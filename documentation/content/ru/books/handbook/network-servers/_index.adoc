//
// The FreeBSD Russian Documentation Project
//
// Original RU revision (18.05.2025): 54ac237fdb34d9074316cd8f8a77832bd618e4f6
//
// Original EN revision (SVN): 42611
//

---
title: Глава 25. Сетевые серверы
part: Часть IV. Сетевые коммуникации
prev: books/handbook/mail
next: books/handbook/firewalls
showBookMenu: true
weight: 30
params:
  path: "/books/handbook/network-servers/"
---

[[network-servers]]
= Сетевые серверы
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 25
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/network-servers/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[network-servers-synopsis]]
== Краткий обзор

Эта глава посвящена некоторым из более часто используемых сетевых сервисов в системах UNIX(R).
Описываются установка, конфигурирование, тестирование и обслуживание многих различных типов сетевых сервисов.
В качестве справочных материалов в эту главу включены примеры конфигурационных файлов.

К концу этой главы читатели будут знать:

* Как управлять даемоном inetd.
* Как настроить сетевую файловую систему NFS (Network File System).
* Как настроить сетевой сервер информации NIS (Network Information Server) для централизации и совместного использования пользовательских учётных записей.
* Как настроить FreeBSD для работы в качестве сервера или клиента LDAP
* Как настроить автоматическое конфигурирование сетевых параметров при помощи DHCP.
* Как настроить сервер имён DNS (Domain Name Server).
* Как настроить Apache HTTP Server.
* Как настроить сервер FTP (File Transfer Protocol).
* Как настроить файловый и сервер печати для Windows(R) клиентов с использованием Samba.
* Как синхронизировать дату и время, а также настроить сервер времени, использующий NTP (Network Time Protocol).
* Как настроить стандартный демон протоколирования, `syslogd`, принимать сообщения от удалённых хостов.

Эта глава предполагает базовые знания:

* Скриптов [.filename]#/etc/rc#.
* Сетевой терминологии.
* Установки дополнительного программного обеспечения сторонних разработчиков (crossref:ports[ports, Установка приложений. Порты и пакеты]).

[[network-inetd]]
== "Супер-сервер" inetd

[[network-inetd-overview]]
=== Обзор

Даемон man:inetd[8] иногда называют также "супер-сервером Интернет", потому что он управляет соединениями с многими сервисами.
Когда inetd принимает соединение, он определяет, для какой программы предназначено соединение, запускает соответствующий процесс и предоставляет ему сокет, ссылка на который передается процессу в качестве стандартных устройств ввода, вывода и сообщения об ошибках. Для не слишком нагруженных серверов запуск через inetd может уменьшить общую нагрузку на систему по сравнению с запуском каждого даемона индивидуально в выделенном режиме.

В первую очередь inetd используется для вызова других даемонов, но несколько простых протоколов, таких, как chargen, auth и daytime, обслуживаются непосредственно.

Этот раздел посвящен основам настройки inetd посредством его параметров командной строки и его конфигурационного файла, [.filename]#/etc/inetd.conf#.

[[network-inetd-settings]]
=== Настройки

inetd инициализируется посредством системы man:rc[8].
Значение параметра `inetd_enable` по умолчанию равно `NO`.
Он может быть включён указанием

[.programlisting]
....
inetd_enable="YES"
....

в [.filename]#/etc/rc.conf#.
Теперь inetd будет запускаться во время загрузки.
Команда

[.programlisting]
....
service inetd rcvar
....

может быть запущена для отображения текущих действующих настроек.

Кроме того, через `inetd_flags` даемону inetd могут быть переданы различные параметры командной строки.

[[network-inetd-cmdline]]
=== Параметры командной строки

Как и большинство серверных даемонов, inetd имеет определённое количество параметров, которые могут быть ему переданы и которые изменяют его поведение.
Обратитесь к странице Справочника man:inetd[8] для получения полного списка параметров.

Опции могут передаваться inetd при помощи переменной `inetd_flags` файла [.filename]#/etc/rc.conf#. По умолчанию переменная `inetd_flags` установлена в `-wW -C 60`, то есть включает обработку TCP wrapping и запрещает обращаться с одного IP-адреса к сервису более чем 60 раз в минуту.

Несмотря на то, что ниже по тексту мы упоминаем опции ограничения частоты обращения к службам (rate-limiting), в большинстве случаев начинающим пользователям нет необходимости менять эти параметры.
Эти параметры могут быть полезными в случае, когда наблюдается чрезмерное количество соединений.
Полный список параметров можно найти на странице справочника man:inetd[8].

-c maximum::
Определение максимального числа одновременных запусков каждой службы; по умолчание не ограничено. Может быть переопределено индивидуально для каждой службы при помощи параметра `max-child`.

-C rate::
Определение по умолчанию максимального количества раз, которое служба может быть вызвана с одного IP-адреса в минуту; по умолчанию не ограничено. Может быть переопределено для каждой службы параметром `max-connections-per-ip-per-minute`.

-R rate::
Определяет максимальное количество раз, которое служба может быть вызвана в минуту; по умолчанию 256. Частота, равная 0, не ограничивает число вызовов.

-s maximum::
Задает максимальное количество процессов, одновременно обслуживающих один сервис для одного IP-адреса; по умолчанию не ограничено. Может переопределяться для каждой службы параметром `max-child-per-ip`.

[[network-inetd-conf]]
=== [.filename]#inetd.conf#

Настройка inetd производится через файл [.filename]#/etc/inetd.conf#.

Если в файле [.filename]#/etc/inetd.conf# делались изменения, то inetd можно заставить считать его конфигурационный файл повторно посредством команды

[[network-inetd-reread]]
.Перезагрузка конфигурационного файла inetd
[example]
====

[source,shell]
....
# service inetd reload
....

====

В каждой строке конфигурационного файла описывается отдельный даемон. Комментариям в файле предшествует знак "#". Строки в файле [.filename]##/etc/inetd.conf## имеют такой формат:

[.programlisting]
....
service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]
user[:group][/login-class]
server-program
server-program-arguments
....

Пример записи для даемона man:ftpd[8], использующего IPv4:

[.programlisting]
....
ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l
....

service-name::
Это имя сервиса, предоставляемого конкретным даемоном. Оно должно соответствовать сервису, указанному в файле [.filename]#/etc/services#. Здесь определяется, какой порт должен обслуживать inetd. При создании нового сервиса он должен помещаться сначала в файл [.filename]#/etc/services#.

socket-type::
`stream`, `dgram`, `raw` либо `seqpacket`. `stream` должен использоваться для ориентированных на соединение даемонов TCP, когда как `dgram` используется для даемонов, использующих транспортный протокол UDP.

protocol::
Одно из следующих:
+

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Протокол
| Описание

|tcp, tcp4
|TCP IPv4

|udp, udp4
|UDP IPv4

|tcp6
|TCP IPv6

|udp6
|UDP IPv6

|tcp46
|TCP как для IPv4, так и для v6

|udp46
|UDP как для IPv4, так и для v6
|===
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]::
`wait|nowait` определяет, может ли даемон, вызванный из inetd, работать с собственным сокетом, или нет. Сокеты типа `dgram` должны использовать параметр `wait`, когда как даемоны с потоковыми сокетами, которые обычно многопоточны, должны использовать `nowait`. `wait` обычно передает много сокетов одному даемону, когда как `nowait` порождает даемон для каждого нового сокета.
+
Максимальное число порожденных даемонов, которых может создать inetd, может быть задано параметром `max-child`. Если нужно ограничение в десять экземпляров некоторого даемона, то после параметра `nowait` нужно задать `/10`. При задании `/0` ограничения на количество экземпляров снимаются.
+
Кроме `max-child`, могут быть задействованы два других параметра, ограничивающих максимальное число соединений от одного источника. `max-connections-per-ip-per-minute` ограничивает количество соединений от одного IP-адреса в течение минуты, например, значение, равное десяти, будет ограничивать любой заданный IP-адрес десятью попытками подключения к некоторому сервису в минуту. Параметр `max-child-per-ip` ограничивает количество дочерних процессов, которые могут быть одновременно задействованы на обслуживание одного IP-адреса. Эти опции полезны для предотвращения намеренного или ненамеренного расходования ресурсов и атак типа Denial of Service (DoS) на машину.
+
В этом поле одно из значений `wait` или `nowait` обязательны. `max-child`, `max-connections-per-ip-per-minute` и `max-child-per-ip` опциональны.
+
Многопоточный даемон типа stream без ограничений `max-child`, `max-connections-per-ip-per-minute` или `max-child-per-ip` будет определен просто как `nowait`.
+
Тот же самый даемон с ограничением в максимум десять даемонов будет определен так: `nowait/10`.
+
Та же конфигурация с ограничением в двадцать соединений на IP-адрес в минуту и общим ограничением в максимум десять порожденных даемонов выглядит так: `nowait/10/20`.
+
Эти параметры, используемые все со значениями по умолчанию даемоном man:fingerd[8], имеют такой вид:
+
[.programlisting]
....
finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s
....
+
Наконец, пример, описывающий ограничение на 100 даемонов в целом, при этом не более чем по 5 на один IP-адрес, будет выглядеть так: `nowait/100/0/5`.

user::
Это имя пользователя, под которым должен работать соответствующий даемон. Чаще всего даемоны работают как пользователь `root`. Для обеспечения безопасности некоторые серверы запускаются как пользователь `daemon` или как пользователь с минимальными правами `nobody`.

server-program::
Полный маршрут к даемону, который будет выполняться при установлении соединения. Если даемон является сервисом, предоставляемым самим inetd, то нужно задать ключевое слово `internal`.

server-program-arguments::
Этот параметр работает вместе с параметром `server-program`, задавая параметры, начиная с `argv[0]`, передаваемые даемону при запуске. Если в командной строке задано `mydaemon -d`, то `mydaemon -d` будет являться значением для `server-program-arguments`. И снова, если даемон является внутренней службой, то здесь нужно использовать `internal`.

[[network-inetd-security]]
=== Безопасность

В зависимости от выбранных при установке параметров, многие из служб inetd могут оказаться по умолчанию включенными. Если нет особой нужды в некотором даемоне, подумайте, не стоит ли его выключить? Поместите знак "#" перед ненужным даемоном в [.filename]##/etc/inetd.conf## и <<network-inetd-reread,пошлите сигнал для inetd>>. Некоторые даемоны, такие, как fingerd, вообще нежелательны, потому что они дают информацию, которая может оказаться полезной атакующему.

Некоторые даемоны не принимают во внимание соображения безопасности и имеют большие или отсутствующие таймауты для попыток соединений.
Атакующий может устанавливать соединения с отдельным даемоном, постепенно потребляя доступные ресурсы и приводя к ситуации отказа в обслуживании DoS (Denial of Service).
Для ограничения подобных атак могут быть использованы `max-connections-per-ip-per-minute`, `max-child` и `max-child-per-ip`.

По умолчанию механизм TCP wrapping включен. Обратитесь к справочной странице по man:hosts_access[5] для получения более подробной информации о задании ограничений TCP для различных даемонов, запускаемых посредством inetd.

[[network-inetd-misc]]
=== Разное

daytime, time, echo, discard, chargen и auth все являются услугами, предоставляемыми самим inetd.

Сервис auth предоставляет идентификационные сетевые услуги и поддается настройке; прочие сервисы ненастраиваемы.

Обратитесь к справочной странице по man:inetd[8] для получения более подробной информации.

[[network-nfs]]
== Network File System (NFS)

FreeBSD поддерживает сетевую файловую систему NFS (Network File System), которая позволяет серверу предоставлять каталоги и файлы клиентам по сети.
С NFS пользователи и программы могут обращаться к файлам на удалённых системах так, как если бы они хранились локально.

Самые заметные выгоды, которые даёт NFS, таковы:

* Данные, которые в противном случае дублировались бы на каждом клиенте, могут храниться в одном месте и быть доступными для клиентов в соответствующей сети.
* Домашние каталоги пользователей могут храниться в одном месте и быть доступными их владельцам по сети.
* Администрирование ресурсов NFS также упрощено. К примеру, политики безопасности и резервного копирования обязательно должны быть установлены только для одной файловой системы.
* Сменные устройства хранения, такие как дискеты или CD-ROM, могут использоваться другими машинами в соответствующей сети. Это снижает количество устройств во всей сети и формирует единый центр управления их безопасностью.

=== Как работает NFS

NFS строится по крайней мере из двух основных частей: сервера и одного или большего количества клиентов. Клиент обращается к данным, находящимся на сервере, в режиме удалённого доступа.
Для того, чтобы это нормально функционировало, необходимо сконфигурировать и запустить несколько процессов.

На сервере обязательно должны работать следующие даемоны:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Даемон
| Описание

|nfsd
|Даемон NFS, обслуживающий запросы от клиентов NFS.

|mountd
|Даемон монтирования NFS, который выполняет запросы, передаваемые ему от man:nfsd[8].

|rpcbind
|Этот даемон позволяет клиентам NFS определить порт, используемый сервером NFS.
|===

Запуск man:nfsiod[8] может улучшить производительность на клиенте, но это не является обязательным требованием.

[[network-configuring-nfs]]
=== Настройка NFS

Активация сервера NFS не является сложной задачей.
Запуск необходимых процессов может быть задан при загрузке добавлением следующих параметров в [.filename]#/etc/rc.conf#:

[.programlisting]
....
rpcbind_enable="YES"
nfs_server_enable="YES"
nfs_server_flags="-u -t -n 4"
mountd_flags="-r"
....

mountd запускается автоматически, если включена функция сервера NFS.

Для включения клиента укажите в [.filename]#/etc/rc.conf# такой параметр:

[.programlisting]
....
nfs_client_enable="YES"
....

[.filename]#/etc/exports# указывает, какие файловые системы будет экспортировать сервер NFS.
Каждая строка в [.filename]#/etc/exports# описывает некоторую файловую систему, которая будет экспортироваться, и то, какие клиенты имеют доступ к этой файловой системе, а также какие-либо параметры доступа.
Имеется много таких параметров, которые можно использовать в этом файле, однако лишь несколько из них будут здесь упомянуты.
Обратитесь к man:exports[5] за полным списком параметров.

Эти примеры дают представление о том, как экспортировать файловые системы.
Для того, чтобы эти примеры работали в сети читателя, им могут потребоваться незначительные изменения.

Этот пример показывает, как экспортировать каталог [.filename]#/cdrom# трём клиентам с именами _alpha_, _bravo_ и _charlie_:

[.programlisting]
....
/cdrom -ro alpha bravo charlie
....

Флаговый параметр `-ro` делает соответствующие файловые системы доступными только в режиме чтения, ограничивая клиентов во внесении каких-либо изменений в экспортированные файловые системы.

В следующем примере экспортируется [.filename]#/home# трём клиентам в соответствии с адресом IP.
Это может быть полезным для сетей без DNS.
Опционально [.filename]#/etc/hosts# может содержать внутренние имена хостов; пожалуйста, просмотрите man:hosts[5] для получения дополнительной информации.
Флаговый парааметр `-alldirs` позволяет подкаталогам быть точками монтирования.
Другими словами, при этом подкаталоги не монтируются, но клиентам разрешается монтировать только те каталоги, которые им требуются или нужны.

[.programlisting]
....
/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4
....

В следующей строке файловая система [.filename]#/a# экспортируется таким образом, что она доступна двум клиентам из других доменов.
Параметр `-maproot=root` позволяет пользователю `root` удалённой системы осуществлять запись на экспортируемую файловую систему как пользователь `root`.
Если параметр `-maproot=root` не задан, то пользователь `root` клиента будет поставлен в соответствие с учётной записью `nobody` сервера, и к нему будут применяться ограничения в доступе, определённые для пользователя `nobody`.

[.programlisting]
....
/a  -maproot=root  host.example.com box.example.org
....

Для того, чтобы клиент имел доступ к экспортированной файловой системе, он должен быть указан в [.filename]#/etc/exports#.

В [.filename]#/etc/exports# каждая строка определяет информацию об экспортировании для одной файловой системы и одного или нескольких клиентов.
Удалённый хост может быть указан только один раз для каждой файловой системы.
К примеру, предположим, что [.filename]#/usr# является отдельной файловой системой.
Следующая запись в [.filename]#/etc/exports# была бы некорректной:

[.programlisting]
....
# Invalid when /usr is one file system
/usr/src   client
/usr/ports client
....

Файловая система [.filename]#/usr# имеет две строки, задающие экспортирование для одного и того же хоста, `client`.
Корректный формат в таком случае таков:

[.programlisting]
....
/usr/src /usr/ports  client
....

Экпортируемая файловая система, её свойства и допустимые хосты должны указываться в одной строке.
Если клиенты не указаны, то любой клиент в сети может монтировать экспортированную файловую систему.

Ниже приведён пример правильного списка экспортирования, где [.filename]#/usr# и [.filename]#/exports# являются локальными файловыми системами:

[.programlisting]
....
# Экспортируем src и ports для client01 и client02, но
# только client01 имеет права пользователя root на них
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports	       client02
# Клиентские машины имеют пользователя root и могут монтировать всё в
# каталоге /exports.  Кто угодно может монтировать /exports/obj в режиме чтения
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro
....

Даемон mountd считывает [.filename]#/etc/exports# при запуске.
Для того, чтобы изменения на сервере NFS вступили в силу немедленно, заставьте mountd считать [.filename]#/etc/exports# повторно в принудительном порядке:

[source,shell]
....
# service mountd reload
....

За дополнительной информацией об использовании скриптов rc, пожалуйста, обратитесь к crossref:config[configtuning-rcd,Использование rc во FreeBSD 5.X и последующих версиях].

На новом сервере, который конфигурируется с сервисами NFS, он может быть запущен пользователем `root` выдачей следующей команды:

[source,shell]
....
# service nfsd start
....

На клиенте NFS:

[source,shell]
....
# service nfsclient restart
....

Теперь на соответствующем клиенте имеется всё, что нужно, для монтирования удалённой файловой системы.
В этих примерах именем сервера является `server`, а именем клиента является `client`.
Для проверки или для временного монтирования удалённой файловой системы запустите mount, работая как пользователь `root` на машине `client`:

[source,shell]
....
# mount server:/home /mnt
....

По этой команде файловая система [.filename]#/home# на машине `server` монтируется в точку монтирования [.filename]#/mnt# на машине `client`.
Файлы и каталоги сервера файловой системы [.filename]#/home# машины `server` теперь будут доступны в каталоге [.filename]#/mnt# на машине `client`.

Для монтирования удалённой файловой системы при каждой загрузке клиента добавьте её в [.filename]#/etc/fstab#.

[.programlisting]
....
server:/home	  /mnt	  nfs	  rw	  0	  0
....

На страницах справочной системы по man:fstab[5] перечислены все доступные параметры.

=== Блокировка файлов

Некоторым приложениям (например, mutt) для корректной работы необходима блокировка файлов.
В случае с NFS для блокировки файлов может использоваться rpc.lockd.
Для его активации добавьте следующую строку в [.filename]#/etc/rc.conf# как на клиенте, так и на сервере:

[.programlisting]
....
rpc_lockd_enable="YES"
rpc_statd_enable="YES"
....

Пожалуйста, заметьте, что при этом предполагается, что как клиент, так и сервер уже сконфигурированы.

Запустите соответствующее приложение, работая как пользователь `root`, при помощи:

[source,shell]
....
# service lockd start
# service statd start
....

Если на сервере блокировка не требуется, то клиент NFS может быть настроен на выполнение локальной блокировки при помощи параметра `-L` команды man:mount_nfs[8].
За дополнительными деталями обратитесь к справочной странице man:mount_nfs[8].

=== Практическое использование

У NFS есть много вариантов практического применения.
Вот некоторые из наиболее часто используемых способов:

* Совместное использование CD-ROM или других носителей с неограниченным количеством клиентов. Зачастую более удобной оказывается установка программного обеспечения на множество машин из единой точки.
* В крупных сетях зачастую более удобной оказывается настройка центрального сервера NFS, на котором размещаются все домашние каталоги пользователей. Пользователи могут войти на клиентскую машину в любом месте этой сети и получить доступ к своим домашним каталогам.
* Нескольким клиентам может быть необходим доступ к каталогу [.filename]#/usr/ports/distfiles#. Совместное использование этого каталога позволяет осуществлять быстрый доступ к исходным файлам без необходимости их сгрузки на каждого клиента.

[[network-amd]]
=== Автоматическое монтирование с amd

man:amd[8] (даемон автоматического монтирования) автоматически монтирует удалённую файловую систему, как только происходит обращение к файлу или каталогу в этой файловой системе. Кроме того, файловые системы, которые были неактивны некоторое время, будут автоматически размонтированы даемоном amd.
amd даёт альтернативный вариант модификации [.filename]#/etc/fstab# для указания каждого клиента.

amd работает, сам выступая как сервер NFS для каталогов [.filename]#/host# и [.filename]#/net#. Когда происходит обращение к файлу в одном из этих каталогов, amd ищет соответствующий удаленный ресурс для монтирования и автоматически его монтирует. [.filename]#/net# используется для монтирования экспортируемой файловой системы по адресу IP, когда как каталог [.filename]#/host# используется для монтирования ресурса по удаленному имени хоста.

К примеру, попытка доступа к файлу в каталоге [.filename]#/host/foobar/usr# указала бы amd на монтирование экспортируемого каталога [.filename]#/usr# хоста `foobar`.

.Монтирование ресурса при помощи amd
[example]
====
`showmount -e` показывает экспортируемые файловые системы, которые могут быть смонтированы с сервера NFS `foobar`:

[source,shell]
....
% showmount -e foobar
Exports list on foobar:
/usr			       10.10.10.0
/a				 10.10.10.0
% cd /host/foobar/usr
....
====

Результат работы `showmount` отображает [.filename]#/usr# как экспортируемый ресурс.
При смене каталога на [.filename]#/host/foobar/usr# amd перехватывает запрос и пытается преобразовать имя хоста `foobar`.
В случае успешного завершения amd автоматически монтирует желаемые ресурс.

amd активируется при помещении такой строки в [.filename]#/etc/rc.conf#:

[.programlisting]
....
amd_enable="YES"
....

Затем он может быть запущен с использованием скриптов FreeBSD man:rc[8] или при помощи команды man:service[8].

Настроечные флаговые параметры могут быть переданы amd через переменную окружения `amd_flags`.
По умолчанию значение `amd_flags` определено следующим образом:

[.programlisting]
....
amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"
....

[.filename]#/etc/amd.map# определяет значения параметров, используемые по умолчанию при монтировании экспортируемых ресурсов.
В [.filename]#/etc/amd.conf# определяются некоторые расширенные возможности amd.

Обратитесь к справочным страницам по man:amd[8] и man:amd.conf[8] для получения более полной информации.

[[network-nis]]
== Network Information System (NIS/YP)

=== Что это такое?

NIS, что является сокращением от Network Information Services (Сетевые Информационные Службы), которые были разработаны компанией Sun Microsystems для централизованного администрирования систем UNIX(R) (изначально SunOS(TM)). В настоящее время эти службы практически стали промышленным стандартом; все основные UNIX(R)-подобные системы (Solaris(TM), HP-UX, AIX(R), Linux, NetBSD, OpenBSD, FreeBSD и так далее) поддерживают NIS.

NIS первоначально назывались Yellow Pages (или yp), но из-за проблем с торговым знаком Sun изменила это название. Старое название (и yp) всё ещё часто употребляется.

Это система клиент/сервер на основе вызовов RPC, которая позволяет группе машин в одном домене NIS совместно использовать общий набор конфигурационных файлов. Системный администратор может настроить клиентскую систему NIS только с минимальной настроечной информацией, а затем добавлять, удалять и модифицировать настроечную информацию из одного места.

Это похоже на систему доменов Windows NT(R); хотя их внутренние реализации не так уж и похожи, основные функции сравнимы.

=== Термины и процессы NIS

Имеется несколько терминов и важных пользовательских процессов, которые будут пояснены параллельно с попытками реализовать NIS во FreeBSD, вне зависимости от того, является ли система сервером или клиентом NIS:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Термин
| Описание

|Имя домена NIS
|Главный сервер NIS и все его клиенты (включая вторичные серверы), имеют доменное имя NIS. Как и в случае с именем домена Windows NT(R), имя домена NIS не имеет ничего общего с DNS.

|rpcbind
|Для обеспечения работы RPC (Remote Procedure Call, Удалённого Вызова Процедур, сетевого протокола, используемого NIS), должен быть запущен даемон rpcbind. Если даемон rpcbind не запущен, невозможно будет запустить сервер NIS, или работать как NIS-клиент.

|ypbind
|"Связывает" NIS-клиента с его NIS-сервером. Он определяет имя NIS-домена системы, и при помощи RPC подключается к серверу. ypbind является основой клиент-серверного взаимодействия в среде NIS; если на клиентской машине программа ypbind перестанет работать, то эта машина не сможет получить доступ к серверу NIS.

|ypserv
|Программа `ypserv`, которая должна запускаться только на серверах NIS: это и есть сервер NIS. Если man:ypserv[8] перестанет работать, то сервер не сможет отвечать на запросы NIS (к счастью, на этот случай предусмотрен вторичный сервер). Есть несколько реализаций NIS (к FreeBSD это не относится), в которых не производится попыток подключиться к другому серверу, если ранее используемый сервер перестал работать. Зачастую единственным средством, помогающим в этой ситуации, является перезапуск серверного процесса (или сервера полностью) или процесса ypbind на клиентской машине.

|rpc.yppasswdd
|Программа `rpc.yppasswdd`, другой процесс, который запускается только на главных NIS-серверах: это даемон, позволяющий клиентам NIS изменять свои пароли NIS. Если этот даемон не запущен, то пользователи должны будут входить на основной сервер NIS и там менять свои пароли.
|===

=== Как это работает?

В системе NIS существует три типа хостов: основные (master) серверы, вторичные (slave) серверы и клиентские машины. Серверы выполняют роль централизованного хранилища информации о конфигурации хостов. Основные серверы хранят оригиналы этой информации, когда как вторичные серверы хранят ее копию для обеспечения избыточности. Клиенты связываются с серверами, чтобы предоставить им эту информацию.

Информация во многих файлах может совместно использоваться следующим образом. Файлы [.filename]#master.passwd#, [.filename]#group# и [.filename]#hosts# используются совместно через NIS. Когда процессу, работающему на клиентской машине, требуется информация, как правило, находящаяся в этих файлах локально, то он делает запрос к серверу NIS, с которым связан.

==== Типы машин

* _Основной сервер NIS_. Такой сервер, по аналогии с первичным контроллером домена Windows NT(R), хранит файлы, используемые всеми клиентами NIS. Файлы [.filename]#passwd#, [.filename]#group# и различные другие файлы, используемые клиентами NIS, находятся на основном сервере.
+
[NOTE]
====
Возможно использование одной машины в качестве сервера для более чем одного домена NIS. Однако, в этом введении такая ситуация не рассматривается, и предполагается менее масштабное использование NIS.
====

* _Вторичные серверы NIS_. Похожие на вторичные контроллеры доменов Windows NT(R), вторичные серверы NIS содержат копии оригинальных файлов данных NIS. Вторичные серверы NIS обеспечивают избыточность, что нужно в критичных приложениях. Они также помогают распределять нагрузку на основной сервер: клиенты NIS всегда подключаются к тому серверу NIS, который ответил первым, в том числе и к вторичным серверам.
* _Клиенты NIS_. Клиенты NIS, как и большинство рабочих станций Windows NT(R), аутентифицируются на сервере NIS (или на контроллере домена Windows NT(R) для рабочих станций Windows NT(R)) во время входа в систему.

=== Использование NIS/YP

В этом разделе приводится пример настройки NIS.

==== Планирование

Давайте предположим, что некий администратор маленькой университетской лаборатории, состоящей из 15 машин FreeBSD, не имеет единую точку администрирования.
На каждой машине имеются собственные файлы [.filename]#/etc/passwd# и [.filename]#/etc/master.passwd#.
Эти файлы синхронизируются друг с другом только средствами неавтоматизированной обработки; в настоящее время при добавлении какого-либо пользователя в лаборатории процесс должен быть выполнен на всех 15 машинах.
Лаборатория бы явно выиграла от добавления двух серверов NIS.

Итак, конфигурация лаборатории сейчас выглядит примерно так:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Имя машины
| IP-адрес
| Роль машины

|`ellington`
|`10.0.0.2`
|Основной сервер NIS

|`coltrane`
|`10.0.0.3`
|Вторичный сервер NIS

|`basie`
|`10.0.0.4`
|Факультетская рабочая станция

|`bird`
|`10.0.0.5`
|Клиентская машина

|`cli[1-11]`
|`10.0.0.[6-17]`
|Другие клиентские машины
|===

Если схема NIS разрабатывается первый раз, она должна быть тщательно спланирована заранее.
Вне зависимости от размера вашей сети в процессе планирования необходимо принять несколько решений.

===== Выбор имени домена NIS

Это имя может не быть обычным "именем домена" для сети.
Более точно оно называется "именем домена NIS".
Когда клиент рассылает запросы на получение информации, он включает в них имя домена NIS, частью которого является. Таким способом многие сервера в сети могут указать, какой сервер на какой запрос должен отвечать. Думайте о домене NIS как об имени группы хостов, которые каким-то образом связаны.

Некоторые организации в качестве имени домена NIS используют свой домен Интернет.
Это не рекомендуется, так как может вызвать проблемы в процессе решения сетевых проблем.
Имя домена NIS должно быть уникальным в пределах соответствующей сети и хорошо, если оно будет описывать группу машин, которую представляет.
Например, художественный отдел в компании Acme Inc. может находиться в домене NIS с именем "acme-art".
В нашем примере положим, что выбранным именем будет `test-domain`.

Несмотря на это, некоторые операционные системы (в частности, SunOS(TM)) используют свое имя домена NIS в качестве имени домена Интернет.
Если одна или большее количество машин в соответствующей сети имеют такие ограничения, то имя домена Интернет должно использоваться в качестве имени домена NIS в _обязательном_ порядке.

===== Требования к серверу

Есть несколько вещей, которые нужно иметь в виду при выборе машины для использования в качестве сервера NIS.
Одной из обескураживающих вещей, касающихся NIS, является уровень зависимости клиентов от серверов.
Если клиент не может подключиться к серверу своего домена NIS, то часто машина становится непригодной к использованию.
Отсутствие информации о пользователях и группах приводит к временной остановке работы большинства систем.
Зная это, обязательно выбирайте машину, которая не будет подвержена частым перезагрузкам или ту, что может не использоваться для разработки.
Сервер NIS в идеале должен быть отдельно стоящей машиной, единственным целью в жизни которой является быть сервером NIS.
Если соответствующая сеть используется не интенсивно, то допускается размещение сервера NIS на машине, на которой запущены другие сервисы, однако если сервер NIS становится недоступным, то это негативно отразится на _всех_ клиентах NIS.

==== Серверы NIS

Оригинальные копии всей информации NIS хранится на единственной машине, которая называется главным сервером NIS. Базы данных, которые используются для хранения информации, называются картами NIS. Во FreeBSD эти карты хранятся в [.filename]#/var/yp/[domainname]#, где [.filename]#[domainname]# является именем обслуживаемого домена NIS. Один сервер NIS может поддерживать одновременно несколько доменов, так что есть возможность иметь несколько таких каталогов, по одному на каждый обслуживаемый домен. Каждый домен будет иметь свой собственный независимый от других набор карт.

Основной и вторичный серверы обслуживают все запросы NIS с помощью даемона `ypserv`. `ypserv` отвечает за получение входящих запросов от клиентов NIS, распознавание запрашиваемого домена и отображение имени в путь к соответствующему файлы базы данных, а также передаче информации из базы данных обратно клиенту.

===== Настройка основного сервера NIS

Настройка основного сервера NIS может быть относительно несложной, в зависимости от потребностей системного окружения, задачей.
FreeBSD сразу поставляется с поддержкой NIS.
Требуется только активировать её, добавив следующие строки в [.filename]#/etc/rc.conf#:

[.procedure]
====
[.programlisting]
....
nisdomainname="test-domain"
....
. Эта строке установит имя домена NIS равным `test-domain` при настройке сети (например, после перезагрузки).
+
[.programlisting]
....
nis_server_enable="YES"
....
. Здесь указывается FreeBSD на запуск процессов серверов NIS, когда дело доходит до сетевых настроек.
+
[.programlisting]
....
nis_yppasswdd_enable="YES"
....
. Здесь указывается на запуск даемона `rpc.yppasswdd`, который, как это отмечено выше, позволит пользователям менять свой пароль NIS с клиентской машины.
====

[NOTE]
====
В зависимости от конфигурации NIS, могут понадобиться дополнительные строки.
Обратитесь к <<network-nis-server-is-client,"разделу о серверах NIS, которые являются также клиентами NIS">> ниже для получения подробной информации.
====

После добавления вышеприведённых строк запустите команду `/etc/netstart`, работая как суперпользователь.
Она выполнит настройку всего, используя значения, заданные в файле [.filename]#/etc/rc.conf#.
На последнем шаге, перед инициализацией карт NIS, запустите вручную даемон ypserv:

[source,shell]
....
# service ypserv start
....

===== Инициализация карт NIS

_Карты NIS_ являются файлами баз данных, которые хранятся в каталоге [.filename]#/var/yp#.
Они генерируются из конфигурационных файлов, находящихся в каталоге [.filename]#/etc# основного сервера NIS, за одним исключением: [.filename]#/etc/master.passwd#.
На это есть весомая причина, ведь никогда не следует распространять пароли `root` и других административных учётных записей на все серверы в домене NIS.
Таким образом, перед инициализацией карт NIS сконфигурируйте первичные файлы паролей:

[source,shell]
....
# cp /etc/master.passwd /var/yp/master.passwd
# cd /var/yp
# vi master.passwd
....

Рекомендуется удалить все записи, касающиеся системных пользователей (`bin`, `tty`, `kmem`, `games` и так далее), а также любые учётные записи, которые не требуется распространять клиентам NIS (например, учётные записи `root` и другие с UID, равным 0 (суперпользователи)).

[NOTE]
====
Удостоверьтесь, что файл [.filename]#/var/yp/master.passwd# недоступен для чтения для группы и для остальных пользователей (режим доступа 600)!
Воспользуйтесь командой `chmod`, если это нужно.
====

Когда эта задача будет завершена, наступает момент инициализации карт NIS.
Во FreeBSD включён скрипт с именем `ypinit`, чтобы сделать это (обратитесь к его справочной странице за дополнительной информацией).
Заметьте, что этот скрипт имеется в большинстве операционных систем UNIX(R), но не во всех. В системе Digital Unix/Compaq Tru64 UNIX он называется `ypsetup`. Так как мы генерируем карты для главного сервера NIS, то при вызове программы `ypinit` мы передаем ей параметр `-m`.
Для генерации соответствующих карт NIS запустите:

[source,shell]
....
ellington# ypinit -m test-domain
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? [y/n: n] n
Ok, please remember to go back and redo manually whatever fails.
If not, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a <control D>.
master server	:  ellington
next host to add:  coltrane
next host to add:  ^D
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] y

[..вывод при генерации карт..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.
....

В этот момент `ypinit` должен был создать файл [.filename]#/var/yp/Makefile# из [.filename]#/var/yp/Makefile.dist#.
При создании этого файла предполагается, что операционным окружением является система с единственным сервером NIS и только с машинами FreeBSD.
Так как в домене `test-domain` имеется также и вторичный сервер, отредактируйте также [.filename]#/var/yp/Makefile#:

[source,shell]
....
ellington# vi /var/yp/Makefile
....

Вы должны закомментировать строку, в которой указано

[.programlisting]
....
NOPUSH = "True"
....

(она уже не раскомментирована).

===== Настройка вторичного сервера NIS

Настройка вторичного сервера NIS осуществляется ещё проще, чем настройка главного сервера. Войдите на вторичный сервер и отредактируйте файл [.filename]#/etc/rc.conf# точно также, как вы делали это ранее. Единственным отличием является то, что при запуске программы `ypinit` мы теперь должны использовать опцию `-s`. Применение опции `-s` требует также указание имени главного сервера NIS, так что наша команда должна выглядеть так:

[source,shell]
....
coltrane# ypinit -s ellington test-domain

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  n

Ok, please remember to go back and redo manually whatever fails.
If not, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Remember to update map ypservers on ellington.
....

Должен существовать каталог с именем [.filename]#/var/yp/test-domain#.
Копии карт главного сервера NIS должны быть в этом каталоге.
Эти файлы должны всегда быть актуальными.
Следующие строки в [.filename]#/etc/crontab# вторичных серверов должны это обеспечить:

[.programlisting]
....
20	*	*	*	*	root   /usr/libexec/ypxfr passwd.byname
21	*	*	*	*	root   /usr/libexec/ypxfr passwd.byuid
....

Эти две строки заставляют вторичный сервер синхронизировать свои карты с картами главного сервера.
Эти строки не являются обязательными, так как главный сервер автоматически пытается передать вторичным серверам все изменения в своих картах NIS, однако, учитывая важность информации о паролях для клиентов, зависящих от вторичного сервера, рекомендуется выполнять частые обновления карт с паролями.
Это особенно важно в загруженных сетях, в которых обновления карт могут не всегда завершаться успешно.

А теперь точно также запустите команду `/etc/netstart` на вторичном сервере, по которой снова выполнится запуск сервера NIS.

==== Клиенты NIS

Клиент NIS выполняет так называемую привязку к конкретному серверу NIS при помощи даемона `ypbind`.
Команда `ypbind` определяет домен, используемый в системе по умолчанию (тот, который устанавливается по команде `domainname`) и начинает широковещательную рассылку запросов RPC в локальной сети.
В этих запросах указано имя домена, к серверу которого `ypbind` пытается осуществить привязку. Если сервер, который был настроен для обслуживания запрашиваемого домена, получит широковещательный запрос, он ответит `ypbind`, который, в свою очередь запомнит адрес сервера. Если имеется несколько серверов (например, главный и несколько вторичных), то `ypbind` будет использовать адрес первого ответившего. С этого момента клиентская система будет направлять все свои запросы NIS на этот сервер. Время от времени `ypbind` будет "пинать" сервер для проверки его работоспособности. Если на один из тестовых пакетов не удастся получить ответа за разумное время, то `ypbind` пометит этот домен как домен, с которым связка разорвана, и снова начнет процесс посылки широковещательных запросов в надежде найти другой сервер.

===== Настройка клиента NIS

Настройка машины с FreeBSD в качестве клиента NIS достаточно проста.

[.procedure]
====

. Отредактируйте [.filename]#/etc/rc.conf#, добавив туда следующие строки для того, чтобы задать имя домена NIS и запустить `ypbind` во время запуска сетевых служб:
+
[.programlisting]
....
nisdomainname="test-domain"
nis_client_enable="YES"
....
+
. Для импортирования всех возможных учётных записей от сервера NIS, удалите все записи пользователей из соответствующего файла [.filename]#/etc/master.passwd# и воспользуйтесь командой `vipw` для добавления следующей строки в конец файла:
+
[.programlisting]
....
+:::::::::
....
+
[NOTE]
======
Эта строка даст всем пользователям с корректной учетной записью в картах учетных баз пользователей доступ к этой системе. Есть множество способов настроить соответствующего клиента NIS, изменив эту строку. Посмотрите ниже текст, касающийся <<network-netgroups,сетевых групп>>, чтобы получить более подробную информацию. Дополнительная информация для изучения находится в книге издательства O'Reilly под названием `Managing NFS and NIS`.
======
+
[NOTE]
======
Имейте в виду, что в [.filename]#/etc/master.passwd# обязательно должна быть по крайней мере одна локальная (то есть не импортированная при помощи NIS) учётная запись, и эта учётная запись должна быть также членом группы `wheel`. Если с NIS что-то случится, эта запись может использоваться для удаленного входа в систему, перехода в режим администратора и исправления неисправностей.
======
+
. Для импортирования всех возможных записей о группах с сервера NIS добавьте в [.filename]#/etc/group# такую строку:
+
[.programlisting]
....
+:*::
....
====

Для немедленного запуска клиента NIS выполните следующую команду с правами пользователя `root`:

[source,shell]
....
# /etc/netstart
# service ypbind start
....

После выполнения этих шагов команда `ypcat passwd` должна показать карту passwd соответствующего сервера.

=== Безопасность NIS

Вообще говоря, любой удалённый пользователь, зная имя вашего домена, может выполнить запрос RPC к man:ypserv[8] и получить содержимое соответствующих карт NIS.
Для предотвращения такого неавторизованного обмена man:ypserv[8] поддерживает так называемую систему "securenets", которая может использоваться для ограничения доступа к некоторой группе хостов. При запуске man:ypserv[8] будет пытаться загрузить информацию, касающуюся securenets, из файла [.filename]#/var/yp/securenets#.

[NOTE]
====
Имя каталога зависит от параметра, указанного вместе с опцией `-p`. Этот файл содержит записи, состоящие из указания сети и сетевой маски, разделенных пробелом. Строчки, начинающиеся со знака "#", считаются комментариями. Примерный файл securenets может иметь примерно такой вид:
====

[.programlisting]
....
# allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0
....

Если man:ypserv[8] получает запрос от адреса, который соответствует одному из этих правил, он будет отрабатывать запрос обычным образом. Если же адрес не подпадает ни под одно правило, запрос будет проигнорирован и в журнал будет записано предупреждающее сообщение. Если файл [.filename]#/var/yp/securenets# не существует, `ypserv` будет обслуживать соединения от любого хоста.

Программа `ypserv` также поддерживает пакет программ TCP Wrapper от Wietse Venema. Это позволяет администратору для ограничения доступа вместо [.filename]#/var/yp/securenets# использовать конфигурационные файлы TCP Wrapper.

[NOTE]
====
Хотя оба этих метода управления доступом обеспечивают некоторую безопасность, они, как основанные на проверке привилегированного порта, оба подвержены атакам типа "IP spoofing".
Весь сетевой трафик, связанный с работой NIS, должен блокироваться соответствующим межсетевым экраном.

Серверы, использующие файл [.filename]#/var/yp/securenets#, могут быть не в состоянии обслуживать старых клиентов NIS с древней реализацией протокола TCP/IP. Некоторые из этих реализаций при рассылке широковещательных запросов устанавливают все биты машинной части адреса в ноль и/или не в состоянии определить маску подсети при вычислении адреса широковещательной рассылки. Хотя некоторые из этих проблем могут быть решены изменением конфигурации клиента, другие могут привести к отказу от использования [.filename]#/var/yp/securenets#.

Использование [.filename]#/var/yp/securenets# на сервере с такой архаичной реализацией TCP/IP является весьма плохой идеей, и приведёт к потере работоспособности NIS в большой части соответствующей сети.

Использование пакета TCP Wrapper увеличивает время отклика соответствующего сервера NIS.
Дополнительной задержки может оказаться достаточно для возникновения тайм-аутов в клиентских программах, особенно в загруженных сетях или с медленными серверами NIS.
Если одна или большее количество соответствующих клиентских систем страдают от таких симптомов, преобразуйте такие клиентские системы во вторичные серверы NIS и выполните их принудительную привязку к самим себе.
====

=== Запрет входа некоторых пользователей

В нашей лаборатории есть машина `basie`, о которой предполагается, что она является исключительно факультетской рабочей станцией. Мы не хотим исключать эту машину из домена NIS, однако файл [.filename]#passwd# на главном сервере NIS содержит учетные записи как для работников факультета, так и студентов. Что мы можем сделать?

Есть способ ограничить вход некоторых пользователей на этой машине, даже если они присутствуют в базе данных NIS.
Чтобы это сделать, добавьте `-_username_` с правильным количеством двоеточий, по аналогии с другими записями, в конец файла [.filename]#/etc/master.passwd# на клиентской машине, где _username_ является именем пользователя, которому ограничивается вход.
Строка с заблокированным пользователем должна располагаться до строки `+` для разрешённых пользователей NIS.
Рекомендуется сделать это с помощью утилиты `vipw`, так как `vipw` будет проверять соответствующие изменения в [.filename]#/etc/master.passwd#, а также автоматически перестроит базу данных паролей после редактирования.
Например, для того, чтобы запретить пользователю `bill` осуществлять вход на машину `basie`:

[source,shell]
....
basie# vipw
[add -bill::::::::: to the end, exit]
vipw: rebuilding the database...
vipw: done

basie# cat /etc/master.passwd

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:*:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:*:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:*:8:8::0:0:News Subsystem:/:/sbin/nologin
man:*:9:9::0:0:Mister Man Pages:/usr/shared/man:/sbin/nologin
bind:*:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
-bill:::::::::
+:::::::::

basie#
....

[[network-netgroups]]
=== Использование сетевых групп

Способ, описанный в предыдущем разделе, работает достаточно хорошо в случае специальных правил в системном окружении с небольшим количеством пользователей и/или машин.
В более крупных сетях администраторы, скорее всего, _будут_ забывать о запрете входа некоторых пользователей на важные машины или может даже будут обязаны настраивать каждую машину по отдельности, теряя таким образом главное преимущество использования NIS: _централизованное_ администрирование.

Ответом разработчиков NIS на эту проблему являются _сетевые группы_. Их назначение и смысл можно сравнить с обычными группами, используемыми в файловых системах UNIX(R). Главное отличие заключается в отсутствии числового идентификатора и возможности задать сетевую группу включением как пользователей, так и других сетевых групп.

Сетевые группы были разработаны для работы с большими, сложными сетями с сотнями пользователей и машин.
С одной стороны, это хорошая вещь в такой ситуации.
С другой стороны, эта сложность делает невозможным описание сетевых групп с помощью по-настоящему простых примеров.
Пример, используемый в оставшейся части раздела, демонстрирует эту проблему.

Давайте предположим, что успешное внедрение системы NIS в соответствующей лаборатории заинтересовало её руководство.
Следующей задачей является расширение домена NIS для покрытия некоторых других машин студенческого городка.
В двух таблицах перечислены имена новых машин и пользователей, а также их краткое описание.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Имена пользователей
| Описание

|`alpha`, `beta`
|Обычные служащие IT-департамента

|`charlie`, `delta`
|Практиканты IT-департамента

|`echo`, `foxtrott`, `golf`, ...
|Обычные сотрудники

|`able`, `baker`, ...
|Проходящие интернатуру
|===

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Имена машин
| Описание

|`war`, `death`, `famine`, `pollution`
|Самые важные уже развёрнутые серверы. Только сотрудникам IT позволяется входить на эти машины.

|`pride`, `greed`, `envy`, `wrath`, `lust`, `sloth`
|Менее важные серверы. Все сотрудники департамента IT могут входить на эти машины.

|`one`, `two`, `three`, `four`, ...
|Обычные рабочие станции. Только _реально нанятым_ служащим позволяется использовать эти машины.

|`trashcan`
|Очень старая машина без каких-либо критичных данных. Даже проходящим интернатуру разрешено ее использовать.
|===

Попытка реализовать эти ограничения путём блокировки каждого пользователя по отдельности потребовала бы добавления строки `-_user_` в [.filename]#passwd# каждой системы.
Одна строка для каждого пользователя, которому не разрешается входить в эту систему.
Упущение всего лишь одной записи может привести к серьёзным неприятностям.
Может быть оправданным делать это корректно во время начальной установки, однако со временем кто-нибудь забудет добавить эти строки для новых пользователей.

Использование в этой ситуации сетевых групп даёт несколько преимуществ.
Нет необходимости обрабатывать каждого пользователя по отдельности; им ставится в соответствие одна или несколько сетевых групп, а регистрация разрешается или запрещается вход для всех членов сетевой группы.
При добавлении новой машины ограничения на вход обязательно должны быть определены для всех сетевых групп.
Если добавляется какой-либой новый пользователь, он в обязательном порядке должен быть привязан к одной или нескольким сетевым группам.
Эти изменения независимы друг от друга: нет больше комбинаций "для каждого пользователя и машины".
Если ландшафт соответствующей NIS тщательно спланирован, то для разрешения или запрета доступа к машинам необходима корректировка только одного конфигурационного файла.

Первым шагом является инициализация карты сетевых групп NIS.
man:ypinit[8] во FreeBSD по умолчанию этой карты не создаёт, однако соответствующая реализация NIS поддерживает эту операцию после создания.
Чтобы создать пустую карту, просто наберите

[source,shell]
....
ellington# vi /var/yp/netgroup
....

и начните добавлять содержимое.
В нашем примере нам нужно по крайней мере четыре сетевых группы: сотрудники IT, практиканты IT, обычные сотрудники и интерны.

[.programlisting]
....
IT_EMP	(,alpha,test-domain)	(,beta,test-domain)
IT_APP	(,charlie,test-domain)	(,delta,test-domain)
USERS	(,echo,test-domain)	(,foxtrott,test-domain) \
	(,golf,test-domain)
INTERNS (,able,test-domain)	(,baker,test-domain)
....

`IT_EMP`, `IT_APP` и так далее являются именами сетевых групп. Несколько слов в скобках служат для добавления пользователей в группу. Три поля внутри группы обозначают следующее:

. Имя хоста или хостов, для которых действительны последующие записи. Если имя хоста не задано, то запись релевантна для всех хостов. Если имя хоста указано, то в рамках данной конфигурации будет требоваться отдельное управление.
. Имя учетной записи, которая принадлежит этой сетевой группе.
. Домен NIS для соответствующей учётной записи. Учётные записи из других доменов NIS могут быть импортированы в сетевую группу.

Каждое из этих полей может содержать шаблоны.
Для получения подробной информации обратитесь к man:netgroup[5].

[NOTE]
====
Не должны использоваться имена сетевых групп длиннее 8 символов, особенно с машинами, работающими под управлением других операционных систем, в соответствующем домене NIS.
Имена чувствительны к регистру; использование заглавных букв для имён сетевых групп является простым способом разделять имена пользователей, машин и сетевых групп.

Некоторые клиенты NIS (отличные от FreeBSD) не могут обрабатывать сетевые группы с большим количеством записей.
Например, в некоторых старых версиях SunOS(TM) возникают проблемы, если сетевая группа содержит более 15 _записей_.
Можно обойти это ограничение, создав несколько сетевых подгрупп с 15 или меньшим количеством пользователей, а также настоящую сетевую группу, состоящую из соответствующих подгрупп:

[.programlisting]
....
BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3
....

Повторите этот процесс, если количество пользователей в одной сетевой группе превысит 225.
====

Активация и распространение соответствующей новой карты NIS просты:

[source,shell]
....
ellington# cd /var/yp
ellington# make
....

Это приведёт к созданию трёх карт NIS, а именно [.filename]#netgroup#, [.filename]#netgroup.byhost# и [.filename]#netgroup.byuser#.
Воспользуйтесь man:ypcat[1] для проверки доступности соответствующих новых карт NIS:

[source,shell]
....
ellington% ypcat -k netgroup
ellington% ypcat -k netgroup.byhost
ellington% ypcat -k netgroup.byuser
....

Результат работы первой команды должен соответствовать содержимому файла [.filename]#/var/yp/netgroup#.
Вторая команда не выведет ничего, если не будут заданы сетевые группы, специфичные для хоста.
Третья команда может использоваться для получения списка сетевых групп пользователя.

Настройка клиента достаточно проста.
Чтобы настроить сервер `war`, воспользуйтесь man:vipw[8] для замены строки

[.programlisting]
....
+:::::::::
....

на

[.programlisting]
....
+@IT_EMP:::::::::
....

Теперь только данные, касающиеся пользователей, определенных в сетевой группе `IT_EMP`, импортируются в базу паролей машины `war` и только этим пользователям будет разрешен вход.

К сожалению, это ограничение также касается и функции `~` командного процессора и всех подпрограмм, выполняющих преобразование между именами пользователей и их числовыми ID.
Другими словами, команда `cd ~_user_` работать не будет, команда `ls -l` будет выдавать числовые идентификаторы вместо имён пользователей, а команда `find . -user joe -print` не будет работать, выдавая сообщение `No such user`.
Чтобы это исправить, импортируйте все пользовательские записи, _не разрешая им вход на соответствующие серверы_.

Это можно сделать, добавив еще одну строку в файл [.filename]#/etc/master.passwd#. Эта строка должна содержать:

`+:::::::::/sbin/nologin`, что означает "Произвести импортирование всех записей с заменой командного процессора на [.filename]#/sbin/nologin# в импортируемых записях".
Возможно заменить любое поле в записи `passwd`, поместив значение по умолчанию в [.filename]#/etc/master.passwd#.

[WARNING]
====

Проверьте, что строка `+:::::::::/sbin/nologin` помещена после `+@IT_EMP:::::::::`. В противном случае все пользовательские записи, импортированные из NIS, будут иметь [.filename]#/sbin/nologin# в качестве оболочки.
====

После этого изменения карта NIS будет требовать модификации только при появлении нового сотрудника подразделения IT.
Похожий подход может применяться для менее важных серверов, при этом старая запись `+:::::::::` в их локальных файлах [.filename]#/etc/master.passwd# заменяется на что-то, подобное следующему:

[.programlisting]
....
+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin
....

Соответствующие строки для обычных рабочих станций могут иметь такой вид:

[.programlisting]
....
+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin
....

И всё было прекрасно до того момента, когда через несколько недель изменилась политика: Департамент IT начал нанимать интернов.
Интернам в IT разрешено использовать обычные рабочие станции и менее важные серверы; практикантам позволили входить на главные серверы.
Добавьте новую сетевую группу `IT_INTERN`, затем добавьте в неё новых интернов из IT и начните изменять конфигурацию на всех и каждой машине.
Как говорит старая мудрость: "Ошибки централизованного планирования приводят к глобальному хаосу".

Возможность в NIS создавать сетевые группы из других сетевых групп может использоваться для предотвращения подобных ситуаций.
Одним из вариантов является создание сетевых групп на основе ролей.
Например, можно создать сетевую группу с именем `BIGSRV` для задания ограничений на вход на важные серверы, другую сетевую группу с именем `SMALLSRV` для менее важных серверов и третью сетевую группу под названием `USERBOX` для обычных рабочих станций.
Каждая из этих сетевых групп содержит сетевые группы, которым позволено входить на эти машины.
Новые записи для соответствующей карты NIS сетевой группы должны выглядеть подобным образом:

[.programlisting]
....
BIGSRV	  IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS
....

Этот метод задания ограничений на вход работает достаточно хорошо, если возможно определить группы машин с одинаковыми ограничениями.
К сожалению, это является исключением, но не правилом.
В большинстве случаев требуется возможность задавать ограничения на вход для каждой машины.

Задание сетевых групп в зависимости от машин является другой возможностью, которой можно воспользоваться при изменении политики, описанной выше. При таком развитии событий файл [.filename]#/etc/master.passwd# на каждой машине содержит две строки, начинающиеся с "+". Первая из них добавляет сетевую группу с учётными записями, которым разрешено входить на эту машину, а вторая добавляет все оставшиеся учетные записи с [.filename]#/sbin/nologin# в качестве командного процессора. Хорошей идеей является использование "ИМЕНИ МАШИНЫ" заглавными буквами для имени сетевой группы. Другими словами, строки должны иметь такой вид:

[.programlisting]
....
+@BOXNAME:::::::::
+:::::::::/sbin/nologin
....

Как только эта работа будет завершена для всех соответствующих машин, повторная модификация локальных версий [.filename]#/etc/master.passwd# больше не потребуется.
Все будущие изменения могут быть выполнены изменением карты NIS. Вот пример возможной карты сетевой группы для этого случая с некоторыми полезными дополнениями:

[.programlisting]
....
# Сначала определяем группы пользователей
IT_EMP	  (,alpha,test-domain)	  (,beta,test-domain)
IT_APP	  (,charlie,test-domain)  (,delta,test-domain)
DEPT1	  (,echo,test-domain)	  (,foxtrott,test-domain)
DEPT2	  (,golf,test-domain)	  (,hotel,test-domain)
DEPT3	  (,india,test-domain)	  (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)	  (,lima,test-domain)
D_INTERNS (,able,test-domain)	  (,baker,test-domain)
#
# Теперь задаем несколько групп на основе ролей
USERS	  DEPT1   DEPT2     DEPT3
BIGSRV	  IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# И группы для специальных задач
# Открыть пользователям echo и golf доступ к антивирусной машине
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# Сетевые группы, специфичные для машин
# Наши главные серверы
WAR	  BIGSRV
FAMINE	  BIGSRV
# Пользователю india необходим доступ к этому серверу
POLLUTION  BIGSRV  (,india,test-domain)
#
# Этот очень важен и ему требуются большие ограничения доступа
DEATH	  IT_EMP
#
# Антивирусная машина, упомянутая выше
ONE	  SECURITY
#
# Ограничить машину единственным пользователем
TWO	  (,hotel,test-domain)
# [...далее следуют другие группы]
....

Если для управления учётными записями пользователей используется какая-либо база данных, то может быть возможным создание первой части соответствующей карты с помощью инструментов построения отчётов этой базы данных.
В таком случае новые пользователи автоматически получат доступ к машинам.

И последнее примечание: Не всегда бывает разумно использовать сетевые группы на основе машин.
При разворачивании пары десятков или даже сотен одинаковых машин в студенческих лабораториях для того, чтобы размер карты NIS оставался в разумных пределах, вместо сетевых групп на основе машин могут использоваться сетевые группы на основе ролей.

=== Важные замечания

Остаётся пара действий, которые администраторам нужно выполнять по-другому, так как машины находятся в среде NIS.

* Каждый раз, когда в лаборатори добавляются новые пользователи, они обязательно должны быть добавлены на главном сервере NIS, а карты NIS будут требовать переформирования. Если этот шаг будет пропущен, то новый пользователь не сможет войти ни в одну систему, кроме как в систему главного сервера NIS. Например, если бы нужно было добавить нового пользователя `jsmith` в лабораторию, то мы бы сделали вот что:
+
[source,shell]
....
# pw useradd jsmith
# cd /var/yp
# make test-domain
....
+
Вместо `pw useradd jsmith` пользователь может быть добавлен командой `adduser jsmith`.
* _Не помещайте административные учётные записи в карты NIS_. Это нежелательно, так как создаёт риски информационной безопасности. Такие пользователи и пароли не должны распространяться на все машины. Особенно если эти машины будут иметь пользователей, которые не должны иметь доступ к подобным учётным записям.
* _Сделайте главный и вторичные серверы NIS безопасными и минимизируйте их время простоя_. Если кто-то либо взломает, либо просто отключит эти машины, то люди без права входа в лабораторию с легкостью получат доступ.
+
Это основное уязвимое место в любой централизованно администрируемой системе. Если серверы NIS не защищены, то будет много разозлённых пользователей и недовольных руководителей!

=== Совместимость с NIS v1

ypserv из поставки FreeBSD имеет определённую поддержку для обслуживания клиентов NIS v1.
Реализация NIS во FreeBSD использует только протокол NIS v2, хотя другие реализации имеют поддержку протокола v1 для обратной совместимости со старыми системами.
Даемоны ypbind, поставляемые с такими системами, будут осуществлять попытки выполнить привязку к серверу NIS v1, даже если это им не нужно (и они будут постоянно рассылать широковещательные запросы в поиске такого сервера даже после получения ответа от сервера v2).
Отметьте, что хотя имеется поддержка обычных клиентских вызовов, эта версия ypserv не отрабатывает запросы на передачу карт v1.
Кроме того, она не может использоваться в качестве главного или вторичного серверов вместе с другими серверами NIS, поддерживающими только протокол v1. К счастью, скорее всего, в настоящий момент такие серверы практически не используются.

[[network-nis-server-is-client]]
=== Серверы NIS, которые также являются клиентами NIS

Особое внимание следует уделить использованию ypserv в домене со многими серверами, когда серверные машины являются также клиентами NIS. Неплохо бы заставить серверы осуществить привязку к самим себе, запретив рассылку запросов на привязку и возможно, перекрестную привязку друг к другу. Если один сервер выйдет из строя, а другие будут зависеть от него, то в результате могут возникнуть странные ситуации. Постепенно все клиенты попадут в тайм-аут и попытаются привязаться к другим серверам, но полученная задержка может быть значительной, а странности останутся, так как серверы снова могут привязаться друг к другу.

Можно заставить хост выполнить привязку к конкретному серверу, запустив команду `ypbind` с флагом `-S`.
Добавьте следующие строки в [.filename]#/etc/rc.conf# для того, чтобы активировать эту функцию при каждой загрузке системы:

[.programlisting]
....
nis_client_enable="YES"   # run client stuff as well
nis_client_flags="-S NIS domain,server"
....

Дополнительную информацию можно найти на странице справки по man:ypbind[8].

=== Форматы паролей

Одной из самых частых проблем, возникающих в начале работы с NIS, является вопрос совместимости форматов паролей.
Если сервер NIS использует пароли, зашифрованные алгоритмом DES, то он будет поддерживать только клиентов, которые также используют DES.
К примеру, если в соответствующей сети имеются клиенты NIS, использующие Solaris(TM), то очень вероятно, что для шифрования паролей должен в обязательном порядке использоваться DES.

Чтобы понять, какой формат используют соответствующие серверы и клиенты, загляните в файл [.filename]#/etc/login.conf#. Если хост настроен на использование паролей, зашифрованных по алгоритму DES, то класс `default` будет содержать запись вроде следующей:

[.programlisting]
....
default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Последующие строки опущены]
....

Другими возможными значениями для `passwd_format` являются `blf` и `md5` (для паролей, шифруемых по стандартам Blowfish и MD5 соответственно).

Если в [.filename]#/etc/login.conf# были внесены какие-либо изменения, то в обязательном порядке должна быть повторно сформирована база данных параметров входа в систему при помощи запуска следующей команды пользователем `root`:

[source,shell]
....
# cap_mkdb /etc/login.conf
....

[NOTE]
====
Формат паролей, которые уже находятся в файле [.filename]#/etc/master.passwd#, не будет изменён до тех пор, пока пользователь не сменит свой пароль _после_ перестроения базы данных параметров входа в систему.
====

После этого, чтобы убедиться в том, что пароли шифруются в выбранном формате, необходимо проверить, что строка `crypt_default` в [.filename]#/etc/auth.conf# даёт приоритет выбранному формату паролей.
Для этого поместите выбранный формат первым в этом списке.
Например, при использовании DES-шифрования паролей строка была бы такова:

[.programlisting]
....
crypt_default	=	des blf md5
....

Выполнив перечисленные выше шаги на каждом из серверов и клиентов NIS под управлением FreeBSD, удостоверьтесь в том, что все они единодушны относительно формата паролей, используемого в соответствующей сети.
Если у вас возникли проблемы с аутентификацией клиента NIS, начать её решать определённо стоит отсюда.
Запомните: при разворачивании сервера NIS в гетерогенной сети, вероятнее всего, придётся использовать DES во всех системах, так как это минимальный общий стандарт.

[[network-ldap]]
== FreeBSD и LDAP

LDAP (Lightweight Directory Access Protocol) является протоколом прикладного уровня, применяемый для доступа, изменения и аутентификации (привязки) с использованием распределённой службы информационного каталога.
Думайте о нём как о телефонной или записной книжке, которая хранит несколько уровней иерархической и однообразной информации.
Он широко используется в сетях, где пользователям зачастую нужен доступ к нескольким уровням внутренней информации, используя одну учётную запись.
Например, аутентификация в системе электронной почты, запрос контактной информации сотрудника и аутентификация на внутреннем веб-сайте могут использовать одного пользователя в базе записей сервера LDAP.

В этом разделе не будет даваться история или детали реализации этого протокола.
Эти разделы были разработаны для того, чтобы сервер и/или клиент LDAP были сконфигурированы быстро и одновременно безопасно; однако любая информационная база требует планирования, и данный случай не является исключением.

Планирование должно включать определение того, какой тип информации будет храниться, для чего эта информация будет использоваться, кто должен иметь доступ к этой информации, и как защитить эту информацию от любопытных глаз.

=== Терминология и структура LDAP

Перед тем, как продолжить, и во избежание недопонимания, обязательно должны быть разъяснены несколько компонентов LDAP.
А путаница с этой конфигурацией относительно легка.
Для начала, все записи каталога состоят из некой группы _атрибутов_.
Каждый из этих наборов атрибутов содержит некоторое имя, уникальный идентификатор, известный как DN или уникальное имя, обычно формируемые из нескольких других атрибутов, таких как RDN.
RDN, или относительное уникальное имя, является более общим именем для атрибута.
Как и каталоги, которые имеют абсолютные и относительные пути, считайте DN абсолютным путём, а RDN относительным путём.

Например, запись может выглядеть подобно следующему:

[source,shell]
....
% ldapsearch -xb "uid=trhodes,ou=users,o=example.com"
....

[.programlisting]
....
# extended LDIF
#
# LDAPv3
# base <uid=trhodes,ou=users,o=example.com> with scope subtree
# filter: (objectclass=*)
# requesting: ALL
#

# trhodes, users, example.com
dn: uid=trhodes,ou=users,o=example.com
mail: trhodes@example.com
cn: Tom Rhodes
uid: trhodes
telephoneNumber: (xxx) xxx-xxxx

# search result
search: 2
result: 0 Success

# numResponses: 2
# numEntries: 1
....

В данном примере весьма очевидно, чем являются различные атрибуты; однако следует обратить внимание на атрибут cn.
Это RDN, описанный ранее.
Кроме того, здесь указан уникальный пользовательский идентификатор.
Распространённой практикой является наличие специфичных uid или uuid для записей, что облегчает какие-либо интеграции в будущем.

=== Конфигурирование сервера LDAP

Чтобы сконфигурировать FreeBSD для работы в качестве сервера LDAP, требуется установка порта OpenLDAP.
Это можно сделать при помощи команды `pkg_add` или путём установки порта [.filename]#net/openldap24-server#.
Рекомендуемым способом является построение порта, так как при этом администратор может выбрать из большого количества параметров или отключить некоторые из них.
В большинстве случаев подойдут значения, используемые по умолчанию; однако в этот момент можно включить поддержку SQL, если она нужна.

После этого будет требоваться пара каталогов, как минимум это каталог с данными и каталог для хранения в нём сертификатов.
Создайте оба этих каталога при помощи следующих команд:

[source,shell]
....
# mkdir /var/db/openldap-data
....

[source,shell]
....
# mkdir /usr/local/etc/openldap/private
....

Скопируйте соответствующий конфигурационный файл базы данных:

[source,shell]
....
# cp /usr/local/etc/openldap/DB_CONFIG.example /var/db/openldap-data/DB_CONFIG
....

Следующим этапом является конфигурирование сертификатов SSL.
Хотя создание сертификатов обсуждается в разделе crossref:security[openssl,"OpenSSL"] этой книги, будет использоваться другой метод, так как требуется сертификационный центр.
Рекомендуется просмотреть этот раздел до начала конфигурирования, чтобы обеспечить ввод корректной информации в процессе создания сертификата ниже.

Следующие команды необходимо исполнять в каталоге [.filename]#/usr/local/etc/openldap/private#.
Это важно, так как полномочия на файлы должны быть ограничивающими, и пользователи не должны иметь прямой доступ к этим файлам.
Для создания соответствующих сертификатов запустите указанные ниже команды.

[source,shell]
....
# openssl req -days 365 -nodes -new -x509 -keyout ca.key -out ../ca.crt
....

Записи для этого могут иметь полностью общий характер, _кроме_ записи _Common Name_.
Эта запись обязательно должна содержать что-то, отличающееся от имени хоста системы.
Если запись будет соответствовать имени хоста, то это будет выглядеть как попытка имени хоста верифицировать имя хоста.
В случаях с самостоятельно подписанным сертификатом, как в этом примере, укажите перед именем хоста CA, что соответствует сертификационному центру.

Следующей заадчей является формирование запроса на подписание сертификата и закрытого ключа.
Для этого запустите следующие команды:

[source,shell]
....
# openssl req -days 365 -nodes -new -keyout server.key -out server.csr
....

В процессе генерации сертификата удостоверьтесь в корректном указании атрибута общего имени.
После завершения потребуется подписать соответствующий ключ:

[source,shell]
....
# openssl x509 -req -days 365 -in server.csr -out ../server.crt -CA ../ca.crt -CAkey ca.key -CAcreateserial
....

Завершающей частью процесса формирования сертификата является генерация и подписание соответствующих клиентских сертификатов:

[source,shell]
....
# openssl req -days 365 -nodes -new -keyout client.key -out client.csr
....

[source,shell]
....
# openssl x509 -req -days 3650 -in client.csr -out ../client.crt -CA ../ca.crt -CAkey ca.key
....

И снова не забудьте обратить внимание на атрибут общего имени.
Он является распространённой причиной путаницы во время первой попытки сконфигурировать LDAP.
Дополнительно удостоверьтесь в том, что при исполнении соответствующих команд всего было сгенерировано 8 (восемь) новых файлов.
Если это так, то следующим шагом будет являться редактирование [.filename]#/usr/local/etc/openldap/slapd.conf# и добавление следующих параметров:

[.programlisting]
....
TLSCipherSuite HIGH:MEDIUM:+SSLv3
TLSCertificateFile /usr/local/etc/openldap/server.crt
TLSCertificateKeyFile /usr/local/etc/openldap/private/server.key
TLSCACertificateFile /usr/local/etc/openldap/ca.crt
....

Кроме того, отредактируйте [.filename]#/usr/local/etc/openldap/ldap.conf# и добавьте следующие строки:

[.programlisting]
....
TLS_CACERT /usr/local/etc/openldap/ca.crt
TLS_CIPHER_SUITE HIGH:MEDIUM:+SSLv3
....

При редактировании этих файлов задайте желаемое значение для `BASE` и раскомментируйте все три параметра `URI`, `SIZELIMIT` и `TIMELIMIT`.
Кроме того, задайте значение `URI`, содержащее `ldap://` и `ldaps://`.

Получившийся файл должен выглядеть подобно показанному ниже:

[.programlisting]
....
BASE    dc=example,dc=com
URI     ldap:// ldaps://

SIZELIMIT       12
TIMELIMIT       15
#DEREF          never

TLS_CACERT /usr/local/etc/openldap/ca.crt
TLS_CIPHER_SUITE HIGH:MEDIUM:+SSLv3
....

Для сервера необходимо создать пароль, так как значение, применяемое по умолчанию, чрезвычайно уязвимо, и это нормально для отрасли.
Чтобы это сделать, запустите следюущую команду, направив результат в [.filename]#slapd.conf#:

[source,shell]
....
# slappasswd -h "{SHA}" &gt;&gt; /usr/local/etc/openldap/slapd.conf
....

Будет выдан запрос для ввода соответствующего пароля и, если процесс завершится без сбоев, его хешированное значение будет добавлено в конец файла [.filename]#slapd.conf#.
`slappasswd` работает с несколькими форматами хеширования, за дополнительной информацией нужно обратиться к соответствующей странице справочника.

Отредактируйте [.filename]#/usr/local/etc/openldap/slapd.conf# и добавьте следующие строки:

[.programlisting]
....
password-hash {sha}
allow bind_v2
....

Кроме того, `suffix` в этом файле обязательно должен быть актуализирован, чтобы соответствовать `BASE` из предыдущей настройки.
Также должен быть задан параметр `rootdn`.
Неплохим рекомендуемым вариантом является что-то, подобное `cn=Manager`.
До того, как сохранять этот файл, поместите параметр `rootpw` перед выдачей пароля из `slappasswd` и удалите старый параметр `rootpw` выше.
Итоговый результат должен выглядеть подобно следующему:

[.programlisting]
....
TLSCipherSuite HIGH:MEDIUM:+SSLv3
TLSCertificateFile /usr/local/etc/openldap/server.crt
TLSCertificateKeyFile /usr/local/etc/openldap/private/server.key
TLSCACertificateFile /usr/local/etc/openldap/ca.crt
rootpw  {SHA}W6ph5Mm5Pz8GgiULbPgzG37mj9g=
....

Наконец, активируйте сервис OpenLDAP в [.filename]#rc.conf#.
В этот момент могут быть полезными указание URI и определение группы и пользователя, с полномочиями которых будет выполняться запуск.
Отредактируйте [.filename]#/etc/rc.conf# и добавьте следующие строки:

[.programlisting]
....
slapd_enable="YES"
slapd_flags="-4 -h ldaps:///"
....

На этом этапе сервер должен быть готов к запуску и тестированию.
Для выполнения этой задачи запустите следующую команду:

[source,shell]
....
# service slapd start
....

Если всё было сконфигурировано корректно, поиск каталога должен показать успешное соединение с единственным откликом, как в этом примере:

[source,shell]
....
# ldapsearch -Z
....

[.programlisting]
....
# extended LDIF
#
# LDAPv3
# base <dc=example,dc=com> (default) with scope subtree
# filter: (objectclass=*)
# requesting: ALL
#

# search result
search: 3
result: 32 No such object

# numResponses: 1
....

Полагая, что сервис теперь должен откликаться, как выше, соответствующий каталог может заполняться посредством команды `ldapadd`.
В этом примере имеется файл, содержащий список пользователей для добавления к этому конкретному каталогу.
Во-первых, создайте файл для импортирования со следующим набором данных:

[.programlisting]
....
dn: dc=example,dc=com
objectclass: dcObject
objectclass: organization
o: Example
dc: Example

dn: cn=Manager,dc=example,dc=com
objectclass: organizationalRole
cn: Manager
....

[NOTE]
====
Для диагностики любых операций далее остановите сервис `slapd` командой `service` и запустите его с диагностическими параметрами.
Для этого запустите следующую команду:

[source,shell]
....
# /usr/local/libexec/slapd -d -1</userinput>
....
====

Чтобы импортировать этот файл данных, запустите следующую команду, полагая, что соответствующим файлом является [.filename]#import.ldif#:

[source,shell]
....
# ldapadd -Z -D "cn=Manager,dc=example,dc=com" -W -f import.ldif
....

Будет выдан запрос на пароль, указанный ранее, а выдаваемый результат должен выглядеть подобно следующему:

[source,shell]
....
Enter LDAP Password:
adding new entry "dc=example,dc=com"

adding new entry "cn=Manager,dc=example,dc=com"
....

Проверьте добавление данных, запустив поиск на сервере при помощи `ldapsearch`.
В данном случае выдаваемый результат должен выглядеть подобно следующему:

[source,shell]
....
# ldapsearch -Z
....

[source,shell]
....
# extended LDIF
#
# LDAPv3
# base <dc=example,dc=com> (default) with scope subtree
# filter: (objectclass=*)
# requesting: ALL
#

# example.com
dn: dc=example,dc=com
objectClass: dcObject
objectClass: organization
o: Example
dc: Example

# Manager, example.com
dn: cn=Manager,dc=example,dc=com
objectClass: organizationalRole
cn: Manager

# search result
search: 3
result: 0 Success

# numResponses: 3
# numEntries: 2
....

Конечно же, рекомендуется ознакомиться со структурой каталогов LDAP и различными справочными страницами, упомянутыми в этом разделе.
К данному моменту сервер должен быть сконфигурирован и функционировать корректно.

[[network-dhcp]]
== Автоматическая настройка сети (DHCP)

=== Что такое DHCP?

DHCP, или Dynamic Host Configuration Protocol (Протокол Динамической Конфигурации Хостов), описывает порядок, по которому система может подключиться к сети и получить необходимую информацию для работы в ней. Во FreeBSD используется `dhclient`, импортированный из OpenBSD 3.7. Вся информация здесь, относительно `dhclient` относится либо к ISC, либо к DHCP клиентам. DHCP сервер включён в ISC дистрибутив.

=== Что описывается в этом разделе

В этом разделе описываются, как компоненты клиентской части ISC или OpenBSD DHCP клиента, так и компоненты ISC DHCP системы со стороны сервера. Программа, работающая на клиентской стороне, `dhclient`, интегрирована в поставку FreeBSD, а серверная часть доступна в виде порта package:net/isc-dhcp42-server[]. Кроме ссылок ниже, много полезной информации находится на страницах справочной системы, описывающих man:dhclient[8], man:dhcp-options[5] и man:dhclient.conf[5].

=== Как это работает

Когда на клиентской машине выполняется программа `dhclient`, являющаяся клиентом DHCP, она начинает широковещательную рассылку запросов на получение настроечной информации. По умолчанию эти запросы делаются на 68 порт UDP. Сервер отвечает на UDP 67, выдавая клиенту адрес IP и другую необходимую информацию, такую, как сетевую маску, маршрутизатор и серверы DNS. Вся эта информация даётся в форме "аренды" DHCP и верна только определенное время (что настраивается администратором сервера DHCP). При таком подходе устаревшие адреса IP тех клиентов, которые больше не подключены к сети, могут автоматически использоваться повторно.

Клиенты DHCP могут получить от сервера очень много информации. Подробный список находится в странице Справочника man:dhcp-options[5].

=== Интеграция с FreeBSD

DHCP клиент от OpenBSD, `dhclient`, полностью интегрирован во FreeBSD. Поддержка клиента DHCP есть как в программе установки, так и в самой системе, что исключает необходимость в знании подробностей конфигурации сети в любой сети, имеющей сервер DHCP.

DHCP поддерживается утилитой sysinstall. При настройке сетевого интерфейса из программы sysinstall второй вопрос, который вам задается: "Do you want to try DHCP configuration of the interface?" ("Хотите ли вы попробовать настроить этот интерфейс через DHCP?"). Утвердительный ответ приведёт к запуску программы `dhclient`, и при удачном его выполнении к автоматическому заданию информации для настройки интерфейса.

Есть две вещи, которые необходимы для того, чтобы ваша система использовала DHCP при загрузке:

* Убедитесь, что устройство [.filename]#bpf# включено в компиляцию соответствующего ядра. Чтобы это сделать, добавьте строчку `device bpf` в конфигурационный файл ядра и перестройте ядро. Более подробная информация о построении ядер имеется в crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]. Устройство [.filename]#bpf# уже является частью ядра [.filename]#GENERIC#, поставляемого с FreeBSD, так что для обеспечения работы DHCP построение специального ядра не требуется. В случае использования специального ядра для корректной работы DHCP требуется присутствие этого устройства.
+
[NOTE]
====
Те, кто беспокоится о безопасности, должны иметь в виду, что устройство `bpf` является также тем самым устройством, которое позволяет работать программам-снифферам пакетов (хотя для этого они должны быть запущены пользователем `root`). Наличие устройства `bpf` _необходимо_ для использования DHCP, однако при повышенном внимании к безопасности, вероятно, не нужно добавлять устройство `bpf` в ядро из-за предположений, что в какой-то момент в будущем система будет использовать DHCP.
====
+
* По умолчанию, конфигурирование FreeBSD по протоколу DHCP выполняется фоновым процессом, или _асинхронно_. Остальные стартовые скрипты продолжают работу не ожидая завершения процесса конфигурирования, тем самым ускоряя загрузку системы.
+ 
Фоновое конфигурирование не создает проблем в случае, если сервер DHCP быстро отвечает на запросы, и процесс конфигурирования происходит быстро. Однако, в некоторых случаях настройка по DHCP может длиться значительное время. При этом запуск сетевых сервисов может потерпеть неудачу, если будет произведен ранее завершения конфигурирования по DHCP. Запуск DHCP в _синхронном_ режиме предотвращает проблему, откладывая выполнение остальных стартовых скриптов до момента завершения конфигурирования по DHCP.
+ 
Для осуществления фонового конфигурирования по DHCP (асинхронный режим), используйте значение "`DHCP`" в [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
ifconfig_fxp0="DHCP"
....

+ 
Для откладывания запуска стартовых скриптов до завершения конфигурирования по DHCP (синхронный режим), укажите значение "`SYNCDHCP`":
+
[.programlisting]
....
ifconfig_fxp0="SYNCDHCP"
....

+
[NOTE]
====
Замените используемое в этих примерах имя _fxp0_ на имя интерфейса, который необходимо сконфигурировать динамически, как это описано в crossref:config[config-network-setup,Настройка карт сетевых интерфейсов].
====

+
При размещении `dhclient` в другом месте файловой системы, либо при обязательной необходимости передать дополнительные параметры `dhclient`, добавьте следующее (изменив по потребности):
+
[.programlisting]
....
dhclient_program="/sbin/dhclient"
dhclient_flags=""
....

Сервер DHCP, dhcpd, включён как часть порта package:net/isc-dhcp42-server[] в коллекцию портов. Этот порт содержит DHCP-сервер от ISC и документацию.

=== Файлы

* [.filename]#/etc/dhclient.conf#
+ 
`dhclient` требует наличия конфигурационного файла, [.filename]#/etc/dhclient.conf#. Как правило, файл содержит только комментарии, а настройки по умолчанию достаточно хороши. Этот настроечный файл описан на страницах справочной системы по man:dhclient.conf[5].
* [.filename]#/sbin/dhclient#
+ 
`dhclient` скомпонован статически и находится в каталоге [.filename]#/sbin#. На страница Справочника man:dhclient[8] дается более подробная информация о `dhclient`.
* [.filename]#/sbin/dhclient-script#
+ 
`dhclient-script` является специфичным для FreeBSD скриптом настройки клиента DHCP. Он описан в man:dhclient-script[8], но для нормального функционирования никаких модификаций со стороны пользователя не требуется.
* [.filename]#/var/db/dhclient.leases.interface#
+ 
В этом файле клиент DHCP хранит базу данных выданных к использованию адресов в виде журнала. На странице man:dhclient.leases[5] дается гораздо более подробное описание.

=== Дополнительная литература

Полное описание протокола DHCP дается в http://www.freesoft.org/CIE/RFC/2131/[RFC 2131]. Кроме того, дополнительная информация есть на сервере http://www.dhcp.org/[http://www.dhcp.org/].

[[network-dhcp-server]]
=== Установка и настройка сервера DHCP

==== Чему посвящён этот раздел

Этот раздел даёт информацию о том, как настроить систему FreeBSD для работы в качестве сервера DHCP на основе реализации пакета DHCP от ISC (Internet Systems Consortium).

Сервер не является частью FreeBSD, так что обеспечения этого сервиса обязательно нужно установить порт package:net/isc-dhcp42-server[].
Обратитесь к разделу crossref:ports[ports, Установка приложений. Порты и пакеты] для получения дополнительной информации об использовании Коллекции портов.

==== Установка сервера DHCP

Для того, чтобы сконфигурировать систему FreeBSD для работы в качестве сервера DHCP, сначала обеспечьте присутствие устройства man:bpf[4], вкомпилированного в соответствующее ядро.
Для этого добавьте строку `device bpf` в файл конфигурации соответствующего ядра и перестройте его.
Для получения дополительной информации о построении ядер, обратитесь к разделу crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD].

Устройство [.filename]#bpf# уже входит в состав ядра [.filename]#GENERIC#, поставляемого с FreeBSD, так что вам не нужно создавать отдельное ядро для обеспечения работы DHCP.

[NOTE]
====
Те, кто обращает особое внимание на вопросы безопасности, должны заметить, что [.filename]#bpf# является тем устройством, что позволяет нормально функционировать снифферам пакетов (хотя таким программам требуются привилегированный доступ).
Для использования DHCP наличие устройства является `bpf` _обязательным_, однако при высоком уровне внимания к безопасности системы это устройство вообще не должно включаться в ядро лишь потому, что в отдалённом будущем будет желательно использовать DHCP.
====

Пример конфигурационного файла устаналивается в составе порта package:net/isc-dhcp42-server[].
Скопируйте этот пример [.filename]#/usr/local/etc/dhcpd.conf.example# в актуальный конфигурационный файл [.filename]#/usr/local/etc/dhcpd.conf#.
Корректировки будут вноситься в этот новый файл.

==== Настройка сервера DHCP

[.filename]#dhcpd.conf# состоит из деклараций относительно подсетей и хостов, и проще всего описывается на примере:

[.programlisting]
....
option domain-name "example.com";<.>
option domain-name-servers 192.168.4.100;<.>
option subnet-mask 255.255.255.0;<.>

default-lease-time 3600;<.>
max-lease-time 86400;<.>
ddns-update-style none;<.>

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<.>
  option routers 192.168.4.1;<.>
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<.>
  fixed-address mailhost.example.com;<.>
}
....

<.> Этот параметр задаёт домен, который будет выдаваться клиентам в качестве домена, используемого по умолчанию при поиске. Обратитесь к страницам справочной системы по man:resolv.conf[5] для получения дополнительной информации о том, что это значит.

<.> Этот параметр задаёт список разделённых запятыми серверов DNS, которые должен использовать клиент.

<.> Маска сети, которая будет выдаваться клиентам.

<.> Клиент может запросить определённое время, которое будет действовать выданная информация. В противном случае сервер выдаст настройки с этим сроком (в секундах).

<.> Это максимальное время, на которое сервер будет выдавать конфигурацию. Если клиент запросит больший срок, он будет подтверждён, но будет действовать только `max-lease-time` секунд.

<.> Этот параметр задаёт, будет ли сервер DHCP пытаться обновить DNS при выдаче или освобождении конфигурационной информации. В реализации ISC этот параметр является _обязательным_.

<.> Это определение того, какие IP-адреса должны использоваться в качестве резерва для выдачи клиентам. IP-адреса между и включая границы, будут выдаваться клиентам.

<.> Объявление маршрутизатора, используемого по умолчанию, который будет выдаваться клиентам.

<.> Аппаратный MAC-адрес хоста (чтобы сервер DHCP мог распознать хост, когда тот делает запрос).

<.> Определение того, что хосту всегда будет выдаваться один и тот же IP-адрес. Заметьте, что указание здесь имени хоста корректно, так как сервер DHCP будет разрешать имя хоста самостоятельно до того, как выдать конфигурационную информацию.

После завершения настройки [.filename]#dhcpd.conf# активируйте сервер DHCP в [.filename]#/etc/rc.conf#, то есть добавьте:

[.programlisting]
....
dhcpd_enable="YES"
dhcpd_ifaces="dc0"
....

Замените `dc0` именем интерфейса (или именами интерфейсов, разделяя их пробелами), на котором сервер DHCP должен принимать запросы от клиентов DHCP.

Продолжите, запустив сервер выдачей следующей команды:

[source,shell]
....
# service isc-dhcpd start
....

Любые будущие изменения в конфигурации соответствующего сервера будут требовать отправки приложению `dhcpd` сигнала `SIGTERM`, а не `SIGHUP`.
Определённо проще для полного перезапуска сервиса использовать man:service[8].

==== Файлы

* [.filename]#/usr/local/sbin/dhcpd#
+ 
dhcpd скомпонован статически и расположен в каталоге [.filename]#/usr/local/sbin#. Страницы справочной системы man:dhcpd[8], устанавливаемые портом, содержат более полную информацию о dhcpd.
* [.filename]#/usr/local/etc/dhcpd.conf#
+ 
dhcpd требует наличия конфигурационного файла, [.filename]#/usr/local/etc/dhcpd.conf#, до того, как он будет запущен и начнёт предоставлять сервис клиентам. Необходимо, чтобы этот файл содержал все данные, которая будет выдаваться обслуживаемым клиентам, а также информацию о работе сервера. Этот конфигурационный файл описывается на страницах справочной системы man:dhcpd.conf[5], которые устанавливаются портом.
* [.filename]#/var/db/dhcpd.leases#
+ 
Сервер DHCP ведёт базу данных выданной информации в этом файле, который записывается в виде протокола. Страницы справочной системы man:dhcpd.leases[5], устанавливаемые портом, дают гораздо более подробное описание.
* [.filename]#/usr/local/sbin/dhcrelay#
+ 
dhcrelay используется в сложных системных ландшафтах, когда сервер DHCP пересылает запросы от клиента другому серверу DHCP в отдельной сети. Если имеется потребность в такой функциональности, то установите порт package:net/isc-dhcp42-relay[]. На страницах справочной системы man:dhcrelay[8], которые устанавливаются портом, даётся более полное описание.

[[network-dns]]
== Domain Name System (DNS)

=== Обзор

По умолчанию во FreeBSD используется одна из версий программы BIND (Berkeley Internet Name Domain), являющейся самой распространенной реализацией протокола DNS. DNS - это протокол, при помощи которого имена преобразуются в IP-адреса и наоборот. Например, в ответ на запрос о `www.FreeBSD.org` будет получен IP-адрес веб-сервера Проекта FreeBSD, а запрос о `ftp.FreeBSD.org` возвратит IP-адрес соответствующей машины с FTP-сервером. Точно также происходит и обратный процесс. Запрос, содержащий IP-адрес машины, возвратит имя хоста. Для выполнения запросов к DNS вовсе не обязательно иметь в системе работающий сервер имён.

FreeBSD в настоящее время поставляется с сервером DNSBIND9, предоставляющим расширенные настройки безопасности, новую схему расположения файлов конфигурации и автоматические настройки для man:chroot[8].

В сети Интернет DNS управляется через достаточно сложную систему авторизированных корневых серверов имён, серверов доменов первого уровня (Top Level Domain, TLD) и других менее крупных серверов имён, которые содержат и кэшируют информацию о конкретных доменах.

На данный момент пакет BIND поддерживается Internet Systems Consortium https://www.isc.org/[https://www.isc.org/].

=== Используемая терминология

Для понимания этого документа нужно понимать значения некоторых терминов, связанных с работой DNS.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Термин
| Определение

|Прямой запрос к DNS (forward DNS)
|Преобразование имён хостов в адреса IP

|Ориджин (origin)
|Обозначает домен, покрываемый конкретным файлом зоны

|named, bind
|Общеупотребительные названия для обозначения пакета BIND, обеспечивающего работу сервера имён во FreeBSD.

|Резолвер
|Системный процесс, посредством которого машина обращается к серверу имён для получения информации о зоне

|Обратный DNS (reverse DNS)
|Преобразование адресов IP в имена хостов

|Корневая зона
|Начало иерархии зон Интернет. Все зоны находятся под корневой зоной, подобно тому, как все файлы располагаются ниже корневого каталога.

|Зона
|Отдельный домен, поддомен или часть DNS, управляемая одним сервером.
|===

Примеры зон:

* `.` - так обычно обозначается в документации корневая зона.
* `org.` - домен верхнего уровня (TLD) в корневой зоне.
* `example.org.` является зоной в домене верхнего уровня (TLD) `org.`.
* `1.168.192.in-addr.arpa` является зоной, в которую включены все IP-адреса, формирующие пространство адресов `192.168.1.*`.

Как можно видеть, уточняющая часть имени хоста появляется слева. Например, `example.org.` более точен, чем `org.`, также, как `org.` более точен, чем корневая зона. Расположение каждой части имени хоста сильно похоже на файловую систему: каталог [.filename]#/dev# расположен в корневой файловой системе, и так далее.

=== Причины, по которым вам может понадобиться сервер имён

Сервера имён обычно используются в двух видах: авторитетный сервер имён и кэширующий сервер имён, также называемый распознавателем (resolver).

Авторитетный сервер имён нужен, когда:

* нужно предоставлять информацию о DNS остальному миру, отвечая на запросы авторизированно.
* зарегистрирован домен, такой, как `example.org` и в этом домене требуется поставить имена машин в соответствие с их адресами IP.
* блоку адресов IP требуется обратные записи DNS (IP в имена хостов).
* резервный (slave) сервер имён должен отвечать на запросы.

Кэширующий сервер имён нужен, когда:

* локальный сервер DNS может кэшировать информацию и отвечать на запросы быстрее, чем это происходит при прямом опросе внешнего сервера имён.

Например, когда кто-нибудь запрашивает информацию о `www.FreeBSD.org`, то обычно резолвер обращается к серверу имён вашего провайдера, посылает запрос и ожидает ответа. С локальным кэширующим сервером DNS запрос во внешний мир будет делаться всего один раз. Последующие запросы не будут посылаться за пределы локальной сети, потому что информация уже имеется в кэше.

=== Как это работает

Во FreeBSD даемон BIND называется named.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Файл
| Описание

|man:named[8]
|Даемон BIND

|man:rndc[8]
|Программа управления даемоном сервера имён

|[.filename]#/etc/namedb#
|Каталог, в котором располагается вся информация о зонах BIND

|[.filename]#/etc/namedb/named.conf#
|Конфигурационный файл для даемона
|===

Файлы зон обычно располагаются в каталоге [.filename]#/etc/namedb# и содержат информацию о зоне DNS, за которую отвечает сервер имён.

В зависимости от способа конфигурации зоны на сервере файлы зон могут располагаться в подкаталогах [.filename]#master#, [.filename]#slave# или [.filename]#dynamic# иерархии [.filename]#/etc/namedb#. Эти файлы содержат DNS информацию, которую и будет сообщать в ответ на запросы сервер имен.

=== Запуск BIND

Так как сервер имён BIND устанавливается по умолчанию, его настройка сравнительно проста.

Стандартная конфигурация named запускает простой кэширующий сервер в ограниченной среде man:chroot[8], который прослушивает запросы на интерфейсе обратной связи (loopback) с адресом (127.0.0.1). Для одноразового запуска даемона в этой конфигурации используйте команду

[source,shell]
....
# service named onestart
....

Чтобы даемон named запускался во время загрузки, поместите в [.filename]#/etc/rc.conf# следующую строку:

[.programlisting]
....
named_enable="YES"
....

Разумеется, существует множество различных конфигурационных параметров [.filename]#/etc/namedb/named.conf#, лежащих за рамками данного документа.
Имеются и другие параметры запуска named во FreeBSD, взгляните на флаговые параметры `named__*__` в [.filename]#/etc/defaults/rc.conf# и обратитесь к странице справочника man:rc.conf[5].
Кроме того, полезной может оказаться crossref:config[configtuning-rcd,Использование rc во FreeBSD 5.X и последующих версиях].

=== Конфигурационные файлы

Файлы конфигурации даемона named расположены в каталоге [.filename]#/etc/namedb# и, за исключением случая, когда вам требуется просто резолвер, требуют модификации.

==== [.filename]#/etc/namedb/named.conf#

[.programlisting]
....
// $FreeBSD$
//
// If you are going to set up an authoritative server, make sure you
// understand the hairy details of how DNS works.  Even with
// simple mistakes, you can break connectivity for affected parties,
// or cause huge amounts of useless Internet traffic.

options {
	// All file and path names are relative to the chroot directory,
	// if any, and should be fully qualified.
	directory	"/etc/namedb/working";
	pid-file	"/var/run/named/pid";
	dump-file	"/var/dump/named_dump.db";
	statistics-file	"/var/stats/named.stats";

// If named is being used only as a local resolver, this is a safe default.
// For named to be accessible to the network, comment this option, specify
// the proper IP address, or delete this option.
	listen-on	{ 127.0.0.1; };

// If you have IPv6 enabled on this system, uncomment this option for
// use as a local resolver.  To give access to the network, specify
// an IPv6 address, or the keyword "any".
//	listen-on-v6	{ ::1; };

// These zones are already covered by the empty zones listed below.
// If you remove the related empty zones below, comment these lines out.
	disable-empty-zone "255.255.255.255.IN-ADDR.ARPA";
	disable-empty-zone "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.ARPA";
	disable-empty-zone "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.ARPA";

// If you've got a DNS server around at your upstream provider, enter
// its IP address here, and enable the line below.  This will make you
// benefit from its cache, thus reduce overall DNS traffic in the Internet.
/*
	forwarders {
		127.0.0.1;
	};
*/

// If the 'forwarders' clause is not empty the default is to 'forward first'
// which will fall back to sending a query from your local server if the name
// servers in 'forwarders' do not have the answer.  Alternatively you can
// force your name server to never initiate queries of its own by enabling the
// following line:
//	forward only;

// If you wish to have forwarding configured automatically based on
// the entries in /etc/resolv.conf, uncomment the following line and
// set named_auto_forward=yes in /etc/rc.conf.  You can also enable
// named_auto_forward_only (the effect of which is described above).
//	include "/etc/namedb/auto_forward.conf";
....

Как и говорится в комментариях, если вы хотите получить эффект от использования кэша провайдера, то можно включить раздел `forwarders`. В обычном случае сервер имён будет рекурсивно опрашивать определённые серверы имён Интернет до тех пор, пока не получит ответ на свой запрос. При включении этого раздела он будет автоматически опрашивать сервер имён вашего провайдера (или тот, который здесь указан), используя преимущества его кэша. наличия нужной информации. Если соответствующий сервер имён провайдера работает быстро и имеет хороший канал связи, то в результате такой настройки вы можете получить хороший результат.

[WARNING]
====
`127.0.0.1` в данном случае работать _не будет_.
Измените этот адрес IP на сервер имён точки подключения.
====

[.programlisting]
....
/*
	   Modern versions of BIND use a random UDP port for each outgoing
	   query by default in order to dramatically reduce the possibility
	   of cache poisoning.  All users are strongly encouraged to utilize
	   this feature, and to configure their firewalls to accommodate it.

	   AS A LAST RESORT in order to get around a restrictive firewall
	   policy you can try enabling the option below.  Use of this option
	   will significantly reduce your ability to withstand cache poisoning
	   attacks, and should be avoided if at all possible.

	   Replace NNNNN in the example with a number between 49160 and 65530.
	*/
	// query-source address * port NNNNN;
};

// If you enable a local name server, don't forget to enter 127.0.0.1
// first in your /etc/resolv.conf so this server will be queried.
// Also, make sure to enable it in /etc/rc.conf.

// The traditional root hints mechanism. Use this, OR the slave zones below.
zone "." { type hint; file "/etc/namedb/named.root"; };

/*	Slaving the following zones from the root name servers has some
	significant advantages:
	1. Faster local resolution for your users
	2. No spurious traffic will be sent from your network to the roots
	3. Greater resilience to any potential root server failure/DDoS

	On the other hand, this method requires more monitoring than the
	hints file to be sure that an unexpected failure mode has not
	incapacitated your server.  Name servers that are serving a lot
	of clients will benefit more from this approach than individual
	hosts.  Use with caution.

	To use this mechanism, uncomment the entries below, and comment
	the hint zone above.

	As documented at http://dns.icann.org/services/axfr/ these zones:
	"." (the root), ARPA, IN-ADDR.ARPA, IP6.ARPA, and ROOT-SERVERS.NET
	are available for AXFR from these servers on IPv4 and IPv6:
	xfr.lax.dns.icann.org, xfr.cjr.dns.icann.org
*/
/*
zone "." {
	type slave;
	file "/etc/namedb/slave/root.slave";
	masters {
		192.5.5.241;	// F.ROOT-SERVERS.NET.
	};
	notify no;
};

zone "arpa" {
	type slave;
	file "/etc/namedb/slave/arpa.slave";
	masters {
		192.5.5.241;	// F.ROOT-SERVERS.NET.
	};
	notify no;
};
*/

/*	Serving the following zones locally will prevent any queries
	for these zones leaving your network and going to the root
	name servers.  This has two significant advantages:
	1. Faster local resolution for your users
	2. No spurious traffic will be sent from your network to the roots
*/
// RFCs 1912 and 5735 (and BCP 32 for localhost)
zone "localhost"	{ type master; file "/etc/namedb/master/localhost-forward.db"; };
zone "127.in-addr.arpa"	{ type master; file "/etc/namedb/master/localhost-reverse.db"; };
zone "255.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// RFC 1912-style zone for IPv6 localhost address
zone "0.ip6.arpa"	{ type master; file "/etc/namedb/master/localhost-reverse.db"; };

// "This" Network (RFCs 1912 and 5735)
zone "0.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// Private Use Networks (RFCs 1918 and 5735)
zone "10.in-addr.arpa"	   { type master; file "/etc/namedb/master/empty.db"; };
zone "16.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "17.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "18.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "19.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "20.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "21.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "22.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "23.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "24.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "25.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "26.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "27.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "28.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "29.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "30.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "31.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "168.192.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// Link-local/APIPA (RFCs 3927 and 5735)
zone "254.169.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// IETF protocol assignments (RFCs 5735 and 5736)
zone "0.0.192.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// TEST-NET-[1-3] for Documentation (RFCs 5735 and 5737)
zone "2.0.192.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "100.51.198.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "113.0.203.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// IPv6 Range for Documentation (RFC 3849)
zone "8.b.d.0.1.0.0.2.ip6.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// Domain Names for Documentation and Testing (BCP 32)
zone "test" { type master; file "/etc/namedb/master/empty.db"; };
zone "example" { type master; file "/etc/namedb/master/empty.db"; };
zone "invalid" { type master; file "/etc/namedb/master/empty.db"; };
zone "example.com" { type master; file "/etc/namedb/master/empty.db"; };
zone "example.net" { type master; file "/etc/namedb/master/empty.db"; };
zone "example.org" { type master; file "/etc/namedb/master/empty.db"; };

// Router Benchmark Testing (RFCs 2544 and 5735)
zone "18.198.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "19.198.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// IANA Reserved - Old Class E Space (RFC 5735)
zone "240.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "241.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "242.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "243.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "244.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "245.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "246.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "247.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "248.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "249.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "250.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "251.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "252.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "253.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "254.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// IPv6 Unassigned Addresses (RFC 4291)
zone "1.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "3.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "4.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "5.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "6.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "7.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "8.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "9.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "a.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "b.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "c.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "d.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "e.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "0.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "1.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "2.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "3.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "4.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "5.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "6.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "7.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "8.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "9.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "a.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "b.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "0.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "1.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "2.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "3.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "4.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "5.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "6.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "7.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// IPv6 ULA (RFC 4193)
zone "c.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "d.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// IPv6 Link Local (RFC 4291)
zone "8.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "9.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "a.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "b.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// IPv6 Deprecated Site-Local Addresses (RFC 3879)
zone "c.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "d.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "e.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "f.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// IP6.INT is Deprecated (RFC 4159)
zone "ip6.int"		{ type master; file "/etc/namedb/master/empty.db"; };

// NB: Do not use the IP addresses below, they are faked, and only
// serve demonstration/documentation purposes!
//
// Example slave zone config entries.  It can be convenient to become
// a slave at least for the zone your own domain is in.  Ask
// your network administrator for the IP address of the responsible
// master name server.
//
// Do not forget to include the reverse lookup zone!
// This is named after the first bytes of the IP address, in reverse
// order, with ".IN-ADDR.ARPA" appended, or ".IP6.ARPA" for IPv6.
//
// Before starting to set up a master zone, make sure you fully
// understand how DNS and BIND work.  There are sometimes
// non-obvious pitfalls.  Setting up a slave zone is usually simpler.
//
// NB: Don't blindly enable the examples below. :-)  Use actual names
// and addresses instead.

/* An example dynamic zone
key "exampleorgkey" {
	algorithm hmac-md5;
	secret "sf87HJqjkqh8ac87a02lla==";
};
zone "example.org" {
	type master;
	allow-update {
		key "exampleorgkey";
	};
	file "dynamic/example.org";
};
*/

/* Example of a slave reverse zone
zone "1.168.192.in-addr.arpa" {
	type slave;
	file "/etc/namedb/slave/1.168.192.in-addr.arpa";
	masters {
		192.168.1.1;
	};
};
*/
....

Это примеры описаний прямой и обратной зон из файла [.filename]#named.conf# для вторичных серверов.

Для каждого новой зоны, которую будет обслуживать сервер имён, в файл [.filename]#named.conf# должна быть добавлена запись.

К примеру, самая простая запись для домена `example.org` может выглядеть вот так:

[.programlisting]
....
zone "example.org" {
	type master;
	file "master/example.org";
};
....

Зона является первичной, что отражается в поле `type`, и информация о зоне хранится в файле [.filename]#/etc/namedb/master/example.org#, что указывается в поле `file`.

[.programlisting]
....
zone "example.org" {
	type slave;
	file "slave/example.org";
};
....

В случае вторичной зоны информация о ней передается с основного сервера имён для заданной зоны и сохраняется в указанном файле. Если и когда основной сервер имён выходит и строя или недосягаем, то скачанная информация о зоне будет находиться на вторичных серверах, и они смогут обслуживать эту зону.

==== Файлы зон

Пример файла зоны `example.org` для основного сервера (располагающийся в файле [.filename]#/etc/namedb/master/example.org#) имеет такой вид:

[.programlisting]
....
$TTL 3600        ; 1 hour default TTL
example.org.    IN      SOA      ns1.example.org. admin.example.org. (
                                2006051501      ; Serial
                                10800           ; Refresh
                                3600            ; Retry
                                604800          ; Expire
                                300             ; Negative Response TTL
                        )

; DNS Servers
                IN      NS      ns1.example.org.
                IN      NS      ns2.example.org.

; MX Records
                IN      MX 10   mx.example.org.
                IN      MX 20   mail.example.org.

                IN      A       192.168.1.1

; Machine Names
localhost       IN      A       127.0.0.1
ns1             IN      A       192.168.1.2
ns2             IN      A       192.168.1.3
mx              IN      A       192.168.1.4
mail            IN      A       192.168.1.5

; Aliases
www             IN      CNAME   example.org.
....

Заметьте, что все имена хостов, оканчивающиеся на ".", задают полное имя, тогда как все имена без символа "." на конце считаются заданными относительно origin. Например, `ns1` преобразуется в `ns1._example.org._`

Файл зоны имеет следующий формат:

[.programlisting]
....
recordname      IN recordtype  value
....

Наиболее часто используемые записи DNS:

SOA::
начало зоны ответственности

NS::
авторитативный сервер имен

A::
адрес хоста

CNAME::
каноническое имя для алиаса

MX::
обмен почтой

PTR::
указатель на доменное имя (используется в обратных зонах DNS)

[.programlisting]
....
example.org. IN SOA ns1.example.org. admin.example.org. (
                        2006051501      ; Serial
                        10800           ; Refresh after 3 hours
                        3600            ; Retry after 1 hour
                        604800          ; Expire after 1 week
                        300 )           ; Negative Response TTL
....

`example.org.`::
имя домена, а также ориджин для этого файла зоны.

`ns1.example.org.`::
основной/авторитативный сервер имён для этой зоны.

`admin.example.org.`::
человек, отвечающий за эту зону, адрес электронной почты с символом "@" замененным на точку. (mailto:admin@example.org[admin@example.org] становится `admin.example.org`)

`2006051501`::
последовательный номер файла. При каждом изменении файла зоны это число должно увеличиваться. В настоящее время для нумерации многие администраторы предпочитают формат `ггггммддвв`. `2006051501` будет означать, что файл последний раз изменялся 15.05.2006, а последнее число `01` означает, что это была первая модификация файла за день. Последовательный номер важен, так как он служит для того, чтобы вторичные серверы узнавали об обновлении зоны.

[.programlisting]
....
       IN      NS      ns1.example.org.
....

Это NS-запись. Такие записи должны иметься для всех серверов имён, которые будут отвечать за зону.

[.programlisting]
....
localhost       IN      A       127.0.0.1
ns1             IN      A       192.168.1.2
ns2             IN      A       192.168.1.3
mx              IN      A       192.168.1.4
mail            IN      A       192.168.1.5
....

Записи типа A служат для обозначения имён машин. Как это видно выше, имя `ns1.example.org` будет преобразовано в `192.168.1.2`.

[.programlisting]
....
       IN      A       192.168.1.1
....

Эта строка присваивает IP адрес `192.168.1.1` текущему ориджину, в данном случае домену `example.org`.

[.programlisting]
....
www	     IN CNAME	@
....

Записи с каноническими именами обычно используются для присвоения машинам псевдонимов. В этом примере `www` является псевдонимом для "главной" машины, имя которой по воле случая совпало с именем домена `example.org` (`192.168.1.1`). Записи типа CNAME нельзя использовать совместно с другими типами записей для одного и того же имени хоста (recordname).

[.programlisting]
....
	       IN MX   10      mail.example.org.
....

MX-запись указывает, какие почтовые серверы отвечают за обработку входящей электронной почты для зоны. `mail.example.org` является именем почтового сервера, а 10 обозначает приоритет этого почтового сервера.

Можно иметь несколько почтовых серверов с приоритетами, например, 10, 20 и так далее. Почтовый сервер, пытающийся доставить почту для `example.org`, сначала попробует связаться с машиной, имеющий MX-запись с самым большим приоритетом (наименьшим числовым значением в поле MX), затем с приоритетом поменьше и так далее, до тех пор, пока почта не будет отправлена.

Для файлов зон in-addr.arpa (обратные записи DNS) используется тот же самый формат, отличающийся только использованием записей PTR вместо A или CNAME.

[.programlisting]
....
$TTL 3600

1.168.192.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
                        2006051501      ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        300 )           ; Negative Response TTL

        IN      NS      ns1.example.org.
        IN      NS      ns2.example.org.

1       IN      PTR     example.org.
2       IN      PTR     ns1.example.org.
3       IN      PTR     ns2.example.org.
4       IN      PTR     mx.example.org.
5       IN      PTR     mail.example.org.
....

В этом файле дается полное соответствие имён хостов IP-адресам в нашем описанном ранее вымышленном домене.

Следует отметить, что все имена в правой части PTR-записи должны быть полными доменными именами (то есть, заканчиваться точкой ".").

=== Кэширующий сервер имён

Кэширующий сервер имён - это сервер имен, чья главная задача - разрешение рекурсивных запросов. Он просто выполняет запросы от своего имени и сохраняет результаты для последующего использования.

=== * DNSSEC

Этот раздел не переведен.

=== Безопасность

Хотя BIND является самой распространенной реализацией DNS, всегда стоит вопрос об обеспечении безопасности. Время от времени обнаруживаются возможные и реальные бреши в безопасности.

FreeBSD автоматически запускает named в ограниченном окружении (man:chroot[8]); помимо этого, есть еще несколько механизмов, помогающих защититься от возможных атак на сервис DNS.

Весьма полезно прочесть сообщения безопасности http://www.cert.org/[CERT] и подписаться на {freebsd-security-notifications} для того, чтобы быть в курсе текущих проблем с обеспечением безопасности Internet и FreeBSD.

[TIP]
====

Если возникает проблема, то наличие последних исходных текстов и свежесобранного named может способствовать её решению.
====

[[dns-read]]
=== Дополнительные материалы для ознакомления

Справочная информация по BIND/named: man:rndc[8], man:named[8], man:named.conf[8], man:nsupdate[1], man:dnssec-signzone[8], man:dnssec-keygen[8]

* https://www.isc.org/software/bind[ Официальная страница ISC BIND]
* https://www.isc.org/software/guild[ Официальный форум ISC BIND]
* http://www.oreilly.com/catalog/dns5/[ Книга издательства O'Reilly DNS and BIND 5th Edition]
* http://www.root-dnssec.org/documentation/[Root DNSSEC]
* http://data.iana.org/root-anchors/draft-icann-dnssec-trust-anchor.html[DNSSEC Trust Anchor Publication for the Root Zone]
* http://tools.ietf.org/html/rfc1034[RFC1034 - Domain Names - Concepts and Facilities]
* http://tools.ietf.org/html/rfc1035[RFC1035 - Domain Names - Implementation and Specification]
* http://tools.ietf.org/html/rfc4033[RFC4033 - DNS Security Introduction and Requirements]
* http://tools.ietf.org/html/rfc4034[RFC4034 - Resource Records for the DNS Security Extensions]
* http://tools.ietf.org/html/rfc4035[RFC4035 - Protocol Modifications for the DNS Security Extensions]
* http://tools.ietf.org/html/rfc4641[RFC4641 - DNSSEC Operational Practices]
* http://tools.ietf.org/html/rfc5011[RFC5011 - Automated Updates of DNS Security (DNSSEC Trust Anchors]

[[network-apache]]
== Apache HTTP сервер

=== Обзор

FreeBSD используется в качестве платформы для многих из самых нагруженных серверов в мире.
Большинство серверов в Интернет используют сервер Apache HTTP.
Пакеты Apache должны быть размещены на установочном носителе с FreeBSD.
Если Apache не был установлен при установке FreeBSD, то его можно установить из порта package:www/apache22[].

Как только Apache будет успешно установлен, его необходимо сконфигурировать.

[NOTE]
====
В этом разделе рассказывается о версии 2.2.X Apache HTTP сервера, поскольку эта версия наиболее широко используется с FreeBSD.
За более подробной информацией об Apache 2.X, выходящей за рамки данного документа, пожалуйста, обратитесь к http://httpd.apache.org/[http://httpd.apache.org/].
====

=== Настройка

Во FreeBSD основной файл настройки Apache HTTP Server устанавливается в [.filename]#/usr/local/etc/apache22/httpd.conf#.
Это обычный текстовый UNIX(R) файл настройки с строками комментариев, начинающимися с символа `#`. Исчерпывающее описание всех возможных параметров настройки находится за пределом рассмотрения этой книги, поэтому здесь будут описаны только наиболее часто модифицируемые директивы.

`ServerRoot "/usr/local"`::
Указывает верхний каталог установки Apache по умолчанию. Бинарные файлы находятся в [.filename]#bin# и [.filename]#sbin#, подкаталоги расположены относительно корневого каталога сервера, файлы настройки находятся в [.filename]#etc/apache#.

`ServerAdmin you@your.address`::
Адрес, на который должны будут отправляться сообщения о проблемах с сервером. Этот адрес также отображается на некоторых генерируемых сервером страницах, например, с ошибочными документами.

`ServerName www.example.com`::
`ServerName` позволяет администратору задать имя хоста, которое отправляется обратно клиентам в качестве сервера. Это полезно, когда оно отличается от того, с которым настроен хост (то есть использует `www` вместо реального имени хоста).

`DocumentRoot "/usr/local/www/apache22/data"`::
`DocumentRoot`: Каталог, из которого будут браться документы. По умолчанию все запросы обрабатываются из этого каталога, но символические ссылки и алиасы могут использоваться для указания на другие каталоги.

Всегда неплохой идеей является создание резервных копий конфигурационного файла Apache перед внесением изменений.
Как конфигурирование Apache будет завершено, сохраните файл и верифицируйте настройки при помощи man:apachectl[8].
Для этого запустите `apachectl configtest`, при этом должно быть выдано `Syntax OK`.

=== Запуск Apache

Для поддержки запуска, остановки и перезапуска Apache порт package:www/apache22[] устанавливает скрипт man:rc[8], который можно найти в каталоге [.filename]#/usr/local/etc/rc.d/#.

Для запуска Apache при старте системы добавьте следующую строку в [.filename]#/etc/rc.conf#:

[.programlisting]
....
apache22_enable="YES"
....

Если Apache должен быть запущен с параметрами, отличающимися от используемых по умолчанию, в [.filename]#/etc/rc.conf# может быть добавлена следюущая строка:

[.programlisting]
....
apache22_flags=""
....

Конфигурация Apache может быть протестирована на наличие ошибок после внесения последующих изменений в конфигурацию при работающем `httpd`.
Это может быть сделано напрямую при помощи скрипта man:rc[8] или утилиты man:service[8] запуском одной из следующих команд:

[source,shell]
....
# service apache22 configtest
....

[NOTE]
====
Важно отметить, что `configtest` не является стандартом man:rc[8], и не следует ожидать, что это работает для всех скриптов запуска man:rc[8].
====

Если Apache не сообщает об ошибках конфигурации, то Apache `httpd` может быть запущен с помощью man:service[8]:

[source,shell]
....
# service apache22 start
....

Сервис `httpd` можно протестировать вводом `http://localhost` в веб-браузере, заменив _localhost_ на полное доменное имя машины с работающим `httpd`, если это не локальная машина.
По умолчанию отображается веб-страница [.filename]#/usr/local/www/apache22/data/index.html#.

=== Виртуальный хостинг

Apache поддерживает два различных типа виртуального хостинга (Virtual Hosting). Первый метод основан на именах (Name-based Virtual Hosting). Он использует полученные от клиента заголовки HTTP/1.1 для определения имени хоста. Это позволяет многим различным доменам использовать один и тот же IP адрес.

Для настройки Apache на использование виртуального хостинга, основанного на именах, добавьте в [.filename]#httpd.conf# запись, подобную следующей:

[.programlisting]
....
NameVirtualHost *
....

Если соответствующий веб-сервер назывался `www.domain.tld`, а виртуальным доменом является `www.someotherdomain.tld`, то добавьте в [.filename]#httpd.conf# следующие записи:

[source,shell]
....
<VirtualHost *>
ServerName www.domain.tld
DocumentRoot /www/domain.tld
</VirtualHost>

<VirtualHost *>
ServerName www.someotherdomain.tld
DocumentRoot /www/someotherdomain.tld
</VirtualHost>
....

Замените адреса на нужные, а пути к документам на те, что используются.

За дополнительной информацией по настройке виртуальных хостов обращайтесь к официальной документации Apache: http://httpd.apache.org/docs/vhosts/[http://httpd.apache.org/docs/vhosts/].

=== Модули Apache

Существуют множество различных модулей Apache, которые добавляют функциональность к основному серверу. Коллекция портов FreeBSD предоставляет простой способ установки Apache с некоторыми наиболее популярными дополнительными модулями.

==== mod_ssl

Модуль mod_ssl использует библиотеку OpenSSL для сильной криптографии через протоколы Secure Sockets Layer (SSL v2/v3) и Transport Layer Security (TLS v1).
Этот модуль содержит всё необходимое для запроса подписанного сертификата из центра подписания доверенных сертификатов для работы безопасного веб-сервера на FreeBSD.

Построение модуля mod_ssl выполняется по умолчанию, однако может быть включено указанием `-DWITH_SSL` на этапе компиляции.

==== Apache и скриптовые языки

Для большинства скриптовых языков созданы модули Apache. На базе таких модулей возможно создание других модулей Apache, написанных полностью на скриптовом языке. Они также часто используются как встроенные в сервер интерпретаторы, что исключает накладные расходы на запуск внешнего интерпретатора и сокращает время построения динамических страниц.

=== Построение динамических сайтов

В последнее десятилетие все большее число компаний обращает внимание на Интернет как площадку для ведения и расширения бизнеса. Среди прочего, этот процесс подчеркивает потребность в интерактивном содержимом сайтов. Некоторые компании, такие как Microsoft(R), представляют свои закрытые решения; сообщество разработчиков открытых программ отвечает на вызов.
Современные варианты организации динамического контента включают в себя Django, Ruby on Rails, mod_perl2 и mod_php.

==== Django

Django - это распространяемая под лицензией BSD инфраструктура, позволяющая разработчикам быстро создавать элегантные, высокопроизводительные веб-приложения. Она предоставляет в распоряжение разработчика объектно-реляционное отображение (object-relational mapper), таким образом типы данных разрабатываются как объекты Python. Для этих объектов предоставляется богатый интерфейс доступа к базам данных, при этом у разработчика не возникает необходимости написания SQL-запросов. Django также предоставляет расширяемую систему шаблонов, так что логика приложения отделена от его HTML-представления.

Django зависит от mod_python, Apache и исполняющего механизма какой-либо базы данных SQL.
Порт FreeBSD установит все эти требуемые компоненты с подходящими параметрами.

[[network-www-django-install]]
.Установка Django совместно с Apache2, mod_python3 и PostgreSQL
[example]
====

[source,shell]
....
# cd /usr/ports/www/py-django; make all install clean -DWITH_MOD_PYTHON3 -DWITH_POSTGRESQL
....

====

После установки Django и этих необходимых компонентов ему будут требоваться каталог для проекта Django, а также конфигурирование Apache для использования встроенного интерпретатора Python.
Он будет являться интерпретатором для вызова соответствующего приложения для определённых URL сайта.

[[network-www-django-apache-config]]
.Конфигурация Apache для Django/mod_python
[example]
====
Чтобы настроить Apache на передачу запросов определенных URL веб-приложению, обязательно должна быть добавлена строка в конфигурационный файл [.filename]#httpd.conf#:

[source,shell]
....
<Location "/">
    SetHandler python-program
    PythonPath "['/dir/to/the/django/packages/'] + sys.path"
    PythonHandler django.core.handlers.modpython
    SetEnv DJANGO_SETTINGS_MODULE mysite.settings
    PythonAutoReload On
    PythonDebug On
</Location>
....
====

==== Ruby on Rails

Ruby on Rails это еще одна веб инфраструктура с открытым исходным кодом, которая предоставляет полный стек разработки и которая оптимизированa для продуктивного и быстрого создания мощных веб-приложений. Ruby on Rails может быть легко установлена из коллекции портов.

[source,shell]
....
# cd /usr/ports/www/rubygem-rails; make all install clean
....

==== mod_perl2

Проект интеграции Apache/Perl объединяет мощь языка программирования Perl и HTTP сервера Apache.
С модулем mod_perl2 возможно написание модулей Apache полностью на Perl.
Кроме того, постоянно запущенный встроенный в сервер интерпретатор позволяет не тратить ресурсы на запуск внешнего интерпретатора и время на запуск Perl.

mod_perl2 доступен как порт package:www/mod_perl2[].

==== mod_php

PHP, также известный как "Препроцессор гипертекста" ("Hypertext Preprocessor"), - это скриптовый язык общего назначения, в основном предназначенный для веб разработки. Этот язык может быть встроен в HTML, его синтаксис заимствован из C, Java(TM) и Perl, и он позволяет веб разработчикам быстро писать динамически генерируемые страницы.

Добавление поддержки PHP5 к веб серверу Apache производится путем установки порта package:lang/mod_php5[].

Если порт package:lang/php5[] устанавливается впервые, то автоматически отобразятся все доступные опции (`OPTIONS`).
Если меню не отображается, потому что, например, порт package:lang/php5[] устанавливался ранее, всегда можно повторно запустить выбор параметров в диалоговом режиме, выполнив следующую команду в каталоге порта:

[source,shell]
....
# make config
....

Выберите в меню опцию `APACHE`, тем самым вы построите загружаемый модуль mod_php5 для веб сервера Apache.

[NOTE]
====
Множество сайтов по разным причинам (к примеру, из-за проблем совместимости или из-за наличия уже развёрнутых веб приложений) всё еще используют PHP4.
Если требуется mod_php4 вместо mod_php5, то воспользуйтесь портом package:lang/php4[]. Порт package:lang/php4[] поддерживает многие из конфигурационных и установочных опций порта package:lang/php5[].
====

Этот порт устанавливает и настраивает модули, необходимые для поддержки динамических PHP веб страниц.
Убедитесь, что в файл [.filename]#/usr/local/etc/apache22/httpd.conf# были добавлены следующие разделы:

[.programlisting]
....
LoadModule php5_module        libexec/apache/libphp5.so
....

[.programlisting]
....
AddModule mod_php5.c
    <IfModule mod_php5.c>
        DirectoryIndex index.php index.html
    </IfModule>
    <IfModule mod_php5.c>
        AddType application/x-httpd-php .php
        AddType application/x-httpd-php-source .phps
    </IfModule>
....

Для загрузки модуля PHP после этого просто вызовите команду `apachectl` с параметром graceful:

[source,shell]
....
# apachectl graceful
....

При дальнейших обновлениях PHP команда `make config` больше не потребуется; выбранные опции сохраняются автоматически инфраструктурой портов FreeBSD

Поддержка PHP в FreeBSD построена по модульному принципу, поэтому базовая установка обладает очень ограниченной функциональностью. Дополнительная функциональность может быть легко добавлена при помощи порта package:lang/php5-extensions[], управляющего набором расширений PHP через меню, либо просто путем установки дополнительных портов.

Например, для добавления поддержки MySQL к PHP5, просто установите порт [.filename]#databases/php5-mysql#.

После установки новых расширений сервер Apache должен быть рестартован, чтобы изменения в конфигурации вступили в силу:

[source,shell]
....
# apachectl graceful
....

[[network-samba]]
== Файл сервер и печать для Microsoft(R) Windows(R) клиентов (Samba)

=== Обзор

Samba является популярным пакетом программного обеспечения с открытым кодом, который обеспечивает файловые сервисы и сервисы печати клиентам под управлением Microsoft(R) Windows(R).
Подобные клиенты могут подключаться и использовать файловое пространство FreeBSD, как если бы это был локальное дисковое устройство, или принтеры FreeBSD, как если бы они были локальными принтерами.

Программные пакеты Samba должны быть размещены на установочном носителе FreeBSD.
Если они не были установлены при первичной установке FreeBSD, то их можно установить из порта или пакета package:net/samba34[].

=== Настройка

Файл настройки Samba по умолчанию устанавливается в [.filename]#/usr/local/shared/examples/samba34/smb.conf.default#. Этот файл необходимо скопировать в [.filename]#/usr/local/etc/smb.conf# и отредактировать перед использованием Samba.

Файл [.filename]#smb.conf# содержит информацию, необходимую для работы Samba, такую, как определение принтеров и "совместно используемых ресурсов файловой системы", которые будут использоваться совместно с клиентами под управлением Windows(R).
В пакет Samba входит программа с веб интерфейсом, называемая swat, которая дает простой способ редактирования файла [.filename]#smb.conf#.

==== Использование Samba Web Administration Tool (SWAT)

Samba Web Administration Tool (SWAT) запускается как даемон из inetd.
По этой причине inetd должен быть активирован так, как это показано в разделе <<network-inetd>>, и перед тем, как использовать swat для настройки Samba, в [.filename]#/etc/inetd.conf# должны быть сняты комментарии в следующей строке:

[.programlisting]
....
swat   stream  tcp     nowait/400      root    /usr/local/sbin/swat    swat
....

Как описано в <<network-inetd-reread>>, после изменения настроек inetd необходимо перечитать конфигурацию.

Как только swat будет включён в [.filename]#inetd.conf#, можно будет использовать веб-браузер для подключения к link:http://localhost:901[http://localhost:901].
При первом подключении обязательно должна использоваться учётная запись `root`.

После успешного входа на основную страницу конфигурирования Samba будет доступна системная документация, либо можно начать конфигурирование, щёлкнув на закладке menu:Globals[].
Раздел menu:Globals[] соответствует переменным, которые задаются в разделе `[global]` файла [.filename]#/usr/local/etc/smb.conf#.

==== Глобальные настройки

Независимо от того, используется ли swat или непосредственно редактируется [.filename]#/usr/local/etc/smb.conf#, первые директивы, встречающиеся при конфигурировании Samba, таковы:

`workgroup`::
Имя домена или рабочей группы NT для компьютеров, которые будут получать доступ к этому серверу.

`netbios name`::
Устанавливает имя NetBIOS, под которым будет работать Samba сервер. По умолчанию оно устанавливается равным первому компоненту DNS имени хоста.

`server string`::
Устанавливает строку, которая будет показана командой `net view` и некоторыми другими сетевыми инструментами, которые отображают строку описания сервера.

==== Настройки безопасности

Две из наиболее важных настроек в [.filename]#/usr/local/etc/smb.conf# отвечают за выбор модели безопасности и за формат паролей для клиентов. Эти параметры контролируются следующими директивами:

`security`::
Двумя наиболее часто используемыми параметрами являются `security = share` и `security = user`. Если клиенты используют имена пользователей, совпадающие с их именами пользователей соответствующей машины FreeBSD, то должна использоваться модель безопасности уровня пользователя. Эта политика безопасности применяется по умолчанию, и она требует, чтобы клиент авторизовался перед доступом к совместно используемым ресурсам.
+
В модели безопасности уровня совместно используемого ресурса клиентам не требуется регистрироваться на сервере с корректными именами и паролями перед подключением к ресурсу. Эта модель безопасности использовалась по умолчанию в старых версиях Samba.

`passdb backend`::
Samba имеет несколько различных поддерживающих моделей аутентификации. Клиенты могут быть аутентифицированы с помощью LDAP, NIS+, базы данных SQL или через модифицированный файл паролей. Методом аутентификации, применяемым по умолчанию, является `smbpasswd`, и здесь будет рассматриваться только он.

Предполагая, что по умолчанию используется модель `smbpasswd`, обязательно должен быть создан файл [.filename]#/usr/local/etc/samba/smbpasswd# для обеспечения аутентификации клиентов сервером Samba.
Для обеспечения пользователей с учётными записями UNIX(R) доступом с клиентов под управлением Windows(R) используйте следующую команду:

[source,shell]
....
# smbpasswd -a username
....

[NOTE]
====
Ныне рекомендуемой подсистемой аутентификации является `tdbsam`, поэтому для добавления пользователей используйте следующую команду:

[source,shell]
....
# pdbedit -a -u username
....

====

Пожалуйста, обратитесь к документу link:http://www.samba.org/samba/docs/man/Samba-HOWTO-Collection/[Official Samba HOWTO] за дополнительной информацией о конфигурационных параметрах.
Опираясь на очерченные здесь основы, далее будет описан минимум, требуемый для начала работы с Samba.
Дополнительно к информации здесь, нужно обратиться и к другой документации.

=== Запуск Samba

Порт package:net/samba34[] добавляет новый стартовый сценарий, который может быть использован для контроля Samba. Для того, чтобы им можно было запускать, останавливать или перезапускать сервер Samba, добавьте следующую запись в файл [.filename]#/etc/rc.conf#:

[.programlisting]
....
samba_enable="YES"
....

Или, для более тонкого контроля:

[.programlisting]
....
nmbd_enable="YES"
....

[.programlisting]
....
smbd_enable="YES"
....

[NOTE]
====
Внесение этих записей в [.filename]#/etc/rc.conf# также обеспечит автоматический запуск сервера Samba во время старта системы.
====

Теперь становится возможным запустить сервер Samba, для чего наберите следующую команду:

[source,shell]
....
# service samba start
Starting SAMBA: removing stale tdbs :
Starting nmbd.
Starting smbd.
....

За дальнейшей информацией об использовании rc скриптов обратитесь к crossref:config[configtuning-rcd,Использование rc во FreeBSD 5.X и последующих версиях].

На самом деле Samba состоит из трёх отдельных даемонов.
Заметьте, что оба даемона, как nmbd, так и smbd, запускаются соответствующим скриптом [.filename]#samba#.
Если сервисы преобразования имён winbind были активированы в [.filename]#smb.conf#, то также будет запущен даемон winbindd.

Samba может быть остановлена в любой момент, если набрать:

[source,shell]
....
# service samba stop
....

Samba это сложный программный набор с функциональностью, позволяющей полную интеграцию в сети Microsoft(R) Windows(R). За дальнейшей информацией о функциях, выходящих за рамки описанной здесь базовой установки, обращайтесь к http://www.samba.org[http://www.samba.org].

[[network-ftp]]
== Протокол передачи файлов (FTP)

=== Обзор

Протокол передачи файлов (File Transfer Protocol, FTP) дает пользователям простой путь передачи файлов на и с FTP сервера. В FreeBSD серверная программа FTP, ftpd, включена в базовую систему. Это упрощает настройку и администрирование FTP сервера в FreeBSD.

=== Настройка

Самый важный шаг конфигурирования заключается в определении того, каким учётным записям будет позволено получать доступ к серверу FTP.
В обычной системе FreeBSD есть определённое количество системных учётных записей, используемых различными даемонами, но неизвестным пользователям должен быть запрещён вход с использованием этих учётных записей.
В файле [.filename]#/etc/ftpusers# находится список пользователей, которым запрещен доступ по FTP. По умолчанию он включает упомянутые системные учетные записи, но в него можно добавить и определенных пользователей, которым будет запрещен доступ по FTP.

В некоторых случаях может быть желательно ограничить доступ некоторых пользователей без полного запрета на использование FTP.
Это можно сделать через файл [.filename]#/etc/ftpchroot#. В нем находится список пользователей и групп, к которым применяется ограничение доступа. На странице справочника man:ftpchroot[5] дана подробная информация, и она не будет дублироваться здесь.

Для включения анонимного доступа к серверу FTP создайте пользователя с именем `ftp` в системе FreeBSD.
Теперь пользователи смогут входить на сервер FTP с именем пользователя `ftp` или `anonymous`, используя любой пароль (принято использовать почтовый адрес пользователя в качестве пароля).
FTP сервер выполнит man:chroot[2] при входе пользователя anonymous для ограничения доступа только домашним каталогом пользователя `ftp`.

Существуют два текстовых файла, определяющих сообщение, отправляемое FTP клиентам. Содержимое файла [.filename]#/etc/ftpwelcome# будет выведено пользователям перед приглашением на вход. После успешного входа будет выведено содержимое файла [.filename]#/etc/ftpmotd#. Обратите внимание, что путь к этому файлу задается относительно домашнего каталога пользователя, так что анонимным пользователям будет отправляться [.filename]#~ftp/etc/ftpmotd#.

Как только FTP сервер был правильно настроен, он должен быть включен в [.filename]#/etc/inetd.conf#. Все, что необходимо, это удалить символ комментария "#" из начала существующей строки ftpd:

[.programlisting]
....
ftp	stream	tcp	nowait	root	/usr/libexec/ftpd	ftpd -l
....

Как описано в разделе crossref:network-servers[network-inetd-reread, Перезагрузка конфигурационного файла inetd], inetd должен перечитать конфигурацию после того, как этот файл настройки был изменён.
Пожалуйста, обратитесь к разделу crossref:network-servers[network-inetd-settings, Настройки] за деталями по запуску inetd в системе.

В качестве альтернативы, даемон ftpd может быть запущен как самостоятельный сервер. В этом случае достаточно установить соответствующую переменную в файле [.filename]#/etc/rc.conf#:

[.programlisting]
....
ftpd_enable="YES"
....

Демон будет запущен автоматически при следующей загрузке системы. Также демон можно запустить вручную, для чего выполните следующую команду как пользователь `root`:

[source,shell]
....
# service ftpd start
....

Теперь вы можете войти на соответствующий сервер FTP, набрав:

[source,shell]
....
% ftp localhost
....

=== Поддержка

Для протоколирования даемон ftpd использует сообщения man:syslog[3]. По умолчанию, man:syslog[3] поместит сообщения, относящиеся к FTP, в файл [.filename]#/var/log/xferlog#. Местоположение лог файла FTP может быть изменено путем изменения следующей строки в файле [.filename]#/etc/syslog.conf#:

[.programlisting]
....
ftp.info      /var/log/xferlog
....

Учтите потенциальные проблемы, возникающие при работе анонимного сервера FTP.
В частности, дважды подумайте о том, чтобы разрешать анонимным пользователям загружать файлы на сервер.
Может оказаться, что сайт FTP стал местом торговли нелицензионным коммерческим программным обеспечением или чем-то хуже.
Если требуются анонимные загрузки FTP, то проверьте настройки полномочий, чтобы эти файлы не могли быть считаны другими анонимными пользователями до их рассмотрения администратором.

[[network-ntp]]
== Синхронизация часов через NTP

=== Обзор

С течением времени часы компьютера подвержены потере точности.
Протокол NTP (Network Time Protocol) является одним из способов обеспечения точности часов.

Многие сервисы Интернет опираются или сильно зависят от точности часов компьютеров. К примеру, веб-сервер может получать запрос на посылку файла, который был недавно модифицирован. В локальной сети необходимо, чтобы часы компьютеров, совместно использующих файлы, были синхронизированы, чтобы время модификации файлов устанавливалось правильно. Такие службы, как man:cron[8], также зависят от правильности установки системных часов, поскольку запускают команды в определенное время.

FreeBSD поставляется с сервером NTP man:ntpd[8], который может использоваться для опроса других серверов NTP с целью установки времени на соответствующей машине или предоставления сервиса времени другим.

=== Выбор подходящих серверов NTP

Для того, чтобы синхронизировать время, необходимо задать один или большее количество серверов NTP.
Администратор соответствующей сети или провайдер могут иметь настроенный сервер NTP для этой цели - обратитесь к предоставляемой ими документации, чтобы выяснить, так ли это.
Существует link:http://support.ntp.org/bin/view/Servers/WebHome[онлайновый список общедоступных серверов NTP], к которому можно обратиться для поиска ближайшего к системе сервера NTP.
Предусмотрительно проанализируйте политику каких бы то ни было выбранных вами серверов и, если это требуется, запросите разрешения.

Выбор нескольких несвязанных серверов NTP является хорошим решением на тот случае, когда один из используемых серверов становится недоступным или его часы неточны.
man:ntpd[8] использует отклики, получаемые от других серверов, осмысленно - уровень предпочтения менее надёжным серверам будет меньше, чем надёжным.

=== Настройка конкретной машины

==== Базовая конфигурация

Для синхронизации времени только при загрузке машины используйте man:ntpdate[8].
Это может подойти для некоторых настольных машин, которые часто перезагружаются и только требуют изредка синхронизироваться, но на большинстве машин должен работать man:ntpd[8].

Использование man:ntpdate[8] при загрузке также хорошо для машин, на которых запущен даемон man:ntpd[8]. Программа man:ntpd[8] изменяет время постепенно, тогда как man:ntpdate[8] устанавливает время вне зависимости от того, насколько велика разница между текущим временем машины и точным временем.

Для включения man:ntpdate[8] во время загрузки, добавьте строку `ntpdate_enable="YES"` в [.filename]#/etc/rc.conf#.
Также укажите все серверы синхронизации и все параметры, которые передаются в man:ntpdate[8], в `ntpdate_flags`.

==== Общие настройки

NTP настраивается в файле [.filename]#/etc/ntp.conf#, формат которого описан в man:ntp.conf[5]. Вот простой пример:

[.programlisting]
....
server ntplocal.example.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift
....

Параметр `server` задает, какие серверы будут использоваться, по одному в каждой строке. Если сервер задан с аргументом `prefer`, как `ntplocal.example.com`, то этому серверу отдается предпочтение перед остальными. Ответ от предпочтительного сервера будет отброшен, если он значительно отличается от ответов других серверов, в противном случае он будет использоваться безотносительно к другим ответам. Аргумент `prefer` обычно используется для серверов NTP, о которых известно, что они очень точны, такими, на которых используется специальное оборудование точного времени.

Параметр `driftfile` задает файл, который используется для хранения смещения частоты системных часов. Программа man:ntpd[8] использует его для автоматической компенсации естественного смещения часов, позволяя ему поддерживать достаточно правильную настройку, даже если он на некоторый период отключается от внешнего источника информации о времени.

Параметр `driftfile` задаёт файл, применяемый для хранения информации о предыдущих откликах от используемых серверов NTP.
Этот файл содержит внутреннюю информацию для NTP.
Он не должен изменяться никаким другим процессом.

==== Управление доступом к вашему серверу

По умолчанию соответствующий сервер NTP будет доступен всем хостам в Интернет.
Параметр `restrict` в [.filename]#/etc/ntp.conf# управляет тем, какие машины могут обращаться к данному серверу.

Для того, чтобы запретить всем машинам обращаться к соответствующему серверу NTP, добавьте следующую строку в [.filename]#/etc/ntp.conf#:

[.programlisting]
....
restrict default ignore
....

[NOTE]
====
При этом также ограничивается доступ от данного сервера ко всем серверам, перечисленным в соответствующей локальной конфигурации.
Если имеется необходимость в синхронизации данного сервера с каким-либо внешним сервером NTP, дайте разрешение только этому конкретному серверу.
Обратитесь к руководству по man:ntp.conf[5] для получения дополнительной информации.
====

Для того, чтобы разрешить машинам в соответствующей сети синхронизировать свои часы с данным сервером, но при этом обеспечить запрет им настраивать данный сервер или быть равноправными участниками синхронизации времени, добавьте вместо этого

[.programlisting]
....
restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap
....

где `192.168.1.0` является адресом IP данной сети, а `255.255.255.0` её сетевой маской.

Соответствующий файл [.filename]#/etc/ntp.conf# может содержать несколько параметров `restrict`.
Для получения более подробной информации обратитесь к подразделу `Access Control Support` в man:ntp.conf[5].

=== Запуск сервера NTP

Для того, чтобы обеспечить запуск сервера NTP при загрузке, добавьте строку `ntpd_enable="YES"` в [.filename]#/etc/rc.conf#.
Для передачи дополнительных параметров в man:ntpd[8] отредактируйте параметр `ntpd_flags` в [.filename]#/etc/rc.conf#.

Для запуска сервера без перезагрузки соответствующей машины выполните команду `ntpd`, не забыв задать дополнительные параметры из переменной `ntpd_flags` в файле [.filename]#/etc/rc.conf#.
К примеру:

[source,shell]
....
# ntpd -p /var/run/ntpd.pid
....

=== Использование ntpd с временным подключением к Интернет

Для полноценной работы программе man:ntpd[8] не требуется постоянное подключение к Интернет.
Однако если имеется временное подключение к Интернет, сконфигурированное на дозвон по требованию, будет полезным запретить трафику NTP вызывать дозвон или поддерживать соединение.
Пользователи PPP могут воспользовать директивы `filter` в [.filename]#/etc/ppp/ppp.conf#.
Например:

[.programlisting]
....
set filter dial 0 deny udp src eq 123
# Prevent NTP traffic from initiating dial out
set filter dial 1 permit 0 0
set filter alive 0 deny udp src eq 123
# Prevent incoming NTP traffic from keeping the connection open
set filter alive 1 deny udp dst eq 123
# Prevent outgoing NTP traffic from keeping the connection open
set filter alive 2 permit 0/0 0/0
....

Более подробную информацию можно найти в разделе `PACKET FILTERING` (ФИЛЬТРАЦИЯ ПАКЕТОВ) в man:ppp[8], а примеры в [.filename]#/usr/shared/examples/ppp/#.

[NOTE]
====
Некоторые провайдеры Интернет блокируют трафик по портам с маленькими номерами, что приводит к неработоспособности NTP, так как ответы никогда не достигают соответствующей машины.
====

=== Дополнительная литература

Документация по серверу NTP может быть найдена в каталоге [.filename]#/usr/shared/doc/ntp/# в формате HTML.

[[network-syslogd]]
== Протоколирование на удалённую машину с `syslogd`

Работа с системными журналами является критическим аспектом как информационной безопасности, так и системного администрирования.
Мониторинг файлов журналов множества хостов может стать очень неудобным, когда эти хосты распределены в сетях среднего или большого размера, или когда они являются частями разнообразных и отличающихся типов сетей.
В таких случаях конфигурирование удалённого протоколирования может сделать весь процесс гораздо более комфортным.

Централизованное протоколирование на специальный хост протоколирования может снизить некоторый объём административной нагрузки на администрирование файлов системных журналов.
Возможна настройка агрегирования файлов журналов, объединения и ротирования в одном месте при помощи собственных инструментов FreeBSD, таких как man:syslogd[8] и man:newsyslog[8].
В следующем примере конфигурации хост `A` с именем `logserv.example.com` будет собирать журналируемую информацию для локальной сети.
Хост `B` с именем `logclient.example.com` будет передавать протоколируемую информацию на серверную систему.
В реальных конфигурациях оба хоста требуют полноценного прямого и обратного DNS или наличия записей в [.filename]#/etc/hosts#.
В противном случае данные будут отклоняться сервером.

=== Конфигурирование сервера журналирования

Серверы журналирования являются машинами, настроенными на приём протоколируемой информации от удалённых хостов.
В большинстве случаев это делается для облегчения настройки, в других случаях это может быть просто шаг в сторону улучшения администрирования.
Вне зависимости от причины, имеется пара требований, нужных для продолжения.

Корректно настроенный сервер журналирования соответствует следюущим минимальным требованиям:

* Набор правил межсетевого экрана разрешает пропуск UDP на порт 514 как на клиенте, так и на сервере;
* `syslogd` сконфигурирован на принятие удалённых сообщений от клиентских машин;
* Соответствующий сервер `syslogd` и все клиентские машины обязательно должны иметь корректные записи для прямого и обратного DNS, или должны быть корректно настроены в [.filename]#/etc/hosts#.

Для конфигурирования сервера протоколирования клиент обязательно должен быть указан в [.filename]#/etc/syslog.conf#, а обязательно должны быть указана подсистема протоколирования:

[.programlisting]
....
+logclient.example.com
*.*	/var/log/logclient.log
....

[NOTE]
====
Дополнительную информацию о разнообразных поддерживаемых и доступных _подсистемах_ можно найти на странице Справочника man:syslog.conf[5].

После добавления все сообщения `подсистемы` будут записываться в указанный ранее файл, [.filename]#/var/log/logclient.log#.

Серверная машина также обязательно должна иметь следующие строки внутри [.filename]#/etc/rc.conf#:

[.programlisting]
....
syslogd_enable="YES"
syslogd_flags="-a logclient.example.com -v -v"
....

Первый параметр активирует даемон `syslogd` при загрузке, а второй параметр разрешает приём данных на этом сервере от указанного клиента.
В последнем, использующим `-v -v`, увеличивается детализация журнальных сообщений.
Это чрезвычайно полезно для тонкой настройки подсистем, так как администраторы могут видеть, какие типы сообщений журналируются и в какой подсистеме.

Могут быть указаны несколько параметров `-a`, чтобы разрешить запись системных журналов от нескольких клиентов.
Также могут быть заданы адреса IP и целые сетевые блоки, а полный список возможных параметров можно увидеть на страницах Справочника man:syslog[3].

Наконец, должен быть создан файл системного журнала.
Используемый способ не имеет значения, однако man:touch[1] прекрасно работает в подобных ситуациях:

[source,shell]
....
# touch /var/log/logclient.log
....

На этом этапе должен быть перезапущен даемон `syslogd` и проверена его работоспособность:

[source,shell]
....
# service syslogd restart
# pgrep syslog
....

Если возвращается PID, то сервер был перезапущен успешно, и можно начинать настройку клиента.
Если сервер не был перезапущен, обратитесь к журналу [.filename]#/var/log/messages# за любой диагностической информацией.

=== Конфигурирование клиента журналирования

Протоколируемый клиент является машиной, которая, кроме хранения локальных копий, также направляет информацию системного журнала на сервер протоколирования.

Подобно протоколирующим серверам, клиенты также в обязательном порядке должны соответствовать паре минимальных требований:

* man:syslogd[8] обязательно должен быть сконфигурирован на отправку сообщений специальных видов на сервер протоколирования, который обязан их принимать;
* Межсетевой экран обязательно должен разрешать прохождение пакетов UDP на порт 514;
* Как прямой, так и обратный DNS обязательно должны быть сконфигурированы или иметь корректные записи в [.filename]#/etc/hosts#.

Конфигурирование клиента по сравнению с серверами несколько проще.
Клиентская машина обязательно должна иметь следующие строки внутри [.filename]#/etc/rc.conf#:

[.programlisting]
....
syslogd_enable="YES"
syslogd_flags="-s -v -v"
....

Как и ранее, эти записи будут активировать даемон `syslogd` при загрузке, также увеличивается детализация журнальных сообщений.
Параметр `-s` предотвращает приём сообщений системного журнала этим клиентом от других хостов.

Подсистемы описывают часть системы, для которой генерируется сообщение.
К примеру, ftp и ipfw оба являются подсистемами.
Когда сообщения системного журнала генерируются для этих двух сервисов, они обычно включают эти две утилиты во все сообщения журнала.
Подсистемы дополняются приоритетом или уровнем, которые используются для указания на важность сообщения системного журнала.
Самыми распространёнными будут `warning` и `info`.
Пожалуйста, обратитесь к страницам Справочника по man:syslog[3] для получения полного списка доступных подсистем и приоритетов.

Сервер протоколирования обязательно должен быть определён в [.filename]#/etc/syslog.conf# соответствующего клиента.
В данной конфигурации символ `@` используется для отправки данных системного журнала на удалённый сервер и выглядит подобно следующей записи:

[.programlisting]
....
*.*               @logserv.example.com
....

После добавления `syslogd` обязательно должен быть перезапущен для того, чтобы изменения вступили в действие:

[source,shell]
....
# service syslogd restart
....

Для проверки того, что сообщения системного журнала отправляются по сети, воспользуйтесь man:logger[1] на клиенте для отправки какого-либо сообщения в `syslogd`.

[source,shell]
....
# logger "Test message from logclient"
....

Теперь это сообщение должно появиться как в [.filename]#/var/log/messages# на клиенте, так и в [.filename]#/var/log/logclient.log# на сервере протоколирования.

=== Диагностирование серверов протоколирования

В определённых случаях, когда сообщения не принимаются на соответствующем сервере протоколирования, может потребоваться диагностирование.
Имеется несколько причин, по которым это может произойти, однако двумя самыми распространёнными являются проблемы с сетевым соединением и проблемы с DNS.
Чтобы проверить наличие этих проблем, удостоверьтесь, что оба хоста могут соединяться друг с другом с использованием имени хоста, указанного в [.filename]#/etc/rc.conf#.
Если выяснится, что это работает корректно, то потребуется изменение параметра `syslogd_flags` в [.filename]#/etc/rc.conf#.

В следующем примере файл [.filename]#/var/log/logclient.log# пуст, а соответствующие файлы [.filename]#/var/log/messages# не отражают причин для этого сбоя.
Для увеличения выдаваемой диагностики измените параметр `syslogd_flags`, чтобы он выглядел так, как в следующем примере, и выполните перезапуск:

[.programlisting]
....
syslogd_flags="-d -a logclien.example.com -v -v"
....

[source,shell]
....
# service syslogd restart
....

Сразу после перезапуска на экран будут выдаваться диагностические данные, подобные следующему:

[source,shell]
....
logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
Logging to FILE /var/log/messages
syslogd: kernel boot file is /boot/kernel/kernel
cvthname(192.168.1.10)
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;
rejected in rule 0 due to name mismatch.
....

Выглядит очевидным, что сообщения отклоняются из-за несоответствия имён.
После побитного анализа конфигурации выясняется, что имеется проблема с опечаткой в следующей строке файла [.filename]#/etc/rc.conf#:

[.programlisting]
....
syslogd_flags="-d -a logclien.example.com -v -v"
....

Эта строка должна содержать `logclient`, а не `logclien`.
После того, как были осуществлены соответствующие корректировки, выполняется перезапуск с ожидаемыми результатами:

[source,shell]
....
# service syslogd restart
logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
syslogd: kernel boot file is /boot/kernel/kernel
logmsg: pri 166, flags 17, from logserv.example.com,
msg Dec 10 20:55:02 &lt;syslog.err&gt; logserv.example.com syslogd: exiting on signal 2
cvthname(192.168.1.10)
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;
accepted in rule 0.
logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2
Logging to FILE /var/log/logclient.log
Logging to FILE /var/log/messages
....

На этом этапе сообщения корректно принимаются и помещаются в соответствующий файл.

=== Соображения информационной безопасности

Как и для любого сетевого сервиса, до реализации этой конфигурации должны быть рассмотрены требования к безопасности.
Бывает так, что журнальные файлы могут содержать сенситивные данные о сервисах, активированных на соответствующем локальном хосте, учётных записях пользователей и конфигурационных данных.
Сетевые данные, отправляемые от клиента на сервер, не будут ни шифроваться, ни защищаться паролем.
Если имеется потребность в шифровании, то возможно использовать [.filename]#security/stunnel#, который будет передавать данные поверх зашифрованного туннеля.

Локальная безопасность также является проблемой.
Файлы системного журнала не шифруются при их использовании или после ротирования журналов.
Локальные пользователи могут обращаться к этим файлам для получения дополнительного понимания конфигурации системы.
В таких случаях установка корректных полномочий на эти файлы будет критичным.
Утилита man:newsyslog[8] поддерживает установку полномочий на вновь создаваемые и ротируемые журнальные файлы.
Установка режима `600` на файлы журналов должна предотвратить любой нежелательный шпионаж со стороны локальных пользователей.
