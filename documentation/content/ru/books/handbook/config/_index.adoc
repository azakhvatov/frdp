//
// The FreeBSD Russian Documentation Project
//
// Original RU revision (18.02.2025): 54ac237fdb34d9074316cd8f8a77832bd618e4f6
//
// Original EN revision (SVN): 42523
//

---
title: Глава 12. Настройка и оптимизация
part: Часть III. Системное администрирование
prev: books/handbook/partiii
next: books/handbook/boot
showBookMenu: true
weight: 16
params:
  path: "/books/handbook/config/"
---

[[config-tuning]]
= Настройка и оптимизация
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 12
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/config/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[config-synopsis]]
== Введение

Одним из важных аспектов FreeBSD является корректная настройка системы.
Эта глава описывает значительную часть процесса конфигурирования FreeBSD, в том числе некоторые параметры, которые можно задавать для тонкой настройки системы FreeBSD.

После прочтения этой главы вы будет знать:

* Как эффективно работать с файловыми системами и разделами подкачки.
* Основы настройки [.filename]#rc.conf# и скрипты запуска [.filename]#/usr/local/etc/rc.d#.
* Как настроить и протестировать сетевую карту.
* Как настроить виртуальные хосты на сетевых устройствах.
* Как использовать различные конфигурационные файлы в каталоге [.filename]#/etc#.
* Как выполнять тонкую настройку FreeBSD при помощи переменных man:sysctl[8].
* Как увеличить скорость работы дисков и изменить ограничения, накладываемые ядром.

Перед прочтением этой главы вам следует:

* Понять основы UNIX(R) и FreeBSD (crossref:basics[basics, Основы FreeBSD]).
* Ознакомиться с основами конфигурирования и компиляции ядра (crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]).

[[configtuning-initial]]
== Начальное конфигурирование

=== Разделы диска

==== Основы построения разделов

При размещении файловых систем с помощью man:bsdlabel[8] или man:sysinstall[8] важно помнить, что скорость чтения и записи данных уменьшается от внешних к внутренним дорожкам диска.
Таким образом, файловые системы меньшего размера и часто используемые должны быть ближе к внешнему краю диска, а более крупные, такие как [.filename]#/usr#, должны размещаться ближе к внутренним частям диска.
Хорошей идеей является создание разделов в порядке, подобном следующему: [.filename]#/#, подкачка, [.filename]#/var# и [.filename]#/usr#.

Размер раздела [.filename]#/var# отражает предполагаемое использование машины.
Этот раздел используется для хранения почтовых ящиков, файлов журналов событий и очередей печати.
Поочтовые ящики и файлы журналов могут вырастать до неожидаемых размеров в зависимости от количества пользователей и продолжительности хранения файлов журналов.
В среднем большинству пользователей редко требуется более, чем примерно гигабайт свободного дискового пространства в [.filename]#/var#.

[NOTE]
====
Иногда в [.filename]#/var/tmp# требуется наличие большого объёма дискового пространства.
Когда новое программное обеспечение устанавливается при помощи man:pkg.add[1], инструменты работы с пакетами разворачивают временную копию пакетов в [.filename]#/var/tmp#.
Если в [.filename]#/var/tmp# нет достаточного объёма дискового пространства, установка крупных пакетов программного обеспечения, подобных Firefox, OpenOffice или LibreOffice, может быть затруднена.
====

Раздел [.filename]#/usr# содержит многие из тех файлов, что поддерживают систему, в том числе Коллекцию Портов и исходный код системы.
Для этого раздела рекомендуется не менее 2 гигабайт.

При выборе объёмов разделов принимайте во внимание требования к дисковому пространству.
Исчерпание объёма одного раздела при слабом использовании другого может вызвать затруднения.

[NOTE]
====
Планировщик <literal>Auto-defaults</literal>, используемый man:sysinstall[8], в некоторых случаях будет выбирать менее адекватные разделы [.filename]#/var# и [.filename]#/#.
Планируйте разделы с умом и не жалейте дискового пространства.
====

[[swap-design]]
==== Раздел подкачки

Как правило, размер раздела подкачки должен быть равен примерно удвоенному размеру физической памяти (ОЗУ), так как алгоритмы работы с выгружаемыми страницами виртуальной памяти (VM) ядра оптимизированы для достижения наилучших показателей, когда раздел памяти подкачки по крайней мере в два раза больше размера основной памяти.
Системы с минимальным ОЗУ работают лучше, когда памяти подкачки ещё больше.
Конфигурирование слишком малого объёма памяти подкачки может привести к неэффективной работе функции сканирования страниц VM и позже вызвать проблемы при добавлении памяти.

На более крупных системах с несколькими дисками SCSI или несколькими дисками IDE, работающими на разных контроллерах, рекомендуется создавать раздел подкачки на каждом диске, и вплоть до четырёх дисков.
Разделы подкачки должны быть примерно одного размера. Ядро не накладывает ограничений на размер раздела подкачки, но внутренние структуры позволяют иметь общий размер разделов подкачки, равный наибольшему, умноженному на четыре. Выделение под разделы подкачки примерно одинакового места позволить ядру оптимально расположить разделы подкачки. Установка размера подкачки больше требуемого нормальна, даже если этот объем не используется. В этих условиях может быть проще восстановиться после зависания программы перед тем, как возникнет необходимость перезагрузки.

==== Зачем нужны разделы?

Некоторые пользователи считают, что лучше использовать один большой раздел, но есть несколько причин, по которым этого лучше не делать. Во-первых, у каждого раздела свои характеристики, и отделяя их, можно выполнить соответствующие настройки.
Например, корневая файловая система и [.filename]#/usr# в основном предназначены для чтения, с небольшим объёмом операций записи, тогда как много операций чтения и записи могут осуществляться в [.filename]#/var# и [.filename]#/var/tmp#.

При правильном разбиении системы на разделы фрагментация в более маленьких разделах с частыми операциями записи не будет проявляться в разделах с превалирующими операциями чтения.
Размещение разделов с большим количеством операций записи ближе к началу диска увеличит скорость ввода/вывода там, где она нужна больше всего.
Хотя производительность ввода/вывода может быть нужна для более крупных разделов, их перемещение к краю диска не приведёт к значительному улучшению быстродействия по сравнению с перемещением ближе к краю диска [.filename]#/var#.
И, наконец, имеются и соображения безопасности.
Наличие маленького аккуратного корневого раздела, доступного только для чтения, даёт значительные шансы на выживание после серьёзного сбоя.

[[configtuning-core-configuration]]
== Основные настройки

Основным местом размещения информации о конфигурации системы является [.filename]#/etc/rc.conf#.
Этот файл содержит широкий спектр конфигурационной информации, и он считывается при запуске системы для её настройки.
Он даёт конфигурационную информацию для файлов [.filename]#rc*#.

Записи в [.filename]#rc.conf# переопределяют значения настроек, используемых по умолчанию, из [.filename]#/etc/defaults/rc.conf#.
Этот файл, содержащий стандартные настройки, не должен редактироваться.
Вместо этого все специфичные для данной системы изменения должны производиться в [.filename]#/etc/rc.conf#.

Для кластеризованных приложений существует несколько стратегий отделения общих настроек для всех систем от настроек конкретной системы в целях уменьшения дополнительных работ администратора.
Рекомендуемым методом является помещение настроек конкретной системы в файл [.filename]#/etc/rc.conf.local#.
Например:

* [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
sshd_enable="YES"
keyrate="fast"
defaultrouter="10.1.1.254"
....
+
* [.filename]#/etc/rc.conf.local#:
+
[.programlisting]
....
hostname="node1.example.org"
ifconfig_fxp0="inet 10.1.1.1/8"
....

Тиражируйте [.filename]#/etc/rc.conf# на все системы при помощи `rsync` или похожей программы, в то время как [.filename]#/etc/rc.conf.local# оставляйте уникальным.

Модернизация системы с помощью man:sysinstall[8] или `make world` не повлекут за собой перезаписи [.filename]#/etc/rc.conf#.
Вся информация в этом файле сохранится.

[TIP]
====
Конфигурационная информация в [.filename]#/etc/rc.conf# обрабатывается при помощи man:sh[1].
Это позволяет системным операторам создавать сложные конфигурационные сценарии.
Обратитесь к man:rc.conf[5] для получения дополнительной информации по этой теме.
====

[[configtuning-appconfig]]
== Настройка приложений

Как правило, установленные приложения имеют собственные конфигурационные файлы и синтаксис.
Важно, чтобы эти файлы хранились отдельно от базовой системы, чтобы их можно было легко находить и администрировать с помощью средств управления пакетами.

Обычно эти файлы устанавливаются в [.filename]#/usr/local/etc#.
В случае, когда приложению нужно большое количество конфигурационных файлов, для их хранения будет создан подкаталог.

Обычно при установке портов и пакетов также устанавливаются и образцы конфигурационных файлов.
Эти файлы обычно помечаются расширением, подобным [.filename]#.sample#.
Если для конкретного приложения конфигурационные файлы отсутствуют, то они могутбыть созданы путём копирования файлов образцов.

К примеру, рассмотрите содержимое каталога [.filename]#/usr/local/etc/apache#:

....
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default
....

Размеры файлов показывают, что изменён был только файл [.filename]#srm.conf#.
При последующем обновлении порта Apache этот изменённый файл уже не будет перезаписан.

[[configtuning-starting-services]]
== Запуск сервисов

Многие пользователи устанавливают программы сторонних производителей во FreeBSD из Коллекции Портов, и им требуется, чтобы установленные сервисы запускались при инициализации системы.
Сервисы, подобные package:mail/postfix[] или package:www/apache22[], являются лишь двумя из множества программных пакетов, которые могут быть запущены при инициализации системы.
В этом разделе описываются действия, применимые для запуска программного обеспеения сторонних разработчиков.

Во FreeBSD большинство включённых в поставку сервисов, таких как man:cron[8], запускаются с помощью стартовых скриптов системы.

=== Расширенное конфигурирование приложений

Теперь, когда FreeBSD включает [.filename]#rc.d#, настройка запуска приложений является более простой и даёт больше возможностей.
С помощью ключевых слов, рассмотренных в разделе <<configtuning-rcd,rc.d>>, приложения могут быть настроены на запуск после других определённых сервисов, а дополнительные параметры могут быть переданы через [.filename]#/etc/rc.conf# вместо их явного указания в сценарии запуска.
Базовый скрипт может иметь вид, подобный следующему:

[.programlisting]
....
#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command="/usr/local/sbin/utility"

load_rc_config $name

#
# НЕ МЕНЯЙТЕ ЗДЕСЬ ЭТИ СТАНДАРТНЫЕ ЗНАЧЕНИЯ
# ЗАДАВАЙТЕ ИХ В ФАЙЛЕ /etc/rc.conf
#
utility_enable=${utility_enable-"NO"}
pidfile=${utility_pidfile-"/var/run/utility.pid"}

run_rc_command "$1"
....

Этот скрипт будет обеспечить то, что указанное приложение `utility` будет запущено после псевдо-сервиса `DAEMON`.
Он также предоставляет инструмент для задания и отслеживания идентификатора процесса (PID).

Для этого приложения затем можно поместить следующую строку в файл [.filename]#/etc/rc.conf#:

[.programlisting]
....
utility_enable="YES"
....

Этот метод также позволяет облегчить работу с аргументами командной строки, включение стандартных функций, находящихся в [.filename]#/etc/rc.subr#, совместимость с man:rcorder[8], а также упрощает конфигурирование с помощью [.filename]#rc.conf#.

=== Использование сервисов для запуска сервисов

Другие сервисы могут быть запущены посредством man:inetd[8].
Работа с даемоном man:inetd[8] и его настройка подробно описаны в разделе crossref:network-servers[network-inetd,inetd].

В некоторых случаях может быть более подходящим использование для запуска системных служб man:cron[8].
Такой подход имеет несколько преимуществ, поскольку man:cron[8] запускает эти процессы от имени владельца man:crontab[5].
Это позволяет обычным пользователям запускать и поддерживать их собственные приложения.

Функция `@reboot` в man:cron[8] может быть использована вместо указания времени.
В результате задание выполняется при запуске man:cron[8], как правило, в ходе инициализации системы.

[[configtuning-cron]]
== Настройка man:cron[8]

Одной из наиболее полезных утилит во FreeBSD является man:cron[8].
Эта утилита работает в фоновом режиме и регулярно проверяет файл [.filename]#/etc/crontab# на предмет наличия задач к выполнению, а также каталог [.filename]#/var/cron/tabs# в поиске нестандартных файлов man:crontab[5].
Указанные файлы хранят информацию о конкретных функциях, которые, как предполагается, man:cron[8] выполнит в определённое время.

man:cron[8] использует два разных вида конфигурационных файлов: системный [.filename]#crontab# и пользовательские [.filename]#crontab#.
Эти форматы отличаются только в шестом и последующем полях.
В случае системного файла [.filename]#crontab# man:cron[8] запускает команду с полномочиями пользователя, указанного в шестом поле.
В случае пользовательского файла [.filename]#crontab# все команды запускаются с полномочиями пользователя, создавшего файл [.filename]#crontab#, так что шестое поле является последним; это важная особенность с точки зрения безопасности.
Последним полем всегда является команда для запуска.

[NOTE]
====
Пользовательские crontab позволяют индивидуальным пользователям планировать задачи без привилегий суперпользователя (`root`). Команды из crontab пользователя запускаются с привилегиями этого пользователя.

Пользователь `root` может иметь пользовательский [.filename]#crontab#, как любой другой пользователь.
Файл [.filename]#crontab# пользователя `root` существует отдельно от системного файла [.filename]#crontab#, [.filename]#/etc/crontab#.
Поскольку системный [.filename]#crontab# запускает указанные команды как `root`, то обычно создавать пользовательский [.filename]#crontab# для `root` нет необходимости.
====

Вот пример записей в [.filename]#/etc/crontab#:

[.programlisting]
....
# /etc/crontab - root's crontab for FreeBSD
#
# $FreeBSD$
## <.>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <.>
#
#minute	hour	mday	month	wday	who	command <.>
#
*/5	*	*	*	*	root	/usr/libexec/atrun <.>
....

<.> Как и в большинстве конфигурационных файлов FreeBSD, строки, начинающиеся с символа `#`, являются комментариями.  Комментарии нужны для напоминания о том, что означает строка и зачем она добавлена. Комментарии не могут находиться на той же строке, что и команда, или они будут восприняты как часть команды; располагайте их на новой строке. Пустые строки игнорируются.

<.> Знак равенства (`=`) используется для определения любых настроек окружения. В данном примере он используется для задания `SHELL` и `PATH`. Если `SHELL` опущена, то man:cron[8] будет использовать man:sh[1] по умолчанию. Если опущена `PATH`, то значение по умолчанию не устанавливается и пути к файлам должны быть полными.

<.> Эта строка определяет всего семь полей: `minute`, `hour`, `mday`, `month`, `wday`, `who` и `command`. И почти все из них говорят сами за себя. `minute` соответствует времени в минутах, когда будет запущена команда. `hour` является часом, когда будет запущена указанная команда. `mday` обозначает день месяца, а `month` соответствует месяцу. Параметр `wday` обозначает день недели. Эти поля должны принимать числовые значения, соответствующие двадцатичетырёхчасовому исчислению, или `*`, что соответствует всем возможным значениям данного поля. Поле `who` присутствует только в системном файле [.filename]#/etc/crontab#. Это поле задаёт пользователя, с полномочиями которого должна быть запущена команда. Последнее поле является командой, которая должна быть выполнена.

<.> Последняя строка определяет параметры, описанные выше. В этом примере задано значение `*/5`, за которым следуют ещё несколько символов `*`.  Эти символы `*` означают "первый-последний", и могут быть интерпретированы как _каждый_ раз.  В этом примере man:atrun[8] вызывается с полномочиями пользователя `root` каждые пять минут вне зависимости от дня или месяца.

Команды могут иметь любое количество флаговых параметров, передаваемых им; однако команды, состоящие из нескольких строк, должны быть объединены символом "\".

Такова базовая конфигурация каждого файла man:crontab[5].
Однако шестое поле, задающее имя пользователя, присутствует только в системном файле man:crontab[5].
Это поле должно быть исключено из персональных пользовательских файлов man:crontab[5].

[[configtuning-installcrontab]]
=== Установка crontab

[IMPORTANT]
====
Не используйте процедуру, описанную здесь, для редактирования и установки системного файла [.filename]#crontab#, [.filename]#/etc/crontab#.
Вместо этого используйте какой-либо текстовый редактор, а man:cron[8] заметит, что файл изменился, и сразу начнёт использовать обновлённую версию.
Обратитесь к extref:{faq}[этому разделу FAQ, root-not-found-cron-errors] для получения дополнительной информации.
====

Для установки нового пользовательского файла man:crontab[5] используйте какой-либо текстовый редактор для создания и сохранения файла в корректном формате.
Затем укажите имя этого файла с man:crontab[1]:

[source,shell]
....
% crontab crontab-file
....

В этом примере [.filename]#crontab-file# является именем файла man:crontab[5], который был создан ранее.

Для выдачи списка установленных файлов man:crontab[5] запустите man:crontab[1] с параметром `-l`.

Пользователи, которые хотят создать собственный файл [.filename]#crontab# с нуля, без использования шаблона, могут воспользоваться командой `crontab -e`.
Она вызовет используемый по умолчанию текстовый редактор с пустым файлом.
Когда файл будет сохранён, man:crontab[1] установит его автоматически.

Для того, чтобы полностью удалить пользовательский файл man:crontab[5], используйте команду `crontab -r`.

[[configtuning-rcd]]
== Использование man:rc[8] во FreeBSD

В 2002 году во FreeBSD была интегрирована система man:rc.d[8] из NetBSD, используемая для инициализации системы.
Файлы, находящиеся в каталоге [.filename]#/etc/rc.d#, обеспечивают базовые сервисы, которыми можно управлять через man:service[8] параметрами `start`, `stop` и `restart`.
Например, man:sshd[8] может быть перезапущен следующей командой:

[source,shell]
....
# service sshd restart
....

Этот способ может быть использован для запуска сервисов в работающей системе.
Сервисы будут запускаться автоматически во время загрузки, как указано в man:rc.conf[5].
Например, для активации man:natd[8] при запуске системы добавьте следующую строку в [.filename]#/etc/rc.conf#:

[.programlisting]
....
natd_enable="YES"
....

Если уже имеется строка `natd_enable="NO"`, замените `NO` на `YES`.
Скрипты man:rc[8] автоматически загрузят все прочие зависимые сервисы при следюущей загрузке, как описано ниже.

Поскольку система man:rc[8] в первую очередь предназначена для запуска и остановки сервисов при запуска и завершении работы системы, параметры `start`, `stop` и `restart` будут выполнять соответствующие действия только если задана соответствующая переменная в [.filename]#/etc/rc.conf#.
Например, `sshd restart` будет работать только если переменная `sshd_enable` в файле [.filename]#/etc/rc.conf# установлена в значение `YES`.
Для выполнения команд `start`, `stop` или `restart` для какого-либо сервиса независимо от параметров в [.filename]#/etc/rc.conf#, их нужно указывать с префиксом "one".
К примеру, для перезапуска man:sshd[8] независимо от текущих параметров в [.filename]#/etc/rc.conf#, выполните следующую команду:

[source,shell]
....
# service sshd onerestart
....

Чтобы проверить, активирован ли сервис в [.filename]#/etc/rc.conf#, запустите соответствующий скрипт man:rc[8] с параметром `rcvar`.
Этот пример выполняет проверку активации man:sshd[8] в [.filename]#/etc/rc.conf#:

[source,shell]
....
# service sshd rcvar
# sshd
sshd_enable=YES
#   (default: "")
....

[NOTE]
====
Строка `# sshd` является результатом работы команды выше, а не содержанием консоли `root`.
====

Для выяснения того, работает ли сервис или нет, используйте параметр `status`.
Например, для проверки того, работает ли man:sshd[8], выполните:

[source,shell]
....
# service sshd status
sshd is running as pid 433.
....

В некоторых случаях для сервиса также доступна операция `reload`.
При этом делается попытка отправить сигнал отдельному сервису, вызывающий перезагрузку конфигурационных файлов этого сервиса.
В большинстве случаев это означает отправку сервису сигнала `SIGHUP`.
Эту функцию поддерживают не все сервисы.

Система man:rc[8] используется для сетевых сервисов, а также она вносит свой вклад в существенную часть инициализации системы.
К примеру, при исполнении скрипта [.filename]#bgfsck# он выводит следующее сообщение:

[source,shell]
....
Starting background file system checks in 60 seconds.
....

Этот скрипт используется для фоновой проверки файловых систем, которая осуществляется только во время инициализации системы.

Функционирование многих сервисов системы зависит от корректной работы других сервисов.
Например, man:yp[8] и другие сервисы, основанные на RPC, не смогут запуститься, пока не будет стартован сервис man:rpcbind[8].
Для решения этой проблемы в начало каждого стартового скрипта в комментариях помещается информация о зависимостях и другие метаданные.
Для обработки указанных комментариев и определения порядка, в котором должны вызываться системные сервисы в соответствии со взаимными зависимостями, во время запуска системы используется программа man:rcorder[8].

Во все стартовые скрипты должны быть включены следующие ключевые слова, так как их требует man:rc.subr[8] для "активации" стартового скрипта:

* `PROVIDE`: Задаёт сервисы, предоставляемые этим файлом.

Следующие ключевые слова могут быть включены в начало каждого стартового скрипта.
Они не являются строго обязательными, однако полезны в качестве подсказок для man:rcorder[8]:

* `REQUIRE`: Перечисляет сервисы, необходимые этому сервису. Скрипт, содержащий данное ключевое слово, будет запущен _после_ указанных сервисов.
* `BEFORE`: Перечисляет сервисы, зависящие от этого сервиса. Скрипт, содержащий данное ключевое слово, будет запущен _до_ указанных сервисов.

При помощи аккуратного указания этих ключевых слов для каждого стартового скрипта администратор получает детализированный уровень контроля над порядком запуска стартовых скриптов без необходимости в "уровнях запуска", используемых некоторыми операционными системами UNIX(R).

Дополнительную информацию можно найти в man:rc[8] и man:rc.subr[8].
Обратитесь к extref:{rc-scripting}[этой статье] для получения указаний о том, как создавать собственные скрипты man:rc[8].

[[config-network-setup]]
== Настройка адаптеров сетевых интерфейсов

Добавление и настройка сетевого адаптера (NIC) являются обычными задачами любого администратора FreeBSD.

=== Поиск подходящего драйвера

В первую очередь определите модель NIC и используемую в нём микросхему.
FreeBSD поддерживает широкий спектр NIC.
Обратитесь к Списку поддерживаемого оборудования соответствующего релиза FreeBSD, чтобы узнать, поддерживается ли данный NIC.

Если NIC поддерживается, определите название соответствующего драйвера FreeBSD для этого NIC.
Обратитесь к [.filename]#/usr/src/sys/conf/NOTES# и [.filename]#/usr/src/sys/arch/conf/NOTES# для получения списка драйверов NIC с определённой информацией о поддерживаемых наборах микросхем.
При наличии сомнений прочтите справочную страницу этого драйвера, так как она даст дополнительную информацию о поддерживаемом оборудовании и известных ограничениях этого драйвера.

Драйверы для распространённых NIC уже присутствуют в ядре [.filename]#GENERIC#, так что ваш NIC должен отобразиться при загрузке.
В данном примере в системе присутствуют два NIC, использующих драйвер man:dc[4]:

[source,shell]
....
dc0: <82c169 PNIC 10/100BaseTX> port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: <MII bus> on dc0
bmtphy0: <BCM5201 10/100baseTX PHY> PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: [ITHREAD]
dc1: <82c169 PNIC 10/100BaseTX> port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: <MII bus> on dc1
bmtphy1: <BCM5201 10/100baseTX PHY> PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: [ITHREAD]
....

Если драйвер для NIC отсутствует в [.filename]#GENERIC#, но он доступен для использования, то его нужно будет загрузить до настройки и использования NIC.
Это может быть сделано одним из двух способов:

* Самым лёгким способом является загрузка модуля ядра NIC при помощи man:kldload[8]. Для того, чтобы также автоматически загружать драйвер во время загрузки, добавьте соответствующую строку в [.filename]#/boot/loader.conf#. Не все драйверы NIC доступны в виде модулей.
* Альтернативным вариантом является статическая компиляция поддержки конкретного NIC в нестандартное ядро. Обратитесь к [.filename]#/usr/src/sys/conf/NOTES# и [.filename]#/usr/src/sys/_arch_/conf/NOTES# и справочной странице драйвера для определения того, какую строку добавлять в конфигурационный файл нестандартного ядра. За более подробной информацией о перекомпиляции ядра обратитесь к разделу crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]. Если NIC был распознан во время загрузки, то перекомпиляция ядра не требуется.

[[config-network-ndis]]
==== Использование драйверов NDIS Windows(R)

К сожалению, всё ещё много производителей не предоставляют схем их драйверов сообществу открытого кода, так как считают эту информацию коммерческой тайной.
Соответственно, разработчикам FreeBSD и других операционных систем остаются два варианта: разрабатывать драйверы в рамках долгого и болезненного процесса обратного проектирования либо использовать существующие бинарные файлы драйверов, доступные для платформ Microsoft(R) Windows(R).
Большинство разработчиков, включая тех, что связаны с FreeBSD, выбрали последний подход.

FreeBSD обеспечивает "родную" поддержку NDIS (Network Driver Interface Specification).
Эта поддержка включает утилиту man:ndisgen[8], которая может использоваться для преобразования драйвера Windows(R) XP в формат, который может быть использован во FreeBSD.
Так как драйвер man:ndis[4] использует бинарный файл Windows(R) XP, он работает только в системах i386 и amd64.
Поддерживаются устройства PCI, CardBus, PCMCIA (PC-Card) и USB.

Для использования man:ndisgen[8] необходимы три вещи:

. Исходный код ядра FreeBSD
. Бинарный файл драйвера Windows(R) XP с расширением [.filename]#.SYS#
. Конфигурационный файл драйвера Windows(R) XP с расширением [.filename]#.INF#

Сгрузите файлы [.filename]#.SYS# и [.filename]#.INF# для конкретного NIC.
Вообще говоря, их можно найти на CD с драйвером или на веб-сайте вендора.
В последующих примерах используются [.filename]#W32DRIVER.SYS# и [.filename]#W32DRIVER.INF#.

Разрядность драйвера должна соответствовать версии FreeBSD.
В случае FreeBSD/i386 используйте 32-разрядный драйвер Windows(R).
Для FreeBSD/amd64 требуется 64-разрядный драйвер Windows(R).

Следующим шагом является компиляция бинарного файла драйвера в загружаемый модуль ядра.
Используйте man:ndisgen[8] как пользователь `root`:

[source,shell]
....
# ndisgen _/path/to/W32DRIVER.INF_ _/path/to/W32DRIVER.SYS_
....

Эта команда работает в интерактивном режиме и запрашивает всю требуемую ей дополнительную информацию.
Новый модуль ядра будет сформирован в текущем каталоге.
Используйте man:kldload[8] для загрузки этого нового модуля:

[source,shell]
....
# kldload _./W32DRIVER_SYS.ko
....

Вдобавок к сгенерированному модулю ядра должны быть загружены модули [.filename]#ndis.ko# и [.filename]#if_ndis.ko#.
Это должно выполняться автоматически при загрузке любого модуля, зависящего от man:ndis[4].
Если этого не происходит, загрузите их в неавтоматическом режиме при помощи следующих команд:

[source,shell]
....
# kldload ndis
# kldload if_ndis
....

Первая команда загружает оболочку драйвера минипорта man:ndis[4], а вторая загружает соответствующий сгенерированный драйвер NIC.

Проверьте man:dmesg[8] на предмет наличия каких-либо ошибок загрузки.
Если всё прошло хорошо, то выдаваемый результат должен быть похож на следующее:

[source,shell]
....
ndis0: <Wireless-G PCI Adapter> mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps
....

С этого момента `ndis0` может быть настроен так же, как и любой другой NIC.

Чтобы настроить систему на загрузку модулей man:ndis[4] при загрузке, скопируйте сгенерированный модуль [.filename]#W32DRIVER_SYS.ko# в каталог [.filename]#/boot/modules#.
Затем добавьте в [.filename]#/boot/loader.conf# следующую строку:

[.programlisting]
....
W32DRIVER_SYS_load="YES"
....

=== Настройка сетевой карты

Как только для NIC будет загружен подходящий драйвер, её необходимо сконфигурировать.
Возможно, её настройка была произведена во время установки с помощью man:sysinstall[8].

Для вывода информации о конфигурации NIC введите следующую команду:

[source,shell]
....
% ifconfig
dc0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	options=80008<VLAN_MTU,LINKSTATE>
	ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect (100baseTX <full-duplex>)
        status: active
dc1: flags=8802<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=80008<VLAN_MTU,LINKSTATE>
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> metric 0 mtu 16384
        options=3<RXCSUM,TXCSUM>
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
	nd6 options=3<PERFORMNUD,ACCEPT_RTADV>
....

В этом примере были показаны следующие устройства:

* [.filename]#dc0#: Первый интерфейс Ethernet.
* [.filename]#dc1#: Второй интерфейс Ethernet.
* [.filename]#lo0#: Устройство loopback.

Для присвоения имени сетевой карте FreeBSD использует имя драйвера и порядковый номер, в котором карта обнаруживается при загрузке.
Например, `sis2` является третьим NIC в системе, использующим драйвер man:sis[4].

В этом примере `dc0` активирован и работает.
Ключевые индикаторы таковы:

. `UP` означает, что карта настроена и готова.
. Адаптер имеет адрес Интернет (`inet`), `192.168.1.3`.
. Он имеет корректную маску подсети (`netmask`), при этом `0xffffff00` обозначает то же, что и `255.255.255.0`.
. Он имеет корректный широковещательный адрес, `192.168.1.255`.
. MAC-адресом адаптера (`ether`) является `00:a0:cc:da:da:da`.
. Выбор физической среды передачи данных в режиме автовыбора (`media: Ethernet autoselect (100baseTX full-duplex)`).  В этом примере `dc1` сконфигурирован на работу с физической средой `10baseT/UTP`.  За более подробной информацией о типах физических сред, доступных драйверу, обратитесь к его справочной странице.
. Состояние соединения (`status`) находится в статусе `active`, указывая на обнаружение несущего сигнала.  Для [.filename]#dc1# состояние `status: no carrier` является нормальным, если кабель Ethernet не подключён к адаптеру.

Если в выдаче man:ifconfig[8] присутствует что-то, подобное следующему:

[source,shell]
....
dc0: flags=8843<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500
	options=80008<VLAN_MTU,LINKSTATE>
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX <full-duplex>)
        status: active
....

это означает, что адаптер не был сконфигурирован.

Адаптер должен конфигурироваться при работе пользователем `root`.
Конфигурирование NIC может быть выполнено из командной строки с помощью man:ifconfig[8], но настройка не сохранится после перезапуска системы, если только конфигурационная информация не будет также добавлена в [.filename]#/etc/rc.conf#.
Для каждого NIC, присутствующего в системе, добавьте строку, как показано в этом примере:

[.programlisting]
....
ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"
....

Замените `dc0` и `dc1`, а также информацию об адресе IP на соответствующие значения, корректные для системы.
Обратитесь к справочной странице соответствующего драйвера, man:ifconfig[8] и man:rc.conf[5] для получения дополнительной информации о доступных параметрах и формате [.filename]#/etc/rc.conf#.

Если сеть была настроена в процессе установки системы, то некоторые записи, касающиеся NIC, могут уже присутствовать.
Дважды проверьте [.filename]#/etc/rc.conf# перед добавлением каких-либо строк.

Если в сети не используется DNS, отредактируйте [.filename]#/etc/hosts# для того, чтобы добавить имена и адреса IP соответствующих машин в LAN, если их ещё там нет.
Для получения дополнительной информации обратитесь к man:hosts[5] и [.filename]#/usr/shared/examples/etc/hosts#.

[NOTE]
====
Если сервер DHCP отсутствует, но требуется доступ в Интернет, настройте сетевой шлюз и сервер имён самостоятельно:

[source,shell]
....
# echo 'defaultrouter="ваш_маршрутизатор_по_умолчанию"' >> /etc/rc.conf
# echo 'nameserver ваш_сервер_DNS' >> /etc/resolv.conf
....
====

=== Тестирование и устранение проблем

После того, как необходимые изменения в [.filename]#/etc/rc.conf# будут сохранены, для тестирования сетевых настроек и проверки того, что система перезапускается без каких-либо ошибок в конфигурации, можно использовать перезагрузку.
Альтернативным способом является применение настроек системы работы с сетью при помощи этой команды:

[source,shell]
....
# service netif restart
....

[NOTE]
====
Если используемый по умолчанию шлюз был настроен в [.filename]#/etc/rc.conf#, также запустите следующую команду:

[source,shell]
....
# service routing restart
....
====

После того, как система работы с сетью перезапустится, проверьте NIC.

==== Проверка адаптера Ethernet

Для проверки правильности настройки сетевой карты выполните man:ping[8] для самого интерфейса, а затем выполните man:ping[8] другой машины в LAN:

[source,shell]
....
% ping -c5 192.168.1.3
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms
....

[source,shell]
....
% ping -c5 192.168.1.2
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms
....

Для проверки преобразования имён сети используйте имя хоста вместо адреса IP.
Если в сети отсутствует сервер DNS, то в первую очередь нужно обязательно сконфигурировать [.filename]#/etc/hosts#.

==== Решение проблем

При устранении проблем с настройками оборудования и программного обеспечения, проверяйте сначала простые вещи.
Подключён ли сетевой кабель?
Корректно ли настроены сетевые сервисы?
Правильно ли настроен межсетевой экран?
Поддерживается ли соответствующий NIC во FreeBSD?
Прежде чем отправлять сообщение об ошибке, всегда сверьтесь с Информацией об оборудовании, обновите FreeBSD до последней версии STABLE, просмотрите архивы списков рассылки и выполните поиск в Интернет.

Если соответствующий адаптер работает, но производительность низка, ознакомьтесь с man:tuning[7].
Кроме того, проверьте также конфигурацию сети, поскольку её некорректные настройки могут приводить к низкой скорости соединений.

Некоторые пользователи встречаются с появлением одного или двух сообщений `device timeouts`, что нормально для некоторых сетевых карт.
Если сообщения продолжают появляться или беспокоят, определите, не конфликтует ли это устройство с каким-то другим.
Ещё раз проверьте кабельное соединение.
Рассмотрите возможность использовать другой адаптер.

Для устранения ошибок `watchdog timeout` первым делом проверьте сетевой кабель.
Многим адаптерам требуется слот PCI, поддерживающий Bus Mastering.
На некоторых старых материнских платах только один слот PCI позволяет использовать такой режим, и обычно это слот 0.
Сверьтесь с документацией на NIC и материнскую плату, чтобы определить, может ли это быть проблемой.

Сообщение `No route to host` появляются, если система не в состоянии доставить пакеты к хосту назначения.
Это может происходить, когда не определён маршрут по умолчанию или кабель не подключён.
Проверьте результат работы команды `netstat -rn` и убедитесь, что к соответствующему хосту есть корректный маршрут.
Если это не так, прочтите раздел crossref:advanced-networking[advanced-networking, Сложные вопросы работы в сети].

Сообщения `ping: sendto: Permission denied` зачастую появляются при неправильно настроенном межсетевом экране.
Если межсетевой экрна активирован во FreeBSD, но правила не были заданы, то политикой, применяемой по умолчанию, является блокировка всего трафика, даже man:ping[8].
Обратитесь к разделу crossref:firewalls[firewalls, Межсетевые экраны] для получения дополнительной информации.

Иногда скорость адаптера низка или ниже среднего.
В таких случаях попробуйте изменить режим выбора типа подключения с `autoselect` на корректный.
Хотя это работает для большинства оборудования, проблема может и не решиться.
Ещё раз проверьте все сетевые настройки и обратитесь к man:tuning[7].

[[configtuning-virtual-hosts]]
== Настройка виртуальных серверов

FreeBSD часто используется для виртуального размещения сайтов, когда один сервер представлен в сети как несколько серверов.
Это достигается присвоением нескольких сетевых адресов одному интерфейсу.

Любой отдельно взятый сетевой интерфейс всегда имеет один "настоящий" адрес и может иметь любое количество "алиасов".
Эти алиасы обычно добавляются путём помещения соответствующих записей в [.filename]#/etc/rc.conf#, как показано в этом примере:

[.programlisting]
....
ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"
....

Записи об алиасах должны начинаться с `alias_0_` и использовать последовательные номера, такие как `alias0`, `alias1` и так далее.
Процесс настройки остановится на первом по порядку отсутствующем числе.

Определение маски подсети для алиасов очень важно.
Для каждого отдельно взятого интерфейса обязательно должен существовать один адрес, корректно отражающий сетевую маску соответствующей сети.
Любые другие адреса, попадающие в эту сеть, в обязательном порядке должны иметь маску подсети, полностью состоящую из `1`, что выражается как `255.255.255.255` или `0xffffffff`.

К примеру, рассмотрим случай, когда интерфейс [.filename]#fxp0# подключён к двум сетям: `10.1.1.0` с сетевой маской `255.255.255.0` и `202.0.75.16` с сетевой маской `255.255.255.240`.
Система должна быть сконфигурирована так, чтобы появиться в диапазонах с `10.1.1.1` по `10.1.1.5` и с `202.0.75.17` по `202.0.75.20`.
Только первый адрес в указанном диапазоне должен иметь реальную сетевую маску.
Все остальные (с `10.1.1.2` по `10.1.1.5` и с `202.0.75.18` по `202.0.75.20`) должны быть сконфигурированы с сетевой маской `255.255.255.255`.

Для данного сценария следующие записи в [.filename]#/etc/rc.conf# корректно сконфигурируют соответствующий адаптер:

[.programlisting]
....
ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"
....

[[configtuning-syslog]]

== Настройка регистратора системных событий `syslogd`

Протоколирование системных событий является важным аспектом системного администрирования.
Оно используется для обнаружения проблем оборудования и программного обеспечения, а также ошибок в системе.
Оно играет важную роль в аудите безопасности и реагировании на инциденты.
Системные даемоны без управляющего терминала обычно записывают информацию через системные функции регистрации событий или другой файл журнала.

Этот раздел описывает, как настроить и использовать системный регистратор FreeBSD, man:syslogd[8], и как выполнять ротацию журналов и управление ими посредством man:newsyslog[8].
Фокус будет направлен на настройку и использование man:syslogd[8] на локальной машине.
В случае более комплексных конфигураций, использующих отдельную машину для ведения журнала событий, обратитесь к разделу <<network-syslogd>>.

=== Использование `syslogd`

В стандартной конфигурации FreeBSD man:syslogd[8] запускается при загрузке.
Это управляется при помощи переменной `syslogd_enable` в [.filename]#/etc/rc.conf#.
Имеется множество параметров приложения, которые влияют на поведение man:syslogd[8].
Для их изменения используйте `syslogd_flags` в [.filename]#/etc/rc.conf#.
Обратитесь к man:syslogd[8] для получения дополнительной информации о параметрах, а также к man:rc.conf[5], разделам <<configtuning-core-configuration>> и <<configtuning-rcd>> за дополнительной информацией о [.filename]#/etc/rc.conf# и подсистеме man:rc[8].

=== Настройка `syslogd`

Конфигурационный файл, которым по умолчанию является [.filename]#/etc/syslog.conf#, управляет тем, что делает man:syslogd[8] с записями о журналируемых событиях при их получении.
Имеется несколько параметров для управления обработкой поступающих событий, из которых самыми основными являются _facility_ (объект или подсистема) и _level_ (уровень).
Объект описывает, какая подсистема сформировала сообщение, например, ядро или даемон, а уровень описывает степень серьёзности произошедшего события.
Это делает возможным записывать события в разные файлы регистрации либо отбрасывать их в зависимости от подсистемы и важности.
Также возможно осуществление действий в зависимости от приложения, которое направило сообщение, а в случае удалённого протоколирования и от имени хоста машины, формирующей регистрируемое событие.

Конфигурационный файл man:syslogd[8] содержит под одной строке для каждого действия, а синтаксически каждая строка состоит из поля выбора (селектора), за которым следует поле действия.
Синтаксис поля выбора имеет вид _объект.уровень_, которое будет соотноситься с сообщениями о событиях от _объекта_ с уровнем критичности, соответствующим или превышающим _уровень_.
Кроме того, перед уровнем можно добавить необязательный флажковый параметр сравнения для более точного указания того, что протоколируется.
Для одного и того же действия могут использоваться несколько селекторов, они разделяются точкой с запятой (`;`).
Используемый символ `*` будет соответствовать любому значению.
Поле действия указывает, куда направлять журналируемое сообщение, например, в файл или на удалённую протоколирующую машину.
В качестве примера вот файл [.filename]#syslog.conf# из FreeBSD, используемый по умолчанию:

[.programlisting]
....
# $FreeBSD$
#
#	Spaces ARE valid field separators in this file. However,
#	other *nix-like systems still insist on using tabs as field
#	separators. If you are sharing this file between systems, you
#	may want to use only tabs as field separators here.
#	Consult the syslog.conf(5) manpage.
*.err;kern.warning;auth.notice;mail.crit	/dev/console <.>
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err	/var/log/messages
security.*					/var/log/security
auth.info;authpriv.info				/var/log/auth.log
mail.info					/var/log/maillog <.>
lpr.info					/var/log/lpd-errs
ftp.info					/var/log/xferlog
cron.*						/var/log/cron
*.=debug					/var/log/debug.log <.>
*.emerg						*
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info					/var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!ppp <.>
*.*						/var/log/ppp.log
!*
....

<.> Выбирать все сообщения с уровнем `err` и выше, а также `kern.warning`, `auth.notice` и `mail.crit`, при этом направлять эти сообщения о событиях на консоль (`/dev/console`).
<.> Выбирать все сообщения от подсистемы `mail` с уровнем `info` и выше, при этом протоколировать эти сообщения в [.filename]#/var/log/maillog#.
<.> В этой строке используется флаг сравнения `=` для выбора сообщений только с уровнем `debug` и записи их в [.filename]#/var/log/debug.log#.
<.> Это пример использования функции _указания программы_. Это заставляет последующие правила применяться только для указанной программы. В данном случае эта и последующие строки заставляют все сообщения от `ppp`, но не от других программ, направляться в [.filename]#/var/log/ppp.log#.

Этот пример показывает, что существует достаточное количество уровней и подсистем.
Имеются следующие уровни, в порядке снижения уровня критичности: `emerg`, `alert`, `crit`, `err`, `warning`, `notice`, `info` и `debug`.

Объекты без определённого порядка перечисления таковы: `auth`, `authpriv`, `console`, `cron`, `daemon`, `ftp`, `kern`, `lpr`, `mail`, `mark`, `news`, `security`, `syslog`, `user`, `uucp` и `local0` до `local7`.
Имейте в виду, что в других операционных системах могут быть подсистемы, отличающиеся от указанных.

Зная это, легко добавить новую строку в [.filename]#/etc/syslog.conf# для регистрации всех событий от различных даемонов на уровне `notice` и выше в файле [.filename]#/var/log/daemon.log#. Просто добавьте следующее:

[.programlisting]
....
daemon.notice					/var/log/daemon.log
....

Для получения дополнительной информации о различных уровнях и подсистемах, обратитесь к man:syslog[3] и man:syslogd[8].
Для получения дополнительной информации о [.filename]#/etc/syslog.conf# и его синтаксисе, а также дополнительных примеров расширенного использования обратитесь к man:syslog.conf[5] и разделу <<network-syslogd>>.

=== Управление журналами событий и ротацией при помощи `newsyslog`

Журналы событий имеют свойство быстро расти и постоянно накапливать данные.
Это приводит к тому, что файлы наполняются информацией, полезность которой невелика для использования в данный момент, при этом они занимают всё больше пространства на жёстком диске.
Управление журналами событий пытается решить это.
Во FreeBSD для управления файлами журналов событий применяется man:newsyslog[8].
Эта программа периодически ротирует и сжимает файлы журналов, а при необходимости создаёт отсутствующие файлы и уведомляет программы при перемещении файлов.
Файлы журналов не обязательно генерируются man:syslogd[8], так как man:newsyslog[8] работает с любыми журналами, записываемыми любыми программами.
Хотя man:newsyslog[8] обычно запускается из man:cron[8], он не является системным даемоном.
В стандартной конфигурации он запускается каждый час.

==== Настройка `newsyslog`

Чтобы узнать, какие действия нужно предпринимать, man:newsyslog[8] считывает свой конфигурационный файл, которым по умолчанию является [.filename]#/etc/newsyslog.conf#.
В данном конфигурационном файле для каждого файла, управляемого man:newsyslog[8], выделена одна строка.
В каждой строке указан владелец файла, полномочия и то, когда ротировать файл, а также необязательные флажковые параметры, которые влияют на параметры ротации журнала, например, на сжатие, и программы, которым нужно отправить сигнал при ротации журнала.
Вот стандартный конфигурационный файл FreeBSD:

[.programlisting]
....
# configuration file for newsyslog
# $FreeBSD$
#
# Entries which do not specify the '/pid_file' field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the 'N' flag.
#
# The 'flags' field is one or more of the letters: BCDGJNUXZ or a '-'.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename		[owner:group]	mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log			600  7     *    @T00  J
/var/log/amd.log			644  7     100  *     J
/var/log/auth.log			600  7     100  @0101T JC
/var/log/console.log			600  5     100  *     J
/var/log/cron				600  3     100  *     JC
/var/log/daily.log			640  7     *    @T00  JN
/var/log/debug.log			600  7     100  *     JC
/var/log/kerberos.log			600  7     100  *     J
/var/log/lpd-errs			644  7     100  *     JC
/var/log/maillog			640  7     *    @T00  JC
/var/log/messages			644  5     100  @0101T JC
/var/log/monthly.log			640  12    *    $M1D0 JN
/var/log/pflog				600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log	root:network	640  3     100  *     JC
/var/log/security			600  10    100  *     JC
/var/log/sendmail.st			640  10    *    168   B
/var/log/utx.log			644  3     *    @01T05 B
/var/log/weekly.log			640  5     1    $W6D0 JN
/var/log/xferlog			600  7     100  *     JC
....

Каждая строка начинается с имени файла для ротации, за которым может указываться владелец и группа для ротируемого и вновь создаваемого файлов.
Поле `mode` задаёт полномочия на доступ к файлу журнала, а `count` указывает на количество подлежащих хранению ротируемых файлов.
Поля `size` и `when` говорят man:newsyslog[8], когда ротировать этот файл.
Файл журнала ротируется, когда либо его размер превышает значение поля `size`, либо после того, как истечёт время, указанное в поле `when`.
`*` означает, что данное поле игнорируется.
Поле _flags_ даёт man:newsyslog[8] дополнительные инструкции, такие как способ сжатия ротированного файла или необходимость создания файла журнала, если он отсутствует.
Последние два поля является необязательными и задают файл PID некоторого процесса и номер сигнала для отправки этому процессу при ротации файла.
Для получения дополнительной информации обо всех полях, действующих флажковых параметрах и о том, как задать время ротации, обратитесь к  man:newsyslog.conf[5].
Так как man:newsyslog[8] запускается из man:cron[8], он не может ротировать файлы чаще, чем запускается из man:cron[8].

[[configtuning-configfiles]]
== Файлы настройки

=== Каталог [.filename]#/etc#

Во FreeBSD определён ряд каталогов, предназначенных для хранения конфигурационных файлов. Это:

[.informaltable]
[cols="1,1", frame="none"]
|===

|[.filename]#/etc#
|Общая конфигурационная информация конкретной системы.

|[.filename]#/etc/defaults#
|Версии системных конфигурационных файлов по умолчанию.

|[.filename]#/etc/mail#
|Дополнительные конфигурационные файлы man:sendmail[8] и другие конфигурационные файлы MTA.

|[.filename]#/etc/ppp#
|Настройка для user- и kernel-ppp программ. 

|[.filename]#/etc/namedb#
|Основное место расположения данных man:named[8]. Обычно [.filename]#named.conf# и файлы зон расположены здесь.

|[.filename]#/usr/local/etc#
|Конфигурационные файлы установленных приложений. Могут содержать подкаталоги приложений.

|[.filename]#/usr/local/etc/rc.d#
|Скрипты man:rc[8] установленных приложений.

|[.filename]#/var/db#
|Автоматически генерируемые системно-специфичные файлы баз данных, такие как база данных пакетов и база данных man:locate[1].
|===

=== Имена хостов

==== [.filename]#/etc/resolv.conf#

man:resolv.conf[5] управляет тем, как система FreeBSD обращается к Системе Доменных Имён Интернет (DNS).

Основные записи в [.filename]#/etc/resolv.conf# таковы:

[.informaltable]
[cols="1,1", frame="none"]
|===

|`nameserver`
|IP-адрес сервера имён, к которому должен обращаться преобразователь имён. Сервера опрашиваются в порядке перечисления, и их максимальное количество равно трём.

|`search`
|Список доменов для поиска с помощью hostname lookup. Обычно определяется доменом, в котором находится компьютер.

|`domain`
|Домен, в котором находится компьютер.
|===

Типичный [.filename]#/etc/resolv.conf# выглядит подобно следующему:

[.programlisting]
....
search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30
....

[NOTE]
====
Опции `search` и `domain` нельзя использовать совместно.
====

При использовании DHCP man:dhclient[8] обычно перезаписывает [.filename]#/etc/resolv.conf# информацией, полученной от серверов DHCP.

==== [.filename]#/etc/hosts#

[.filename]#/etc/hosts# представляет собой простую текстовую базу данных, которая работает совместно с DNS и NIS, обеспечивая сопоставление имени хоста и адреса IP.
Для простейших задач именования вместо настройки сервера man:named[8] в этот файл могут быть добавлены записи для локальных компьютеров, соединённых с помощью LAN.
Кроме того, [.filename]#/etc/hosts# используется для записи IP адресов и соответствующих им доменов, снижая потребность в обращениях к внешним серверам DNS для часто запрашиваемых имён.

[.programlisting]
....
# $FreeBSD$
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace 'my.domain' below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#      10.0.0.0        -   10.255.255.255
#      172.16.0.0      -   172.31.255.255
#      192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#
....

Формат [.filename]#/etc/hosts# имеет следующий вид:

[.programlisting]
....
[IP адрес в Интернете] [имя компьютера] [alias1] [alias2] ...
....

Например:

[.programlisting]
....
10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2
....

За дополнительной информацией обращайтесь к man:hosts[5].

[[configtuning-sysctl]]
== Тонкая настройка с использованием man:sysctl[8]

man:sysctl[8] используется для внесения изменений в работающую систему FreeBSD.
К ним относятся многие расширенные параметры стека TCP/IP и системы виртуальной памяти, которые в руках опытного системного администратора могут существенно улучшить производительность.
С помощью man:sysctl[8] можно считать и задать значения более пяти сотен системных переменных.

По своей сути, man:sysctl[8] выполняет две функции: чтение и изменение настроек системы.

Для просмотра всех доступных для чтения переменных:

[source,shell]
....
% sysctl -a
....

Чтобы считать определённую переменную, укажите её название:

[source,shell]
....
% sysctl kern.maxproc
kern.maxproc: 1044
....

Для присвоения значения переменной, используйте формат _переменная_=_значение_:

[source,shell]
....
# sysctl kern.maxfiles=5000
kern.maxfiles: 2088 -> 5000
....

Переменные sysctl обычно принимают строковые, численные или логические значения, при этом в случае логических значений `1` соответствует положительному значению, а `0` отрицательному.

Для автоматической установки некоторых переменных при каждой загрузке машины добавьте их в [.filename]#/etc/sysctl.conf#.
За дополнительной информацией обратитесь к man:sysctl.conf[5] и разделу <<configtuning-sysctlconf>>.

[[configtuning-sysctlconf]]
=== [.filename]#sysctl.conf#

Конфигурационный файл для man:sysctl.conf[8], [.filename]#/etc/sysctl.conf#, очень похож на [.filename]#/etc/rc.conf#.
Значения задаются в форме `variable=value`.
Указанные значения устанавливаются после перевода системы в многопользовательский режим.
В этом режиме могут быть установлены значения не всех переменных.

Например, чтобы отключить протоколирование прекращения работы программ из-за аварийных ошибок и ограничить пользователям просмотр процессов, запущенных другими пользователями, в [.filename]#/etc/sysctl.conf# могут быть заданы следующие параметры:

[.programlisting]
....
# Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0
....

[[sysctl-readonly]]
=== Переменные man:sysctl[8], доступные только для чтения

В некоторых случаях может оказаться желательным изменить значения переменных man:sysctl[8], доступных только для чтения, что будет требовать перезагрузки системы.

Например, на некоторых моделях ноутбуков определение диапазона памяти устройством man:cardbus[4] не может быть выполнено, при этом операция завершится неудачно с сообщениями, подобными следующим:

[source,shell]
....
cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12
....

Исправление требует изменения параметра man:sysctl[8], доступного только для чтения.
Добавьте `hw.pci.allow_unsupported_io_range=1` в [.filename]#/boot/loader.conf# и выполните перезагрузку.
Теперь man:cardbus[4] должен работать корректно.

[[configtuning-disk]]
== Тонкая настройка дисков

В следующем разделе будут описаны различные механизмы тонкой настройки и параметры, которые могут быть применены к дисковым устройствам.
Во многих случаях диски с механическими частями, подобные приводам SCSI, будут являться узким местом, снижающим общую производительность системы.
Хотя решением является установка диска без механических компонентов, например, твердотельного накопителя, в близком будущем механические приводы никуда не исчезнут.
В процессе тонкой настройки дисков полезно использовать возможности команды man:iostat[8] для проверки различных изменений в системе.
Эта команда позволяет пользователю получать ценную информацию о системном вводе/выводе.

=== Переменные Sysctl

==== `vfs.vmiodirenable`

Значение man:sysctl[8]-переменной `vfs.vmiodirenable` может быть установлено равным `0` (выключено) или `1` (включено).
По умолчанию значение установлено равным `1`.
Эта переменная управляет тем, как в системе кэшируются каталоги.
Большинство каталогов невелики и занимают всего лишь один фрагмент (обычно 1 K) файловой системы и, как правило, 512 байт в буферном кэше.
При отключении этой переменной буферный кэш будет хранить только фиксированное количество каталогов, даже если в системе имеется огромное количество памяти.
При включении эта переменная man:sysctl[8] позволяет этому буферному кэшу использовать кэш страниц памяти VM для кэширования каталогов, делая доступным для кэширования каталогов всю память.
Однако минимальный объём памяти, используемой для кэширования какого-либо каталога, соответствует размеру физической страницы (обычно 4 K), а не 512 байт.
Рекомендуется оставлять этот параметр включённым, если в системе работают любые сервисы, обрабатывающие большое количество файлов.
Примерами таких сервисов могут служить веб-кэши, большие почтовые системы и серверы новостей.
В целом включение этого параметра не понизит производительности, даже с учётом затрат оперативной памяти, однако лучше это проверить, чтобы убедиться.

==== `vfs.write_behind`

Значение man:sysctl[8]-переменной `vfs.write_behind` по умолчанию установлено равным `1` (включено).
Это указывает файловой системе на осуществление записи на носитель при полном наполнении кластеров, что обычно происходит при записи больших последовательных файлов.
Это позволяет избежать насыщения буферного кэша буферами с изменёнными данными, когда это не увеличивает производительность ввода/вывода.
Однако это может застопорить процессы и в определённых ситуациях должно быть отключено.

==== `vfs.hirunningspace`

man:sysctl[8]-переменная `vfs.hirunningspace` определяет на уровне всей системы объём записывающих операций ввода/вывода, которые в любой момент могут быть поставлены в очередь дисковым контроллерам.
Значения по умолчанию обычно бывает достаточно, но на машинах с большим количеством дисков попробуйте увеличить его до четырёх или пяти _мегабайт_.
Установка слишком большого значения, превышающего порог записи буферного кэша, может привести к низкой производительности кластеризации.
Не делайте это значение необоснованно большим, так как более высокие значения могут добавить задержку к операциям чтения, выполняемых в то же время.

Имеются и другие различные переменные man:sysctl[8], относящиеся к буферному кэшу и кэшу страниц VM.
Изменение их значений не рекомендуется, поскольку система VM хорошо справляется с задачей самостоятельной автоматической оптимизации.

==== `vm.swap_idle_enabled`

man:sysctl[8]-переменная `vm.swap_idle_enabled` полезна в больших многопользовательских системах с множеством активно работающих пользователей и простаивающих процессов.
Подобные системы склонны к генерации постоянной нагрузки на резервы свободной памяти.
Включение этой функции и тонкая настройка задержки выгрузки в память подкачки (в секундах простоя) при помощи `vm.swap_idle_threshold1` и `vm.swap_idle_threshold2` понижает приоритет страниц памяти, занятых простаивающими процессами, быстрее, чем обычный алгоритм выгрузки страниц.
Это помогает даемону выгрузки страниц.
Включайте этот параметр только при необходимости, так как негативным эффектом является по сущности более ранняя выгрузка страниц из памяти, что требует больше памяти подкачки и пропускной способности диска.
В небольших системах этот параметр будет давать предсказуемый эффект, однако в больших системах, уже осуществляющих определённый объём выгрузки страниц, данный параметр позволяет системе VM проще загружать и выгружать из памяти целые процессы.

==== `hw.ata.wc`

Отключение кэширования записи IDE снижает производительность записи на диски IDE, но иногда может быть необходимым ввиду проблем с консистентностью данных, привносимых производителями жёстких дисков.
Проблема состоит в том, что некоторые диски IDE сообщают неверную информацию о завершении записи.
При включенном кэшировании записи жёсткие диски IDE записывают данные не в порядке поступления, и при большой нагрузке на диск иногда откладывают запись некоторых блоков на неопределённый срок.
Сбой или отключение питания могут могут стать причиной серьёзных повреждений в файловой системе.
Проверьте значение man:sysctl[8]-переменной `hw.ata.wc`, применяемое по умолчанию в системе.
Если кэширование записи IDE выключено, то для его включения при загрузке можно установить значение указанной переменной, доступной только для чтения, равным `1` в файле [.filename]#/boot/loader.conf#.

За дополнительной информацией обратитесь к man:ata[4].

==== `SCSI_DELAY` (`kern.cam.scsi_delay`)

Параметр конфигурации ядра `SCSI_DELAY` может быть использован для уменьшения времени загрузки системы.
Используемое по умолчанию значение достаточно велико и может являться причиной задержки в `15` секунд в процессе загрузки.
Уменьшение его до `5` секунд обычно срабатывает с современными накопителями.
Следует использовать настраиваемый параметр загрузки `kern.cam.scsi_delay`.
Этот настраиваемый параметр и параметр конфигурации ядра принимают значения в _миллисекундах_, а _не_ в _секундах_.

[[soft-updates]]
=== Мягкие обновления

Для тонкой настройки файловой системы используйте man:tunefs[8].
У этой программы имеется большое количество различных параметров.
Для включения и отключение мягких обновлений используйте:

[source,shell]
....
# tunefs -n enable /filesystem
# tunefs -n disable /filesystem
....

Файловая система не может быть изменена с помощью man:tunefs[8], пока она смонтирована.
Самое подходящее время для включения "Soft Updates" - перед монтированием разделов, в однопользовательском режиме.

Механизм мягких обновлений рекомендован для файловых систем UFS, так как он резко увеличивают производительность работы с метаданными, в основном создания и удаления файлов за счёт использования кэша в памяти.
Есть и два недостатка мягких обновлений, которые нужно иметь в виду.
Во-первых, мягкие обновления гарантируют целостность файловой системы в случае сбоя, но до момента обновления физического диска легко может пройти несколько секунд или даже минута.
Если в системе произойдёт сбой, то незаписанные данные могут быть потеряны.
Во-вторых, мягкие обновления вносят задержку в высвобождение блоков файловой системы.
Если соответствующая корневая файловая система практически полна, выполнение значительного обновления, такого как `make installworld`, может привести к исчерпанию пространства файловой системы и неудачное завершение соответствующего обновления.

==== Дополнительная информация о мягких обновлениях

Обновления метаданных представляют собой обновления данных, не относящихся к содержимому, таких как каталоги или индексные дескрипторы.
Существуют два традиционных подхода к записи метаданных файловой системы снова на диск.

Исторически подход по умолчанию заключается в синхронной записи обновлений метаданных.
Если какой-либо каталог был изменён, система ждала, пока изменение не будет действительно записано на диск.
Буферы данных файла (содержимого файла) обрабатывались через кэш буфера и записывались на диск позже в асинхронном режиме.
Преимуществом этого способа является его безопасная работа.
Если во время обновления происходит сбой, соответствующие метаданные всегда находятся в консистентном состоянии.
Файл либо создаётся целиком, либо вообще не создаётся.
Если блоки данных файла к моменту сбоя не завершили свой путь из буфера на диск, то man:fsck[8] распознаёт это и исправляет файловую систему, устанавливая длину соответствующего файла равной `0`.
Кроме того, реализация этого метода понятна и проста.
Недостаток заключается в том, что обновления метаданных выполняются медленно.
К примеру, команда `rm -r` последовательно затрагивает все файлы в каталоге, однако каждое изменение будет записано на диск в синхроном режиме.
Сюда включаются обновления самого каталога, таблицы индексных дескрипторов, и, возможно, блоков непрямой адресации, занятых файлом.
Похожие сложности возникают и в случае распаковки крупных иерархий при помощи `tar -x`.

Второй метод заключается в использовании асинхронного обновления метаданных.
Он применяется по умолчанию для файловой системы UFS, монтируемой командой `mount -o async`.
Так как все обновления метаданных также проходят через кэш буферов, они будут чередоваться с обновлениями данных, относящихся к содержимому файла.
Преимуществом такой реализации заключается в том, что нет необходимости в ожидании момента, когда все обновления метаданных будут записаны на диск, поэтому все операции, приводящие к огромному количеству обновлений метаданных, работают гораздо быстрее, чем при синхронном способе.
Такая реализация остаётся быть понятной и простой, поэтому риск появления ошибок в коде невелик.
Недостаток заключается в том, что гарантии целостности файловой системы отсутствуют.
Если сбой, подобный отключению электропитания или нажатию кнопки сброса, происходит во время операции обновления большого объёма метаданных, файловая система будет оставаться в непредсказуемом состоянии.
После того, как система снова вернётся к работе, возможность анализа состояния файловой системы отсутствует, так как блоки данных того или иного файла могут быть уже записаны на диск, в отличие от обновлений таблицы индексных дескрипторов или связанного каталога.
Невозможно реализовать man:fsck[8], которая могла бы исправить получившийся хаос, поскольку необходимая информация на диске отсутствует.
Если файловая система была повреждена без возможности восстановления, единственным вариантом является её повторное форматирование и восстановление из резервной копии.

Обычным способом решения этой проблемы состоит в реализации _области протоколирования изменений_ (dirty region logging), известном также как _журналирование_.
Обновления метаданных продолжают записываться на диск в синхронном режиме, но в небольшую область диска.
Позже они перемещаются в корректное местоположение.
Поскольку область протоколирования является небольшой и непрерывной областью диска, то для его головок нет больших расстояний для перемещения, даже при выполнении большого количества операций, поэтому они осуществляется быстрее, чем синхронные обновления.
Кроме того, сложность реализации ограничена, поэтому риск наличия ошибок невелик.
Недостаток заключается в том, что все метаданные записываются дважды, один раз в область протоколирования и один раз в корректное местоположение, поэтому это может приводить к "пессимизации" производительности.
С другой стороны, в случае сбоя все незавершённые действия с метаданными могут быть либо оперативно возвращены назад, либо завершены из области протоколирования после возобновления работы системы, что приводит к быстрому запуску файловой системы.

Кирк МакКусик, разработчик Berkeley FFS, решил эту проблему с помощью мягких обновлений.
Все незавершённые обновления метаданных остаются в памяти и записываются на диск в упорядоченной последовательности ("упорядоченные обновления метаданных").
Это приводит к тому, что в случае большого количества операций с метаданными более поздние обновления "догоняют" выполненные ранее и всё ещё находящиеся в памяти, но не записанные на диск.
В целом все операции осуществляются в памяти до того, как обновление записывается на диск, а блоки данных сортируются в соответствии с их положением, так что они не окажутся на диске раньше метаданных.
При аварийном сбое операционной системы выполняется безусловный "откат журнала", приводящий к тому, что всё выглядит так, как будто все операции, не записанные на диск, никогда не происходили.
Поддерживается состояние целостности файловой системы, соответствующее тому, в котором она находилась за 30-60 секунд до этого.
Используемый алгоритм гарантирует, что все используемые ресурсы маркированы соответствующим образом в своих блоках и индексных дескрипторах.
После сбоя единственная проявляющаяся ошибка выделения ресурсов заключается в том, что ресурсы помечены как "используемые", хотя на самом деле они "свободны".
man:fsck[8] распознаёт такую ситуацию и освобождает более не используемые ресурсы.
Принудительное монтирование файловой системы командой `mount -f` с игнорированием некорректного состояния файловой системы безопасно.
Для того, чтобы освободить ресурсы, которые могут быть неиспользуемыми, позже необходимо запустить man:fsck[8].
Эта идея лежит в основе _фонового man:fsck[8]_: во время запуска системы записывается только _мгновенный снимок_ файловой системы, а man:fsck[8] запускается позже.
После этого все файловые системы могут быть смонтированы в "нечистом" состоянии, а запуск системы продолжается в многопользовательском режиме.
Затем планируются фоновые man:fsck[8] для всех файловых систем, где это необходимо, чтобы высвободить ресурсы, которые могут быть неиспользуемыми.
Файловые системы, которые не используют мягкие обновления, всё ещё требуют обычного man:fsck[8] в активном режиме.

Преимущество заключается в том, что операции с метаданными производятся почти так же быстро, как при асинхронных обновлениях, и быстрее, чем _журналирование_, когда метаданные должны быть записаны дважды.
К недостаткам относятся сложность кода, более высокий уровень потребления памяти и несколько идиосинкразий.
После сбоя состояние файловой системы является несколько "устаревшим".
В ситуациях, когда стандартный синхронный метод привёл бы к появлению нескольких файлов нулевого размера после man:fsck[8], при использовании мягких обновлений эти файлы не будут существовать совсем, поскольку ни метаданные, ни содержимое файлов не были записаны на диск.
Дисковое пространство не освобождается, пока обновления не будут записаны на диск, что после выполнения команды man:rm[1] может занять некоторое время.
Это может вызвать проблемы при записи большого объёма данных в файловой системе, где недостаточно свободного места для размещения всех файлов дважды.

[[configtuning-kernel-limits]]
== Изменение ограничений, накладываемых ядром

[[file-process-limits]]
=== Ограничения на Файлы/Процессы

[[kern-maxfiles]]
==== `kern.maxfiles`

Значение man:sysctl[8]-переменной `kern.maxfiles` может быть увеличено или уменьшено в зависимости от потребностей системы.
Эта переменная указывает максимальное количество файловых дескрипторов в системе.
Когда таблица дескрипторов файлов полна, в буфере системных сообщений, который может быть просмотрен при помощи man:dmesg[8], будет повторяться сообщение `file: table is full`.

Каждый открытый файл, сокет или буфер использует дескриптор файла. Широкомасштабному серверу может понадобиться много тысяч дескрипторов файлов, в зависимости от количества программ, одновременно выполняемых на сервере.

В более старых релизах FreeBSD значение `kern.maxfile`, используемое по умолчанию, определяется на основании параметра `maxusers` в конфигурационном файле ядра.
`kern.maxfiles` растёт пропорционально значению `maxusers`.
При компиляции отдельного ядра рассмотрите установку значения этой переменной ядра в соответствии с использованием системы.
Значения большинства предопределённых лимитов ядра задаётся на основании этого показателя.
Даже если продуктивная машина может и не иметь 256 одновременно подключённых пользователей, требуемые ресурсы могут быть сравнимы с крупномасштабным веб-сервером.

Значение man:sysctl[8]-переменной `kern.maxusers` доступно только для чтения и рассчитывается в процессе загрузки автоматически в зависимости от объёмов памяти, доступных системе, и может быть выяснено во время работы просмотром значения `kern.maxusers`.
Некоторым системам требуются более высокие или более низкие значения `kern.maxusers`, при этом значения, равные `64`, `128` и `256` не являются редкими.
Если нет необходимости в огромном количестве файловых дескрипторов, превышение значения `256` не рекомендуется.
Многие из настраиваемых значений, установленных в соответствующие значения по умолчанию на основании `kern.maxusers`, могут быть в индивидуальном порядке переопределены в процессе загрузки или во время работы системы в [.filename]#/boot/loader.conf#.
Обратитесь к man:loader.conf[5] и [.filename]#/boot/defaults/loader.conf# за дополнительной информацией и подсказками.

В более старых релизах система будет автоматически подстраивать показатель `maxusers`, если оно установлено в значение `0`.footnote:[Алгоритм автоматической подстройки устанавливает значение `maxusers` равным объёму памяти в системе, с минимумом, равным `32` и максимумом, равным `384'.]
При настройке этого параметра задайте значение `maxusers` равным по крайней мере `4`, особенно если в системе запускается Xorg или она используется для компиляции программного обеспечения.
Самой важной таблицей, определяемой при помощи `maxusers`, является максимальное количество процессов, которое устанавливается равным `20 + 16 * maxusers`.
Если `maxusers` установлено в значение `1`, то одновременно могут существовать лишь `36` процессов, в том числе около `18`, которые система запускает в процессе загрузки, и примерно `15`, используемых Xorg.
Даже такая простая задача, как чтение страницы Справочника, запускает девять процессов для её фильтрации, распаковки и просмотра.
Установка `maxusers` в значение `64` позволяет иметь вплоть до `1044` одновременных процессов, чего должно быть достаточно практически для любых применений.
Если, тем не менее, при попытке запуска очередной программы выдаётся сообщение об ошибке `proc table full` или же сервер имеет дело с большим количеством одновременно работающих пользователей, увеличьте это значение и выполните повторную компиляцию.

[NOTE]
====
`maxusers` _не_ ограничивает количество пользователей, которые могут заходить на соответствующую машину.
Оно просто устанавливает различные размеры таблиц в разумные значения, учитывая максимальное количество пользователей в системе, и то, как много процессов каждый из них будет запускать одновременно.
====

==== `kern.ipc.somaxconn`

man:sysctl[8]-переменная `kern.ipc.somaxconn` ограничивает размер очереди для приёма новых соединений `TCP`.
Значение `128`, применяемое по умолчанию, обычно слишком мало для надёжной обработки новых соединений для высоконагруженного веб-сервера.
Для таких системных окружений рекомендуется увеличить это значение до `1024` или более высокого.
Сервис, подобный man:sendmail[8] или Apache, может сам ограничивать очередь входящих соединений, однако зачастую будет иметь какую-то директиву в своём файле конфигурации для настройки размера очереди.
Большие очереди входящих соединений лучше справляются с задачей по избежанию атак типа отказа в обслуживании (DoS).

[[nmbclusters]]
=== Сетевые Ограничения

Параметр конфигурации ядра `NMBCLUSTERS` определяет количество Mbuf, доступных данной системе.
Сервер с высоким трафиком и низким значением Mbuf будет иметь сниженную производительность.
Каждый кластер соответствует примерно 2 K памяти, так что значение `1024` означает `2` мегабайта памяти ядра, зарезервированной для буферов сети.
Для определения их необходимого количества можно выполнить простой расчёт.
Веб-сервер с максимальным количеством одновременных соединений, равным `1000`, где каждое соединение использует 6 K для буфера приёма и 16 K для буфера передачи, требует примерно 32 МБ для буферов сети, покрывающих потребности веб-сервера.
Хорошим правилом является умножение этого значения на `2`, так что 2x32 МБ / 2 КБ = 64 МБ / 2 кБ = `32768`.
Значения между `4096` и `32768` рекомендуются для машин с более высоким объёмом памяти.
Никогда не указывайте произвольно большое значение параметра, так как это может привести к аварийной остановке системы при загрузке.
Для просмотра использования сетевых кластеров используйте man:netstat[1] с параметром `-m`.

Для настройки в процессе загрузки нужно использовать переменную загрузчика `kern.ipc.nmbclusters`.
Только в старых версиях FreeBSD требуется использование параметра `NMBCLUSTERS` конфигурации ядра man:config[8].

Для нагруженных серверов, интенсивно использующих системный вызов man:sendfile[2], может потребоваться увеличения буферов man:sendfile[2] с помощью параметра конфигурации ядра `NSFBUFS`, или изменения значения путем установки переменной в [.filename]#/boot/loader.conf# (обратитесь к man:loader[8] за подробностями).
Частым признаком того, что параметр требуется изменить, является нахождение процессов в состоянии `sfbufa`.
man:sysctl[8]-переменная `kern.ipc.nsfbufs` доступна только для чтения.
Номинально этот параметр увеличивается вместе с `kern.maxusers`, однако его может потребоваться настроить соответствующим образом.

[IMPORTANT]
====
Даже если сокет помечен как неблокирующий, вызов man:sendfile[2] на неблокирующем сокете может вызвать блокирование man:sendfile[2], пока не станет доступным достаточное количество `struct sf_buf`.
====

==== `net.inet.ip.portrange.*`

man:sysctl[8]-переменные `net.inet.ip.portrange.*` управляют диапазонами номеров портов, автоматически привязываемых к сокетам `TCP` и `UDP`.
Имеются три диапазона: нижний диапазон, диапазон, используемый по умолчанию, и верхний диапазон.
Большинство сетевых программ используют диапазон, используемый по умолчанию, контролируемый `net.inet.ip.portrange.first` и `net.inet.ip.portrange.last`, установленными, соответственно, в значения `1024` и `5000`.
Привязанные диапазоны портов используются для исходящих соединений и при некоторых условиях возможно, что порты системы будут исчерпаны.
Чаще всего это происходит при работе сильно нагруженного проксирующего веб-сервера.
Диапазон портов не является проблемой при работе сервера, который в основном обрабатывают входящие соединения, подобно веб-серверу, или имеют ограниченное количество исходящих соединений, подобно почтовому узлу.
Для ситуаций, когда имеется нехватка портов, рекомендуется немного увеличить `net.inet.ip.portrange.last`.
Значения `10000`, `20000` или `30000` могут быть подходящими.
Учтите влияния межсетевого экрана при изменении диапазона портов.
Некоторые межсетевые экраны могут блокировать большие диапазоны портов, обычно с небольшими номерами, и предполагают использование системами более высоких диапазонов портов для исходящих соединений.
По этой причине не рекомендуется уменьшать значение `net.inet.ip.portrange.first`.

==== `TCP` Bandwidth Delay Product

Ограничение показателя интегральной пропускной способности `TCP` (Bandwidth Delay Product) может быть включено установкой man:sysctl[8]-переменной `net.inet.tcp.inflight.enable` в значение `1`.
При этом система попытается вычислить показатель интегральной пропускной способности для каждого соединения и ограничить объём данных, передаваемых в сеть, значением, требуемым для поддержания оптимальной пропускной способности.

Данная функция полезна при передаче данных через модемы, Gigabit Ethernet, высокоскоростные `WAN`-соединения или любые другие соединения с высоким показателем интегральной пропускной способности, особенно если также используется масштабирование размера окна или когда настроено большое окно передачи.
При включении этого параметра также установите значение переменной `net.inet.tcp.inflight.debug` равным `0`, чтобы отключить отладку.
Для использования в режиме промышленной эксплуатации установка значения переменной `net.inet.tcp.inflight.min` равным как минимум `6144`, может быть полезной.
Установка большого значения для минимумов может, в зависимости от конкретного соединения, практически отключить ограничение пропускной способности.
Эта ограничивающая функция уменьшает объём данных, накапливаемых в промежуточных очередях маршрутизации и коммутации пакетов и уменьшает объём данных, накапливаемых в очереди интерфейса локального хоста.
С меньшим количеством пакетов в очереди интерактивные соединения, особенно на медленных модемах, будут осуществляться с меньшим показателем _Round Trip Times_.
Эта функция не влияет на приём или скачивание данных.

Изменение значения переменной `net.inet.tcp.inflight.stab` _не_ рекомендуется.
Значение этого параметра по умолчанию равно `20`, что соответствует 2 максимальным пакетам, добавляемым к расчёту окна интегрального показателя пропускной способности.
Дополнительное окно требуется для стабилизации алгоритма и улучшения восприимчивости к изменению условий, но это также может привести к более высоким задержкам man:ping[8] на медленных соединениях, хотя всё же гораздо меньшим, чем без алгоритма inflight.
В таких случаях попробуйте уменьшить этот параметр до `15`, `10` или 5, и уменьшить значение `net.inet.tcp.inflight.min`, например, до `3500` для получения желаемого эффекта.
Уменьшение значений этих параметров должно осуществляться только в качестве крайней меры.

=== Виртуальная память

==== `kern.maxvnodes`

Виртуальный узел (vnode) является внутренним представлением какого-либо файла или каталога.
Увеличение количества виртуальных узлов, доступных операционной системе, снижает объём дискового ввода/вывода.
Обычно это обрабатывается операционной системой и не требует изменений.
В некоторых случаях, когда дисковый ввод/вывод является узким местом и виртуальные узлы исчерпаны, значение этой переменной следует увеличить.
При этом необходимо будет принять во внимание объём неактивной и свободной оперативной памяти.

Текущее количество использованных vnode можно посмотреть при помощи команды:

[source,shell]
....
#  sysctl vfs.numvnodes
vfs.numvnodes: 91349
....

Максимальное количество vnode, доступных системе:

[source,shell]
....
#  sysctl kern.maxvnodes
kern.maxvnodes: 100000
....

Если количество используемых виртуальных узлов близко к максимуму, попробуйте увеличить значение переменной `kern.maxvnodes` на `1000`.
Следите за количеством `vfs.numvnodes`.
Если оно снова приближается к максимуму, то `kern.maxvnodes` необходимо ещё увеличить.
В противном случае изменение в использовании памяти, отражаемое в man:top[1], должно быть заметным, при этом больше памяти должно быть в статусе активной.

[[adding-swap-space]]
== Увеличение объема подкачки

Иногда системе требуется дополнительный объём памяти подкачки.
Есть три способа увеличения объёма памяти подкачки: добавить новый жёсткий диск, включить подкачку поверх `NFS` или создать файл памяти подкачки в каком-нибудь существующем разделе диска.

За информацией о том, как шифровать память подкачки, какие имеются параметры и почему это должно быть сделано, обратитесь к разделу crossref:disks[swap-encrypting,“Шифрование области подкачки”].

[[new-drive-swap]]
=== Память подкачки на новом или существующем жёстком диске

Добавление нового жёсткого диска для памяти подкачки даёт более высокую производительность, чем добавление раздела на существующем устройстве.
Конфигурирование разделов и жёстких дисков описаны в <<disks-adding>>, а в разделе <<configtuning-initial>> обсуждаются планирование разделов и факторы, влияющие на размер раздела памяти подкачки.

Используйте man:swapon[8] для добавления раздела подкачки в систему.
Например:

[source,shell]
....
# swapon /dev/ada1s1b
....

[WARNING]
====
Возможно использование любого не смонтированного в данный момент раздела, даже если он уже содержит данные.
Применение man:swapon[8] к разделу, содержащему данные, приведёт к перезаписи и уничтожению этих данных.
До запуска man:swapon[8] проверьте, что в качестве раздела, добавляемого как память подкачки, действительно указан тот раздел, что предполагался быть указанным.
====

Для автоматического добавления этого раздела памяти подкачки при загрузке добавьте запись в [.filename]#/etc/fstab#:

[.programlisting]
....
/dev/ada1s1b	none	swap	sw	0	0
....

Обратитесь к man:fstab[5] для получения описания записей в [.filename]#/etc/fstab#.

[[nfs-swap]]
=== Подкачка поверх `NFS`

Подкачка поверх `NFS` рекомендуется только в случае, когда локальный жёсткий диск для подкачки отсутствует.
Подкачка поверх `NFS` будет ограничена доступной пропускной способностью сети, а также даёт дополнительную нагрузку на man:nfsd[8].

[[create-swapfile]]
=== Файлы памяти подкачки

Для создания файла подкачки укажите его размер.
В следующем примере создаётся файл размером 64МБ с именем [.filename]#/usr/swap0#.

.Создание файла подкачки в FreeBSD
[example]
====
. В ядро [.filename]#GENERIC# уже включён драйвер организации диска в оперативной памяти (man:md[4]), требуемый для этой операции.
При построении нестандартного ядра убедитесь, что в конфигурационном файле этого ядра присутствует следующая строка:
+
[.programlisting]
....
device	md
....
+
Для получения информации о построении кастомизированного ядра обратитесь к разделу <<kernelconfig>>.
+
. Сначала создайте соответствующий файл подкачки [.filename]#/usr/swap0#:
+
[source,shell]
....
# dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
....

. Затем задайте соответствующие полномочия на [.filename]#/usr/swap0#:
+
[source,shell]
....
# chmod 0600 /usr/swap0
....

. Включите файл подкачки в [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
....

. Перегрузите компьютер либо, в случае немедленной активации файла подкачки, введите:
+
[source,shell]
....
# mdconfig -a -t vnode -f /usr/swap0 -u 0  swapon /dev/md0
....

====

[[acpi-overview]]
== Управление энергопотреблением и ресурсами

Важно использовать аппаратные ресурсы эффективно.
До того, как появился ACPI (Advanced Configuration and Power Interface), задачи управления энергопотреблением и температурными характеристиками системы на уровне операционных систем решались сложно и негибко.
Аппаратное обеспечение управлялось при помощи BIOS, и пользователь имел меньше возможностей по просмотру настроек управления энергопотреблением и их контролю.
Некоторые ограниченные возможности конфигурирования были доступны средствами _APM (Advanced Power Management)_.
Управление энергопотреблением и ресурсами позволяет операционной системе выполнять мониторинг системных ограничений и, возможно, подавать предупреждающий сигнал при неожиданном росте температуры системы.

Этот раздел содержит исчерпывающую информацию об ACPI.
Будут даны ссылки для ознакомления с дополнительными материалами.

[[acpi-intro]]
=== Что такое ACPI?

ACPI является стандартом, написанный объединением производителей в целях предоставления стандартного интерфейса для аппаратных ресурсов и управления электропитанием.
Он является ключевым элементом концепции _Operating System-directed configuration and Power Management_, так как даёт операционной системе больше контроля и гибкости.
Современные системы вышли за пределы ограничений существующих Plug and Play интерфейсов до появления ACPI.
ACPI является прямым преемником APM.

[[acpi-old-spec]]
=== Недостатки Advanced Power Management (APM)

Подсистема APM управляет энергопотреблением системы в зависимости от её активности.
APM BIOS предоставляется производителем и специфичен для соответствующей аппаратной платформы.
Драйвер APM операционной системы выступает посредником при обращении к _APM Software Interface_, позволяющем управлять уровнями энергопотребления.
APM должен продолжать использоваться с системами, произведёнными в 2000 году и ранее.

В APM имеются четыре основных проблемы.
Во-первых, управление электропитанием осуществляется через специфичный для поставщика BIOS, отдельно от операционной системы.
К примеру, пользователь может установить значения продолжительности простоя для жёсткого диска в APM BIOS, и по его истечении этого времени BIOS останавливает жёсткий диск без координации с операционной системой.
Во-вторых, логика работы APM встроена в BIOS, которая работает вне границ операционной системы.
Это означает, что пользователи могут исправлять проблемы с APM BIOS только записью нового микрокода в ROM, что является опасной процедурой, при неудачном исполнении которой система может оказаться в невосстановимом состоянии.
В-третьих, технология APM специфична для поставщика, что означает дублирование усилий, так что ошибки, найденные в BIOS одного из поставщиков, не могут быть исправлены в других.
Наконец, APM BIOS недостаточно велик для реализации сложной политики управления электропитанием, или такой политики, которая может хорошо адаптироваться к целям использования конкретной машины.

_Plug and Play BIOS (PNPBIOS)_ во многих ситуациях был ненадёжен.
PNPBIOS является 16-разрядной технологией, поэтому операционной системе необходимо использовать эмуляцию 16-разрядного режима для взаимодействия с методами PNPBIOS.

Драйвер APM для FreeBSD документирован в man:apm[4].

[[acpi-config]]
=== Настройка ACPI

По умолчанию драйвер man:acpi.ko[4] загружается при помощи man:loader[8] при запуске системы, его _не_ нужно компилировать как часть ядра.
Дело в том, что с модулями проще работать, и они не требуют повторного построения ядра.
Такой подход имеет преимущество в упрощении тестирования.
Другая причина заключается в том, что запуск ACPI после запуска системы зачастую работает не очень хорошо.
При возникновении проблем ACPI может быть полностью отключён.
Этот драйвер не должен и не может быть выгружен, поскольку системная шина использует его для различных взаимодействий с оборудованием.
ACPI может быть отключён посредством перезапуска системы после установки `hint.acpi.0.disabled="1"` равным [.filename]#/boot/loader.conf# или при помощи установки этого значения в командной строке man:loader[8].

[NOTE]
====
ACPI и APM не могут сосуществовать и должны использоваться раздельно.
Каждый из них при загрузке прекратит свою работу, если обнаружит, что уже запущен другой.
====

ACPI может использоваться для перевода системы в спящий режим с помощью man:acpiconf[8] с флагом `-s` и параметром `1-5`.
Большинству пользователей требуется только `1` (быстрая приостановка работы с сохранением состояния в RAM) или `3` (приостановка работы с сохранением состояния в RAM).
Параметр `5` выполняет программное выключение, что означает те же действия, что и:

[source,shell]
....
# halt -p
....

Другие варианты доступны через man:sysctl[8].
За дополнительной информацией обратитесь к man:acpi[4] и man:acpiconf[8].

[[ACPI-debug]]
== Использование и отладка FreeBSD ACPI

ACPI это фундаментально новый способ обнаружения устройств, управления энергопотреблением и предоставления стандартизированного доступа к различному оборудованию, ранее управлявшемуся BIOS. Был достигнут определенный прогресс в приспособлении ACPI к работе со всеми системами, но все еще встречаются ошибки в байткоде _ACPI Machine Language_ (AML) некоторых материнских плат, незавершенные участки кода в подсистемах ядра FreeBSD и ошибки в интерпретаторе Intel(R) ACPI-CA.

Этот раздел предназначен для того, чтобы помочь пользователям в содействии разработчикам FreeBSD ACPI в определении первопричин проблем, а также в отладке и выработке решения.

[[ACPI-submitdebug]]
=== Отправка отладочной информации

[NOTE]
====
Перед отправкой сообщения о проблеме убедитесь, что установлена самая последняя версия BIOS, и, если доступна, последняя версия микрокода встроенного контроллера.
====

При отправке сообщения о проблеме направляйте в адрес link:mailto:freebsd-acpi@FreeBSD.org[freebsd-acpi@FreeBSD.org] следующую информацию:

* Описание некорректного поведения, включая тип системы, модель и всё, что приводит к появлению ошибки. Отметьте настолько точно, насколько это возможно, когда ошибка начала появляться, если она является новой.
* Вывод man:dmesg[8] после `boot -v`, включая все сообщения, появляющиеся из-за ошибки.
* Вывод man:dmesg[8] после "boot ``-v``" с выключенным ACPI, если его отключение помогает решить проблему.
* Вывод `sysctl hw.acpi`. В нём перечислены возможности соответствующей системы.
* URL, указывающий на соответствующую версию _ACPI Source Language_ (ASL). _Не_ отправляйте ASL непосредственно в список рассылки, поскольку он может быть очень большим. Сформируйте копию ASL запуском следующей команды:
+
[source,shell]
....
# acpidump -t -d  name-system.asl
....
+
Укажите вашу учётную запись вместо _name_ и производителя/модель вместо _system_. Например, используйте [.filename]#njl-FooCo6000.asl#.

Большинство разработчиков FreeBSD отслеживают {freebsd-current}, но для уверенности в том, что проблемы будут замечены, отправьте их в {freebsd-acpi}.
Будьте терпеливы при ожидании отклика.
Если ошибка не будет очевидна сразу, отправьте PR при помощи man:send-pr[1].
При вводе PR, включите ту же информацию, что запрошена выше.
Это поможет разработчикам отследить эту проблему и решить её.
Не отправляйте PR без предварительной отправки письма в {freebsd-acpi}, поскольку вероятно, что о проблеме сообщалось ранее.

[[ACPI-background]]
=== Общие сведения

ACPI представлен во всех современных компьютерах, соответствующих архитектурам ia32 (x86), ia64 (Itanium) и amd64 (AMD).
Полный стандарт включает множество возможностей, в том числе управление производительностью CPU, уровнем питания, температурой, различными системами аккумуляторов, встроенными контроллерами и опросом шины.
В большинстве систем стандарт реализован не полностью.
Например, в настольных системах обычно реализуется только опрос шины, тогда как в ноутбуках может иметься поддержка управления охлаждением и электропитанием.
В ноутбуках также имеются функции приостановки и возобновления работы со своими собственными сложностями.

ACPI-совместимые системы имеют разнообразные компоненты.
Производители BIOS и наборов микросхем поставляют различные жёстко заданные в памяти таблицы, подобные FADT, которые определяют такие вещи, как карта APIC (используется для SMP), конфигурационные регистры настройки и значения параметров простой настройки.
Кроме того, таблица байт-кода _Differentiated System Description Table_ DSDT определяет древоподобное пространство имён устройств и методов.

Драйвер ACPI должен прочесть заданные таблицы, реализовать интерпретатор для байткода, модифицировать драйвера устройств и ядро для приема информации от подсистемы ACPI.
Что касается FreeBSD, то Intel(R) предоставила интерпретатор (ACPI-CA), используемые также в Linux и NetBSD.
Исходный код ACPI-CA находится в каталоге [.filename]#src/sys/contrib/dev/acpica#.
Поддерживающий код, позволяющий ACPI-CA функционировать во FreeBSD, находится в каталоге [.filename]#src/sys/dev/acpica/Osd#.
Наконец, драйверы, реализующие различные устройства ACPI, находятся в [.filename]#src/sys/dev/acpica#.

[[ACPI-comprob]]
=== Часто встречающиеся проблемы

Для правильной работы ACPI все ее части должны работать правильно. Вот некоторые часто встречающиеся проблемы, в порядке частоты появления, и некоторые обходные пути или исправления.

==== Проблемы с мышью

В некоторых случаях возобновление работы после её приостановки приводит к неработоспособности мыши.
Известным решением проблемы является добавление строки `hint.psm.0.flags="0x3000"` в файл [.filename]#/boot/loader.conf#.
Если это не срабатывает, то рассмотрите возможность направить сообщение об ошибке при помощи man:send-pr[1].

==== Приостановка/возобновление работы

ACPI поддерживает три состояния приостановки с сохранением в RAM (STR), `S1`-`S3`, и одно состояние приостановки с сохранением на диск (`STD`), называемое `S4`.
`S5` это "мягкое выключение" и это нормальное состояние системы, когда она подключена к электропитанию, но не включена.
`S4` может быть реализовано двумя различными способами.
``S4``BIOS является приостановкой с сохранением на диск, поддерживаемой BIOS.
``S4``OS реализуется полностью операционной системой.

Начните с проверки переменных `sysctl hw.acpi`, относящихся к приостановке (suspend). Вот результат для Thinkpad:

[source,shell]
....
hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0
....

Используйте `acpiconf -s` для проверки `S3`, ``S4``OS, и `S5`.
Значение `s4bios`, равное единице (`1`), указывает на поддержку ``S4``BIOS, а не ``S4``OS.

При тестировании приостановки/возобновления работы начните с `S1`, если этот режим поддерживается.
Это состояние, скорее всего, поддерживается, поскольку не требует слишком серьёзной поддержки со стороны драйвера.
Никто не реализовал `S2`, который похож на `S1`.
Затем попробуйте `S3`.
Это наиболее глубокое состояние режима STR, и оно требует существенной поддержки со стороны драйвера для корректной повторной инициализации аппаратного обеспечения.
Если при возобновлении работы возникли проблемы, отправьте сообщение электронной почты в адрес {freebsd-acpi}.
Однако быстро проблема может не быть решена, поскольку существует множество драйверов и оборудования, нуждающихся в дополнительном тестировании и работе над ними.

Распространённой проблемой с приостановкой/возобновлением работы является то, что многие драйверы устройств не сохраняют, не восстанавливают и не инициализируют повторно их микропрограммное обеспечение, регистры или память устройств.
В качестве первой попытки отладки проблемы, попробуйте:

[source,shell]
....
# sysctl debug.bootverbose=1
# sysctl debug.acpi.suspend_bounce=1
# acpiconf -s 3
....

Этот тест воспроизводит цикл приостановки/возобновления всех драйверов устройств без фактического перехода в состояние `S3`.
В некоторых случаях таким способом могут быть выявлены такие проблемы, как потеря состояния микропрограммного обеспечения, таймаут таймера устройства и бесконечный цикл повторных попыток.
Заметьте, что система фактически не будет переходить в состояние `S3`, а это значит то, что устройства могут не терять питание полностью, и многие будут нормально работать даже если методы приостановки/возобновления отсутствуют вовсе, в отличие от реального состояния `S3`.

Более сложные случаи требуют дополнительного оборудования, такого, как последовательный порт и кабель для отладки через последовательную консоль, порт Firewire и кабель для использования man:dcons[4], а также навыков отладки ядра.

Для того, чтобы помочь изолировать проблему, удалите из ядра столько драйверов, сколько возможно.
Если это работает, сузьте поиск драйвера, являющегося проблемным, путём загрузки драйверов до тех пор, пока снова не произойдёт сбой.
Обычно бинарные драйверы, такие как [.filename]#nvidia.ko#, драйвера дисплеев и USB вызывают большинство проблем, тогда как драйверы интерфейсов Ethernet, как правило, работают нормально.
Если драйверы могут быть нормально загружены и выгружены, автоматизируйте это, поместив соответствующие команды в [.filename]#/etc/rc.suspend# и [.filename]#/etc/rc.resume#.
Имеются заключённый в комментарии пример выгрузки и загрузки драйвера.
Попробуйте задать значение параметра `hw.acpi.reset_video` равным нулю (`0`), если дисплей не включается после возобновления работы.
Попробуйте установить более высокие или низкие значения для `hw.acpi.sleep_delay`, чтобы проверить, помогает ли это.

Попробуйте загрузить один из недавних дистрибутивов Linux(R) для того, чтобы проверить работоспособность остановки/возобновления работы на том же оборудовании.
Если она работает на Linux(R), то, вероятно, проблема заключается в драйвере FreeBSD.
Сужение поиска драйвера, вызывающего проблему, поможет разработчикам в её исправлении.
Так как те, кто поддерживают ACPI, редко поддерживают другие драйверы, такие как звук или ATA, сообщения о любых проблемах с драйвером должны быть также направлены в список рассылки {freebsd-current} и человеку, поддерживающему соответствующий драйвер.
Опытные пользователи могут добавить отладочные man:printf[3] в проблемный драйвер для отслеживания момента, в который останавливается функция возобновления работы.

Наконец, попробуйте отключить ACPI и включить вместо него APM.
Если приостановка/возобновление работает с APM, оставайтесь с APM, особенно на более старом оборудовании (до 2000).
Обеспечение корректной поддержки ACPI поставщиками оборудования требует времени, и более вероятно, что старое оборудование имеет проблемы с поддержкой ACPI в BIOS.

==== Система зависает

Большинство зависаний систем являются результатом потери прерываний или штормоподобного потока прерываний.
Наборы микросхем могут иметь проблемы, связанные с загрузкой, с тем, как BIOS настраивает прерывания перед загрузкой, правильностью таблицы APIC (MADT), и маршрутизацией _System Control Interrupt_ (SCI).

Шторм прерываний можно отличить от потери прерываний путём анализа результата выполнения команды `vmstat -i` и поиска строки с `acpi0` в нём.
Если счётчик увеличивается более чем несколько раз в секунду, то это является штормом прерываний.
Если система останавливается, попробуйте войти в DDB (kbd:[CTRL+ALT+ESC] на консоли) и ввести `show interrupts`.

При работе с проблемами с прерываниями попробуйте отключить поддержку APIC с помощью параметра `hint.apic.0.disabled="1"` в [.filename]#/boot/loader.conf#.

==== Аварийное завершение работы

Аварийные завершения работы ядра, связанные с ACPI, относительно редки и имеют высший приоритет для исправлений.
Первым шагом является вычленение действий, приводящих к аварийному завершению работы, если это возможно, и получение обратной трассировки вызовов.
Следуйте инструкции по включению `options DDB` и настройке последовательной консоли в разделе crossref:serialcomms[serialconsole-ddb,Вход в отладчик DDB с последовательной линии] или настройке раздела man:dump[8].
Для того, чтобы получить обратную трассировку вызовов в DDB, используйте `tr`.
При ручной записи обратной трассировки зафиксируйте по крайней мере пять строк в самом низу и пять строк в самом верху трассировки.

Затем попробуйте изолировать проблему, загрузившись с выключенным ACPI.
Если это срабатывает, изолируйте подсистему ACPI, используя различные значения `debug.acpi.disable`.
Обратитесь к man:acpi[4] для получения нескольких примеров.

==== Система включается после приостановки или завершения работы

Во-первых, попробуйте установить в man:loader.conf[5] параметр `hw.acpi.disable_on_poweroff="0"`. Это предотвращает отключение различных событий в ACPI во время завершения работы. В некоторых системах этот параметр необходимо установить в `1` (по умолчанию) по тем же причинам. Обычно это решает проблему, если система неожиданно включается после приостановки или отключения питания.

==== Другие проблемы

При возникновении других проблем с ACPI, таких как отсутствие работы с док-станцией или отсутствие обнаружения устройств, отправьте описание проблемы по адресу {freebsd-acpi}.
Некоторые из этих проблем могут быть связаны с незавершёнными частями подсистемы ACPI, на реализацию котороых может потребоваться какое-то время.
Будьте терпеливыми, и подготовьтесь к тестированию исправлений.

[[ACPI-aslanddump]]
=== ASL, man:acpidump[8] и IASL

Некоторые разработчики BIOS поставляют некорректный или ошибочный байт-код.
Это обычно проявляется появлением консольных сообщений ядра, подобных следующему:

[source,shell]
....
ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
       (Node 0xc3f6d160), AE_NOT_FOUND
....

Зачастую эти проблемы могут быть решены обновлением BIOS до последней ревизии.
Большинство консольных сообщений безобидны, но если существуют другие проблемы, такие как неработающее отслеживание состояния батареи, то эти сообщения являются хорошей отправной точкой для поиска проблем.
Байт-код, известный как AML, компилируется из исходного текста на языке, называемом ASL.
AML находится в таблице, известной как DSDT.
Для получения копии ASL системы используйте man:acpidump[8].
Используйте оба параметра, а именно `-t`, показывающий содержимое постоянных таблиц, и `-d`, дизассемблирующий AML.
Обратитесь к разделу <<ACPI-submitdebug,Отправка отладочной информации>> за примером синтаксиса.

Первой простейшей проверкой является перекомпиляция ASL для поиска ошибок.
Предупреждения обычно могут быть проигнорированы, но они являются ошибками, обычно не позволяющим ACPI работать корректно.
Для перекомпиляции ASL выполните следующую команду:

[source,shell]
....
# iasl your.asl
....

[[ACPI-fixasl]]
=== Исправление ASL

Цель FreeBSD состоит в том, чтобы у всех ACPI работал без какого-либо вмешательства пользователя.
На данный момент всё ещё разрабатываются обходные пути для решения распространённых ошибок поставщиков BIOS.
Интерпретатор Microsoft(R) ([.filename]#acpi.sys# и [.filename]#acpiec.sys#) не занимается проверкой четкости соблюдения стандартов, поэтому многие поставщики BIOS, проверяющие ACPI только под Windows(R), никогда не исправляют ASL.
Разработчики FreeBSD продолжают идентифицировать и документировать нестандартное поведение, которое разрешается интерпретатором Microsoft(R), и воспроизводить его, чтобы FreeBSD могла работать без необходимости исправления ASL пользователями.
В качестве обходного пути и в качестве помощи в идентификации поведения, исправляйте ASL вручную.
Если это срабатывает, отправьте файл man:diff[1] разницы между старым и новым ASL, чтобы разработчики, возможно, смогли реализовать обходной путь для ошибочного поведения в ACPI-CA.

Вот список наиболее часто встречающихся проблем, их причин и способы исправления:

==== Зависимости от операционной системы

Некоторые версии AML предполагают, что пользователь работает с Windows(R).
Для корректировки этого установите значение `hw.acpi.osname="Windows 2001"` в [.filename]#/boot/loader.conf#, используя строки из соответствующего ASL.

==== Отсутствующие команды возврата

Некоторые методы не возвращают значение явным образом, как того требует стандарт.
Хотя ACPI-CA не обрабатывает эту ситуацию, в FreeBSD существует обходной путь, позволяющей ей явно возвращать значение.
Если известно значение, которое должно быть возвращено, то там, где требуется, директивы возвращения значения могут быть добавлены явным образом.
Для принудительной компиляции ASL командой man:iasl[8] используйте флаговый парааметр `-f`.

==== Перезапись AML по умолчанию

После внесения изменений в [.filename]#your.asl# скомпилируйте его этой командой:

[source,shell]
....
# iasl your.asl
....

Добавление флага `-f` приводит к принудительному созданию AML даже при наличии ошибок во время компиляции.
Некоторые ошибки, такие как отсутствие директив возвращения, автоматически обходятся интерпретатором.

Именем файла, по умолчанию используемым man:iasl[8] для вывода, является [.filename]#DSDT.aml#.
Загрузите этот файл вместо копии BIOS с ошибками, которая всё ещё присутствует во флэш-памяти, отредактировав [.filename]#/boot/loader.conf# следующим образом:

[.programlisting]
....
acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"
....

Убедитесь, что скопировали [.filename]#DSDT.aml# в каталог [.filename]#/boot#.

[[ACPI-debugoutput]]
=== Получение отладочной информации от ACPI

Драйвер ACPI обладает гибкими средствами отладки.
Могут быть указаны набор подсистем и уровень детализации.
Подсистемы для отладки указываются как "слои" и разделяется на компоненты ACPI-CA (ACPI_ALL_COMPONENTS) и поддержку оборудования ACPI (ACPI_ALL_DRIVERS).
Уровень детализации диагностических сообщений указывается как "level" и варьируется от ACPI_LV_ERROR (сообщать только об ошибках) до ACPI_LV_VERBOSE (всё).
Уровень отладки представляет собой битовую маску, поэтому возможна одновременная установка нескольких параметров, разделенных пробелами.
На практике для протоколирования выдаваемой информации следует использовать последовательную консоль, чтобы не происходило потерь при очистке буфера консольных сообщений.
Полный список отдельных слоёв и уровней находится в man:acpi[4].

Вывод отладочной информации по умолчанию не активирован.
Для его включения добавьте параметр `options ACPI_DEBUG` к соответствующему файлу конфигурации ядра, если ACPI встраивается в ядро.
Добавьте `ACPI_DEBUG=1` в [.filename]#/etc/make.conf# для его глобальной активации.
Если это модуль, перекомпилируйте только [.filename]#acpi.ko# следующим образом:

[source,shell]
....
# cd /sys/modules/acpi/acpi
 make clean  make
ACPI_DEBUG=1
....

Установите [.filename]#acpi.ko# в [.filename]#/boot/kernel# и добавьте соответствующие предпочитаемые уровень и слой в [.filename]#/boot/loader.conf#.
Этот пример активирует диагностические сообщения для всех компонентов ACPI-CA и всех драйверов оборудования ACPI, такого как CPU и LID.
Он выводит только сообщения об ошибках с наименьшим уровнем детализации.

[.programlisting]
....
debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"
....

Если требуемая информация формируется в результате определённого события, например, приостановки с последующим возобновлением работы, не вносите изменения в [.filename]#/boot/loader.conf#, но вместо этого используйте man:sysctl[8] для указания слоя и уровня `sysctl` после загрузки и подготовки системы к определённому событию.
Переменные, которые могут быть заданы при помощи man:sysctl[8], имеют те же имена, что и настроечные параметры в [.filename]#/boot/loader.conf#.

[[ACPI-References]]
=== Ссылки

Дальнейшую информацию о ACPI можно найти по следующим ссылкам:

* {freebsd-acpi}
* Архивы списка рассылки ACPI http://lists.freebsd.org/pipermail/freebsd-acpi/[http://lists.freebsd.org/pipermail/freebsd-acpi/]
* Старые архивы списка рассылки ACPI http://home.jp.FreeBSD.org/mail-list/acpi-jp/[http://home.jp.FreeBSD.org/mail-list/acpi-jp/]
* https://uefi.org/specifications#ACPI[Спецификация ACPI]
* man:acpi[4], man:acpi_thermal[4], man:acpidump[8], man:iasl[8] и man:acpidb[8]
* http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt[Ресурс об отладке DSDT].
