//
// The FreeBSD Russian Documentation Project
//
// Original RU revision (18.02.2025): 54ac237fdb34d9074316cd8f8a77832bd618e4f6
//
// Original EN revision (SVN): 41015
//

---
title: Глава 12. Настройка и оптимизация
part: Часть III. Системное администрирование
prev: books/handbook/partiii
next: books/handbook/boot
showBookMenu: true
weight: 16
params:
  path: "/books/handbook/config/"
---

[[config-tuning]]
= Настройка и оптимизация
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 12
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/config/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[config-synopsis]]
== Введение

Одним из важных аспектов FreeBSD является корректная настройка системы.
Эта глава описывает значительную часть процесса конфигурирования FreeBSD, в том числе некоторые параметры, которые можно задавать для тонкой настройки системы FreeBSD.

После прочтения этой главы вы будет знать:

* Как эффективно работать с файловыми системами и разделами подкачки.
* Основы настройки [.filename]#rc.conf# и скрипты запуска [.filename]#/usr/local/etc/rc.d#.
* Как настроить и протестировать сетевую карту.
* Как настроить виртуальные хосты на сетевых устройствах.
* Как использовать различные файлы конфигурации в [.filename]#/etc#.
* Как оптимизировать FreeBSD, используя переменные `sysctl`.
* Как увеличить скорость работы дисков и изменить ограничения, накладываемые ядром.

Перед прочтением этой главы вам следует:

* Понять основы UNIX(R) и FreeBSD (crossref:basics[basics, Основы FreeBSD]).
* Ознакомиться с основами конфигурирования и компиляции ядра (crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]).

[[configtuning-initial]]
== Начальное конфигурирование

=== Разделы диска

==== Основы построения разделов

Во время разметки жёсткого диска с помощью man:bsdlabel[8] или man:sysinstall[8] важно помнить, что скорость чтения и записи данных уменьшается от внешних к внутренним трекам диска.
Таким образом, файловые системы меньшего размера и часто используемые должны быть ближе к внешнему краю диска, а более крупные, такие как [.filename]#/usr#, должны размещаться ближе к внутренним частям диска.
Хорошей идеей является создание разделов в порядке, подобном следующему: root, swap, [.filename]#/var#, [.filename]#/usr#.

Размер раздела [.filename]#/var# отражает предполагаемое использование машины.
Этот раздел [.filename]#/var# используется для хранения почтовых ящиков, файлов журналов событий и очередей печати.
Поочтовые ящики и файлы журналов могут вырастать до неожидаемых размеров в зависимости от количества существующих пользователей и продолжительности хранения файлов журналов.
Большинству пользователей редко требуется более примерно гигабайта свободного дискового пространства в [.filename]#/var#.

[NOTE]
====
Есть несколько случаев, когда в [.filename]#/var/tmp# требуется много дискового пространства.
Когда при помощи man:pkg.add[1] устанавливается новое программное обеспечение, инструменты работы с пакетами разворачивают временную копию пакетов в [.filename]#/var/tmp#.
Если в [.filename]#/var/tmp# нет достаточного объёма дискового пространства, установка крупных пакетов программного обеспечения, подобных Firefox, OpenOffice или LibreOffice, может быть затруднена.
====

Раздел [.filename]#/usr# содержит многие их тех файлов, что поддерживают систему, в том числе Коллекцию Портов и исходный код системы.
Для этого раздела рекомендуется не менее 2 гигабайт.

При выборе объёмов разделов, не забудьте принять во внимание рост размера требуемого системе дискового пространства. Переполнение одного раздела даже при наличии свободного места на другом может вызвать затруднения.

[NOTE]
====
Многие пользователи обнаружили, что размер разделов, предлагаемый man:sysinstall[8]'ом по умолчанию, иногда меньше подходящего для разделов [.filename]#/var# и [.filename]#/#. Тщательно планируйте размер разделов и не жалейте места.
====

[[swap-design]]
==== Раздел подкачки

Как правило, размер раздела подкачки должен быть равен примерно удвоенному размеру физической памяти (ОЗУ), так как алгоритмы работы с выгружаемыми страницами виртуальной памяти (VM) ядра оптимизированы для достижения наилучших показателей, когда раздел памяти подкачки по крайней мере в два раза больше размера основной памяти.
Системы с минимальным ОЗУ работают лучше, когда памяти подкачки ещё больше.
Конфигурирование слишком малого объёма памяти подкачки может привести к неэффективной работе функции сканирования страниц VM и позже вызвать проблемы при добавлении памяти.

На более крупных системах с несколькими дисками SCSI или несколькими дисками IDE, работающими на разных контроллерах, рекомендуется создавать раздел подкачки на каждом диске (вплоть до четырёх дисков).
Разделы подкачки должны быть примерно одного размера. Ядро не накладывает ограничений на размер раздела подкачки, но внутренние структуры позволяют иметь общий размер разделов подкачки, равный наибольшему, умноженному на четыре. Выделение под разделы подкачки примерно одинакового места позволить ядру оптимально расположить разделы подкачки. Установка размера подкачки больше требуемого нормальна, даже если этот объем не используется. В этих условиях может быть проще восстановиться после зависания программы перед тем, как возникнет необходимость перезагрузки.

==== Зачем нужны разделы?

Некоторые пользователи считают, что лучше использовать один большой раздел, но есть несколько причин, по которым этого лучше не делать. Во-первых, у каждого раздела свои характеристики, и отделяя их, можно выполнить соответствующие настройки.
Например, корневая файловая система и [.filename]#/usr# в основном предназначены для чтения, с небольшим объёмом операций записи, тогда как много операций чтения и записи могут осуществляться в [.filename]#/var# и [.filename]#/var/tmp#.

При правильном размещении и выборе размера разделов системы, фрагментация в более маленьких разделах, куда часто записываются данные, не перенесётся на остальные разделы. Размещение самых часто используемых разделов ближе к началу диска увеличит скорость ввода/вывода там, где она нужна больше всего. Хотя производительность важна и для больших дисков, передвижение их ближе к концу диска не повлечёт значительного уменьшения быстродействия по сравнению с перемещением ближе к концу диска [.filename]#/var#. И, наконец, разделы существуют и из соображений безопасности. Наличие маленького аккуратного корневого раздела, доступного только для чтения даёт значительные шансы на "выживание" после краха системы.

[[configtuning-core-configuration]]
== Основные настройки

Основным местом размещения информации о конфигурации системы является [.filename]#/etc/rc.conf#.
Этот файл содержит широкий спектр конфигурационной информации, и он считывается при запуске системы для её настройки.
Он даёт конфигурационную информацию для файлов [.filename]#rc*#.

Записи в [.filename]#rc.conf# переопределяют значения настроек, используемых по умолчанию, из [.filename]#/etc/defaults/rc.conf#.
Этот файл, содержащий стандартные настройки, не должен редактироваться.
Вместо этого все специфичные для данной системы изменения должны производиться в [.filename]#/etc/rc.conf#.

Для кластеризованных приложений существует несколько стратегий отделения общих настроек для всех систем от настроек конкретной системы в целях уменьшения дополнительных работ администратора.
Рекомендуемым методом является помещение настроек конкретной системы в файл [.filename]#/etc/rc.conf.local#.
Например:

* [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
sshd_enable="YES"
keyrate="fast"
defaultrouter="10.1.1.254"
....
+
* [.filename]#/etc/rc.conf.local#:
+
[.programlisting]
....
hostname="node1.example.org"
ifconfig_fxp0="inet 10.1.1.1/8"
....

Затем файл [.filename]#rc.conf# может быть распространён на все системы при помощи `rsync` или похожей программы, в то время как [.filename]#rc.conf.local# остаётся уникальным.

Модернизация системы с помощью man:sysinstall[8] или `make world` не повлекут за собой перезаписи [.filename]#rc.conf#.
Вся информация в этом файле сохранится.

[TIP]
====
Конфигурационный файл [.filename]#/etc/rc.conf# обрабатывается при помощи man:sh[1].
Это позволяет системным операторам добавлять определённую логику в этот файл, что может помочь в создании очень сложных конфигурационных сценариев.
Обратитесь к man:rc.conf[5] для получения дополнительной информации по этой теме.
====

[[configtuning-appconfig]]
== Настройка приложений

Как правило, установленные приложения имеют собственные конфигурационные файлы и синтаксис.
Важно, чтобы эти файлы хранились отдельно от базовой системы, чтобы их можно было легко находить и администрировать с помощью средств управления пакетами.

Обычно эти файлы устанавливаются в [.filename]#/usr/local/etc#. В случае, если приложению нужно большое количество конфигурационных файлов, для их хранения будет создан подкаталог.

Обычно, вместе с установкой портов и пакетов, устанавливаются и примеры конфигурационных файлов. Обычно они имеют расширение [.filename]#.default#. Если не существует конфигурационных файлов для этого приложения, они будут созданы путём копирования [.filename]#.default# файлов.

Например, [.filename]#/usr/local/etc/apache#:

....
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default
....

Размеры файлов показывают, что только файл [.filename]#srm.conf# был изменён. При следующем обновлении Apache этот файл уже не будет перезаписан.

[[configtuning-starting-services]]
== Запуск сервисов

Многие пользователи устанавливают программы сторонних производителей во FreeBSD из Коллекции Портов, и им требуется, чтобы установленные сервисы запускались при инициализации системы.
Сервисы, подобные package:mail/postfix[] или package:www/apache22[], являются лишь двумя примерами из множества программных пакетов, которые можно запускать при инициализации системы.
В этом разделе описывается процедура, предназначенная для запуска программ сторонних разработчиков.

Во FreeBSD большинство включённых в поставку сервисов, таких как man:cron[8], запускаются с помощью стартовых скриптов системы.

=== Расширенное конфигурирование приложений

Теперь, когда FreeBSD включает [.filename]#rc.d#, настройка запуска приложений является более простой и даёт больше возможностей.
С помощью ключевых слов, рассмотренных в разделе <<configtuning-rcd,rc.d>>, приложения могут быть настроены на запуск после других определённых сервисов, а дополнительные параметры могут быть переданы через [.filename]#/etc/rc.conf# вместо их жёсткого указания в стартовом скрипте.
Базовый скрипт может иметь вид, подобный следующему:

[.programlisting]
....
#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command="/usr/local/sbin/utility"

load_rc_config $name

#
# НЕ МЕНЯЙТЕ ЗДЕСЬ ЭТИ СТАНДАРТНЫЕ ЗНАЧЕНИЯ
# ЗАДАВАЙТЕ ИХ В ФАЙЛЕ /etc/rc.conf
#
utility_enable=${utility_enable-"NO"}
pidfile=${utility_pidfile-"/var/run/utility.pid"}

run_rc_command "$1"
....

Этот скрипт будет обеспечить то, что указанное приложение utility будет запущено после псевдо-сервиса `DAEMON`.
Он также предоставляет инструмент для создания и отслеживания файла идентификатора процесса, PID.

Для этого приложения затем можно поместить следующую строку в файл [.filename]#/etc/rc.conf#:

[.programlisting]
....
utility_enable="YES"
....

Этот метод также позволяет легко работать с аргументами командной строки, включать стандартные функции из файла [.filename]#/etc/rc.subr#, обеспечивает совместимость с утилитой man:rcorder[8] и упрощает конфигурирование с помощью файла [.filename]#rc.conf#.

=== Использование сервисов для запуска сервисов

Другие сервисы, такие как даемоны серверов POP3 или IMAP, могут быть запущены с помощью man:inetd[8].
Для этого необходимо установить сервисную утилиту из набора портов и добавить соответствующую строчку конфигурации в файл [.filename]#/etc/inetd.conf# или раскомментировать подходящую строку конфигурации из уже имеющихся.
Работа с даемоном inetd и его конфигурирование подробно описаны в разделе crossref:network-servers[network-inetd,inetd].

В некоторых случаях может быть более разумным использование для запуска системных служб даемона man:cron[8].
Такой подход имеет несколько преимуществ, поскольку даемон `cron` запускает эти процессы от имени владельца файла [.filename]#crontab#. Это позволяет обычным пользователям запускать и поддерживать некоторые приложения.

Утилита `cron` поддерживает уникальную возможность, `@reboot`, - это значение можно использовать вместо спецификации времени. В результате, задание будет выполнено при запуске man:cron[8], обычно - в ходе инициализации системы.

[[configtuning-cron]]
== Настройка утилиты `cron`

Одной из наиболее полезных утилит во FreeBSD является man:cron[8].
Эта утилита работает в фоновом режиме и регулярно проверяет файл [.filename]#/etc/crontab# на предмет наличия задач к выполнению, а также каталог [.filename]#/var/cron/tabs# в поиске пользовательских файлов [.filename]#crontab#.
Указанные файлы хранят информацию о конкретных функциях, которые, как предполагается, `cron` выполнит в определённое время.

Утилита `cron` использует два разных вида конфигурационных файлов, системный и пользовательский.
Эти форматы отличаются только в шестом и последующем полях.
В случае системного файла `cron` будет запускать команду с полномочиями пользователя, указанного в шестом поле.
В случае пользовательского файла все команды запускаются с полномочиями пользователя, создавшего файл, так что шестое поле является последним; это важная особенность с точки зрения безопасности.
Последним полем всегда является запускаемая команда.

[NOTE]
====
Пользовательские crontab позволяют индивидуальным пользователям планировать задачи без привилегий суперпользователя (`root`). Команды из crontab пользователя запускаются с привилегиями этого пользователя.

Пользователь `root` может иметь собственный crontab, как и любой другой пользователь.
Файл пользователя `root` существует отдельно от [.filename]#/etc/crontab# (системного файла crontab).
Поскольку системный crontab фактически запускает указанные команды как root, то обычно создавать пользовательский crontab для `root` не требуется.
====

Давайте заглянем в [.filename]#/etc/crontab#, который является файлом crontab для системы:

[.programlisting]
....
# /etc/crontab - root's crontab for FreeBSD
#
# $FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp $
## <.>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <.>
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <.>
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <.>
....

<.> Как и в большинстве конфигурационных файлов FreeBSD, строки, начинающиеся с символа `#`, являются комментариями.  Комментарии нужны для напоминания о том, что означает строка и зачем она добавлена. Комментарии не могут находиться на той же строке, что и команда, или они будут восприняты как часть команды; располагайте их на новой строке. Пустые строки игнорируются.

<.> Сначала должны быть заданы переменные окружения. Знак равно (`=`) используется для задания переменных окружения, в этом примере `SHELL`, `PATH`, и `HOME`. Если переменная для оболочки не задана, `cron` использует оболочку по умолчанию, `sh`. Если не задана переменная `PATH`, значение по умолчанию не устанавливается и пути к файлам должны быть полными. Если не задана переменная `HOME`, `cron` будет использовать домашний каталог соответствующего пользователя.

<.> В строке всего семь полей. Их значения `minute`, `hour`, `mday`, `month`, `wday`, `who` (кто), и `command`. Значение полей почти очевидно. `minute` это время в минутах, когда будет запущена команда. `hour` означает то же самое для часов. `mday` означает день месяца. `month`, это то же самое, что час и минута, но для месяцев. Параметр `wday` это день недели. Все эти поля должны быть в числовом формате, время в двадцатичетырехчасовом исчислении. Поле `who` имеет специальное значение и присутствует только в [.filename]#/etc/crontab#.  Это поле задаёт пользователя, с полномочиями которого должна быть запущена команда.  Последнее поле является командой, которая должна быть исполнена.

<.> Последняя строка будет определять параметры, описанные выше. В этом примере задано значение `*/5`, за которым следуют ещё несколько символов `*`.  Эти символы `*` означают "первый-последний", и могут быть интерпретированы как _каждый_ раз.  В этом примере `atrun` вызывается с полномочиями пользователя `root` каждые пять минут независимо от дня или месяца.  За дополнительной информацией по команде `atrun` обратитесь к man:atrun[8].

Команды могут иметь любое количество флаговых параметров, передаваемых им; однако команды, состоящие из нескольких строк, должны быть объединены символом "\".

Такова базовая конфигурация каждого файла [.filename]#crontab#, однако имеется один нюанс.
Шестое поле, задающее имя пользователя, присутствует только в системном файле [.filename]#crontab#.
Это поле должно быть исключено из пользовательских файлов [.filename]#crontab#.

[[configtuning-installcrontab]]
=== Установка crontab

[IMPORTANT]
====
Не используйте процедуру, описанную здесь, для редактирования и установки системного файла crontab, [.filename]#/etc/crontab#.
Вместо этого используйте какой-либо текстовый редактор: `cron` заметит, что файл изменился, и сразу начнёт использовать обновлённую версию.
Обратитесь к extref:{faq}[этому разделу FAQ, root-not-found-cron-errors] для получения дополнительной информации.
====

Для установки нового пользовательского файла [.filename]#crontab# сначала создайте в каком-нибудь текстовом редакторе и сохраните файл соответствующего формата.
Затем сообщите имя этого файла утилите `crontab`:

[source,shell]
....
% crontab crontab-file
....

В этом примере, [.filename]#crontab-file# это имя файла crontab, который только что был создан.

Для выдачи списка установленных файлов [.filename]#crontab# запустите `crontab` с параметром `-l`.

Для пользователей, составляющих crontab вручную, без временного файла, существует параметр `crontab -e`.
При этом будет вызван выбранный текстовый редактор с пустым файлом.
Когда файл будет сохранён, `crontab` автоматически установит его.

Для того, чтобы полностью удалить пользовательский файл [.filename]#crontab#, используйте команду `crontab -r`.

[[configtuning-rcd]]
== Использование man:rc[8] во FreeBSD

В 2002 году во FreeBSD была интегрирована из NetBSD система [.filename]#rc.d#, используемая для старта системы. Многие из файлов в каталоге [.filename]#/etc/rc.d# предназначены для основных сервисов, они могут управляться параметрами `start`, `stop`, и `restart`.
Например, man:sshd[8] может быть перезапущен следующей командой:

[source,shell]
....
# service sshd restart
....

Эта процедура похожа для других сервисов. Конечно, сервисы обычно запускаются автоматически при загрузке системы, как указано в man:rc.conf[5]. Например, включение даемона Network Address Translation при запуске выполняется простым добавлением следующей строки в [.filename]#/etc/rc.conf#:

[.programlisting]
....
natd_enable="YES"
....

Если `natd_enable="NO"` уже присутствует, просто измените `NO` на `YES`. Скрипты rc автоматически загрузят все другие зависимые сервисы, как описано ниже.

Поскольку система [.filename]#rc.d# в основном предназначена для запуска/отключения сервисов во время запуска/отключения системы, стандартные параметры `start`, `stop` и `restart` будут выполнять соответствующие действия, только если заданы соответствующие переменные в [.filename]#/etc/rc.conf#.
Например, `sshd restart` будет работать, только если переменная `sshd_enable` в файле [.filename]#/etc/rc.conf# установлена в значение `YES`.
Для выполнения скриптов независимо от установок в [.filename]#/etc/rc.conf#, параметры `start`, `stop` или `restart` необходимо задавать с префиксом "one".
Например, для перезапуска `sshd` независимо от параметров в [.filename]#/etc/rc.conf# выполните следующую команду:

[source,shell]
....
# service sshd onerestart
....

Проверить состояние переменной в файле [.filename]#/etc/rc.conf# легко: запустите соответствующий скрипт из [.filename]#rc.d# с параметром `rcvar`. Проверка переменной для `sshd` выполняется следующей командой:

[source,shell]
....
# service sshd rcvar
# sshd
$sshd_enable=YES
....

[NOTE]
====
Вторая строка (`# sshd`) это вывод команды `sshd`, а не консоль `root`.
====

Для выяснения того, работает ли сервис или нет, используйте параметр `status`.
Например, для проверки работы `sshd` выполните:

[source,shell]
....
# service sshd status
sshd is running as pid 433.
....

В некоторых случаях возможна также перегрузка (`reload`) сервиса. Скрипт, запущенный с этим параметром, попытается отправить сервису сигнал, вызывающий перезагрузку файлов настройки. В большинстве случаев это означает отправку сервису сигнала `SIGHUP`. Следует помнить, что эту функцию поддерживают не все сервисы.

Система [.filename]#rc.d# используется не только для сетевых сервисов, она вносит свой вклад в существенную часть инициализации системы.
К примеру, при исполнении скрипта [.filename]#bgfsck# он будет выводить следующее сообщение:

[source,shell]
....
Starting background file system checks in 60 seconds.
....

Следовательно, этот файл используется для фоновой проверки файловых систем, которая выполняется только в процессе инициализации системы.

Функционирование многих сервисов системы зависит от корректной работы других сервисов. Например, NIS и другие основанные на RPC сервисы могут не запуститься, пока не загрузится `rpcbind` (portmapper). Для разрешения этой проблемы, в начале каждого скрипта в комментарии включаются информация о зависимостях и другие метаданные.
Затем во время запуска системы используется программа man:rcorder[8] для обработки этих комментариев и определения порядка, в котором должны вызываться системные сервисы в соответствии со взаимными зависимостями.

Во все стартовые скрипты должны быть включены следующие слова (их требует man:rc.subr[8] для "включения" стартовых скриптов):

* `PROVIDE`: Задаёт сервисы, предоставляемые этим файлом.

Следующие слова могут быть включены в начало каждого стартового файла.
Они не являются строго обязательными, однако полезны в качестве подсказок для man:rcorder[8]:

* `REQUIRE`: Перечисляет сервисы, необходимые этому сервису. Этот файл будет запущен _после_ указанных сервисов.
* `BEFORE`: Перечисляет сервисы, зависящие от этого сервиса. Этот файл будет запущен _до_ указанных сервисов.

При помощи аккуратного указания этих ключевых слов для каждого стартового скрипта администратор получает очень детализированный уровень контроля над порядком запуска стартовых скриптов без использования "уровней запуска", как в некоторых других операционных системах UNIX(R).

Дополнительную информацию о системе [.filename]#rc.d# можно найти в man:rc[8] и man:rc.subr[8].
Обратитесь к extref:{rc-scripting}[этой статье] для получения указаний о том, как создавать собственные скрипты [.filename]#rc.d#.

[[config-network-setup]]
== Настройка адаптеров сетевых интерфейсов

Добавление и настройка сетевого адаптера являются обычными задачами любого администратора FreeBSD.

=== Поиск подходящего драйвера

В первую очередь определите модель адаптера сетевого интерфейса и используемую в нём микросхему.
FreeBSD поддерживает широкий спектр адаптеров сетевого интерфейса.
Обратитесь к Списку поддерживаемого оборудования соответствующего релиза FreeBSD, чтобы узнать, поддерживается ли адаптер.

Если адаптер поддерживается, определите название драйвера FreeBSD для него.
Обратитесь к [.filename]#/usr/src/sys/conf/NOTES# и [.filename]#/usr/src/sys/arch/conf/NOTES# для получения списка драйверов сетевых интерфейсов с определённой информацией о поддерживаемых наборах микросхем.
При наличии сомнений прочтите справочную страницу этого драйвера, так как она даст дополнительную информацию о поддерживаемом оборудовании и известных ограничениях этого драйвера.

Драйверы для распространённых сетевых адаптеров уже представлены в ядре [.filename]#GENERIC#, так что ваша карта должна отображаться при загрузке, как в этом примере:

[source,shell]
....
dc0: <82c169 PNIC 10/100BaseTX> port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: <MII bus> on dc0
bmtphy0: <BCM5201 10/100baseTX PHY> PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: [ITHREAD]
dc1: <82c169 PNIC 10/100BaseTX> port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: <MII bus> on dc1
bmtphy1: <BCM5201 10/100baseTX PHY> PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: [ITHREAD]
....

В этом примере в системы присутствуют два адаптера, использующих драйвер man:dc[4].

Если драйвер для интерфейса отсутствует в [.filename]#GENERIC#, но он доступен для использования, то его будет требоваться загрузить до настройки и использования интерфейса.
Это может быть сделано одним из двух способов:

* Самым лёгким способом является загрузка модуля ядра сетевой карты при помощи man:kldload[8].  Чтобы также автоматически загружать драйвер во время загрузки, добавьте соответствующую строку в [.filename]#/boot/loader.conf#.  Не все драйверы сетевых адаптеров доступны в виде модулей; например, что существенно, модули отсутствуют для драйверов адаптеров ISA.
* Альтернативным вариантом является статическая компиляция поддержки конкретного адаптера в нестандартное ядро.  Обратитесь к [.filename]#/usr/src/sys/conf/NOTES# и [.filename]#/usr/src/sys/_arch_/conf/NOTES# и справочной странице драйвера для определения того, какую строку добавлять в конфигурационный файл нестандартного ядра.  За более подробной информацией о перекомпиляции ядра обратитесь к разделу crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD].  Если адаптер был распознан во время загрузки, то перекомпиляция ядра не требуется.

[[config-network-ndis]]
==== Использование NDIS-драйверов Windows(R)

К сожалению, всё ещё много производителей не предоставляют схем их драйверов сообществу открытого кода, так как считают эту информацию коммерческой тайной.
Соответственно, разработчикам FreeBSD и других операционных систем остаются два варианта: разрабатывать драйверы при помощи долгого и болезненного процесса обратного проектирования либо использовать существующие бинарные файлы драйверов, доступные для платформ Microsoft(R) Windows(R).
Большинство разработчиков, включая тех, что связаны с FreeBSD, выбрали последний подход.

Благодаря вкладу Билла Пола (wpaul) имеется "родная" поддержка NDIS (Network Driver Interface Specification).
Эмулятор NDIS (известный также как Project Evil) принимает бинарный файл Windows(R) и по сути заставляет его полагать, что он работает в Windows(R).
Так как драйвер man:ndis[4] использует бинарный файл Windows(R), он работает только в системах i386 и amd64.
Поддерживаются устройства PCI, CardBus, PCMCIA (PC-Card) и USB.

Для использования эмулятора NDIS необходимы три вещи:

. Исходный код ядра
. Бинарный файл драйвера Windows(R) XP (расширение [.filename]#.SYS#)
. Конфигурационный файл драйвера Windows(R) XP (расширение [.filename]#.INF#)

Поищите файлы для конкретного адаптера.
Вообще говоря, их можно найти на поставляемых CD или на веб-сайте вендора.
В последующих примерах используются [.filename]#W32DRIVER.SYS# и [.filename]#W32DRIVER.INF#.

Разрядность драйвера должна соответствовать версии FreeBSD.
В случае FreeBSD/i386 используйте 32-разрядный драйвер Windows(R).
Для FreeBSD/amd64 требуется 64-разрядный драйвер Windows(R).

Следующим шагом является компиляция бинарного файла драйвера в загружаемый модуль ядра.
Используйте man:ndisgen[8] как пользователь `root`:

[source,shell]
....
# ndisgen _/path/to/W32DRIVER.INF_ _/path/to/W32DRIVER.SYS_
....

man:ndisgen[8] работает в интерактивном режиме и запрашивает всю дополнительную информацию, которая требуется.
Новый модуль ядра записывается в текущий каталог.
Используйте man:kldload[8] для загрузки нового модуля:

[source,shell]
....
# kldload _./W32DRIVER_SYS.ko
....

Вдобавок к сгенерированному модулю ядра должны быть загружены модули [.filename]#ndis.ko# и [.filename]#if_ndis.ko#.
Это должно выполняться автоматически при загрузке любого модуля, зависящего от man:ndis[4].
Если этого не происходит, загрузите их в неавтоматическом режиме при помощи следующих команд:

[source,shell]
....
# kldload ndis
# kldload if_ndis
....

Первая команда загружает оболочку драйвера минипорта NDIS, а вторая загружает реальный сетевой интерфейс.

Теперь проверьте man:dmesg[8] на предмет наличия ошибок загрузки.
Если всё прошло хорошо, выдача должна быть похожа на следующее:

[source,shell]
....
ndis0: <Wireless-G PCI Adapter> mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps
....

С этого момента вы можете считать устройство `ndis0` таким же сетевым интерфейсом, как и юбое другое (например, `dc0`).

Чтобы настроить систему на загрузку модулей NDIS при загрузке, скопируйте сгенерированный модуль, [.filename]#W32DRIVER_SYS.ko#, в каталог [.filename]#/boot/modules#.
Затем добавьте в [.filename]#/boot/loader.conf# следующую строку:

[.programlisting]
....
W32DRIVER_SYS_load="YES"
....

=== Настройка сетевой карты

Как только для сетевой карты загружен подходящий драйвер, ее потребуется настроить. Как и многое другое, сетевая карта может быть настроена во время установки с помощью sysinstall.

Для вывода информации о конфигурации сетевых интерфейсов введите следующую команду:

[source,shell]
....
% ifconfig
dc0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	options=80008<VLAN_MTU,LINKSTATE>
	ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect (100baseTX <full-duplex>)
        status: active
dc1: flags=8802<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=80008<VLAN_MTU,LINKSTATE>
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> metric 0 mtu 16384
        options=3<RXCSUM,TXCSUM>
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
	nd6 options=3<PERFORMNUD,ACCEPT_RTADV>
....

В этом примере были показаны следующие устройства:

* [.filename]#dc0#: первый Ethernet интерфейс
* [.filename]#dc1#: второй Ethernet интерфейс
* [.filename]#lo0#: устройство loopback

Для присвоения имени сетевой карте FreeBSD использует имя драйвера и порядковый номер, в котором карта обнаруживается при инициализации устройств. Например, [.filename]#sis2# это третья сетевая карта, использующая драйвер man:sis[4].

В этом примере, устройство [.filename]#dc0# включено и работает. Ключевые признаки таковы:

. `UP` означает, что карта настроена и готова.
. У карты есть интернет (`inet`) адрес (в данном случае `192.168.1.3`).
. Установлена маска подсети (`netmask`; `0xffffff00`, то же, что и `255.255.255.0`).
. Широковещательный адрес (в данном случае, `192.168.1.255`).
. Значение MAC адреса карты (`ether`) `00:a0:cc:da:da:da`
. Выбор физической среды передачи данных в режиме автовыбора (`media: Ethernet autoselect (100baseTX full-duplex)`).  В этом примере [.filename]#dc1# была настроена для работы с физической средой `10baseT/UTP`.  За более подробной информацией о типах физических сред, доступных драйверу, обратитесь к его справочной странице.
. Состояние соединения (`status`) находится в статусе `active`, указывая на обнаружение несущего сигнала.  Для [.filename]#dc1# состояние `status: no carrier` является нормальным, если кабель Ethernet не подключён к адаптеру.

Если в выдаче man:ifconfig[8] присутствует что-то, подобное следующему:

[source,shell]
....
dc0: flags=8843<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500
	options=80008<VLAN_MTU,LINKSTATE>
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX <full-duplex>)
        status: active
....

это означает, что адаптер не был сконфигурирован.

Для конфигурирования адаптера вам потребуются привилегии пользователя `root`.
Настройка сетевого адаптера может быть выполнена из командной строки с помощью man:ifconfig[8], но конфигурация не сохранится после перезапуска системы, если только настройки сетевого адаптера также не будут добавлены в [.filename]#/etc/rc.conf# при помощи какого-либо редактора.
Для каждого сетевого адаптера, присутствующего в системе, добавьте строку, как показано в этом примере:

[.programlisting]
....
ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"
....

Замените `dc0` и `dc1`, а также информацию об адресе IP на соответствующие значения, корректные для системы.
Обратитесь к справочной странице соответствующего драйвера, man:ifconfig[8] и man:rc.conf[5] для получения дополнительной информации о доступных параметрах и формате [.filename]#/etc/rc.conf#.

Если сеть была настроена в процессе установки системы, то некоторые строки, касающиеся сетевой карты, могут уже присутствовать.
Внимательно проверьте [.filename]#/etc/rc.conf# перед добавлением каких-либо строк.

Если в сети не используется DNS, отредактируйте [.filename]#/etc/hosts# для добавления имён и адресов IP различных машин в сети, если их ещё там нет.
Для получения дополнительной информации обратитесь к man:hosts[5] и [.filename]#/usr/shared/examples/etc/hosts#.

[NOTE]
====
Если сервер DHCP отсутствует, но требуется доступ в Интернет, настройте сетевой шлюз и сервер имён самостоятельно:

[source,shell]
....
# echo 'defaultrouter="ваш_маршрутизатор_по_умолчанию"' >> /etc/rc.conf
# echo 'nameserver ваш_сервер_DNS' >> /etc/resolv.conf
....
====

=== Тестирование и устранение проблем

После того, как в [.filename]#/etc/rc.conf# будут сохранены необходимые изменения, для тестирования сетевых настроек и проверки того, что система перезапускается без каких-либо ошибок в конфигурации, можно использовать перезагрузку.
Альтернативным способом является применение настроек системы работы с сетью при помощи этой команды:

[source,shell]
....
# service netif restart
....

[NOTE]
====
Если используемый по умолчанию шлюз был настроен в [.filename]#/etc/rc.conf#, также используйте эту команду:

[source,shell]
....
# service routing restart
....
====

После того, как система работы с сетью перезапустится, проверьте сетевые интерфейсы.

==== Проверка Ethernet карты

Для проверки правильности настройки сетевой карты выполните ping для самого интерфейса, а затем для другой машины в локальной сети:

[source,shell]
....
% ping -c5 192.168.1.3
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms
....

[source,shell]
....
% ping -c5 192.168.1.2
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms
....

Для проверки преобразования имён сети используйте имя машины вместо `192.168.1.2`.
Если в сети отсутствует сервер DNS, то сначала обязательно нужно настроить [.filename]#/etc/hosts#.

==== Решение проблем

Решение проблем с аппаратным и программным обеспечением всегда вызывает боль, которую можно смягчить, проверив сначала простые вещи.
Подключён ли сетевой кабель?
Корректно ли настроены сетевые сервисы?
Правильно ли настроен межсетевой экран?
Поддерживается ли используемая карта во FreeBSD?
Всегда перед тем, как отправить сообщение об ошибке, проверьте информацию об оборудовании, обновите FreeBSD до последней версии STABLE, просмотрите архивы списков рассылки и выполните поиск в Интернет.

Если карта работает, но производительность низка, может помочь чтение страницы справочника man:tuning[7].
Кроме того, проверьте также конфигурацию сети, поскольку её некорректные настройки могут приводить к низкой скорости соединений.

Некоторые пользователи встречаются с появлением одного или двух сообщений `device timeouts`, что нормально для некоторых сетевых карт.
Если сообщения продолжают появляться или беспокоят, определите, не конфликтует ли это устройство с каким-то другим.
Ещё раз проверьте кабельное соединение.
Рассмотрите возможность использовать другой адаптер.

Время от времени пользователи наблюдают несколько ошибок `watchdog timeout`.
Первым делом нужно проверить сетевой кабель.
Многие карты требуют поддержки Bus Mastering слотом PCI. На некоторых старых материнских платах, только один PCI слот имеет такую поддержку (обычно слот 0). Сверьтесь с документацией на сетевую карту и материнскую плату, чтобы определить, может ли это быть проблемой.

Сообщение `No route to host` появляются, если система не в состоянии доставить пакеты к хосту назначения. Это может случиться, если не определен маршрут по умолчанию, или кабель не подключен. Проверьте вывод команды `netstat -rn` и убедитесь, что к соответствующему хосту есть маршрут.
Если это не так, прочтите crossref:advanced-networking[advanced-networking, Сложные вопросы работы в сети].

Сообщения `ping: sendto: Permission denied` зачастую появляются при неправильно настроенном брандмауэре. Если `ipfw` включен в ядре, но правила не определены, правило по умолчанию блокирует весь трафик, даже запросы ping! Прочтите crossref:firewalls[firewalls, Межсетевые экраны] с более подробной информацией.

Иногда скорость карты недостаточна, или ниже среднего. В этих случаях лучше всего изменить режим выбора типа подключения с `autoselect` на правильный тип. Обычно это работает для большинства оборудования, но не может решить проблему во всех случаях. Проверьте еще раз настройки сети и прочтите страницу справочника man:tuning[7].

[[configtuning-virtual-hosts]]
== Настройка виртуальных серверов

Очень часто FreeBSD используется для размещения сайтов, когда один сервер работает в сети как несколько серверов. Это достигается присвоением нескольких сетевых адресов одному интерфейсу.

У сетевого интерфейса всегда есть один "настоящий" адрес, хотя он может иметь любое количество "синонимов" (alias). Эти синонимы обычно добавляются путём помещения соответствующих записей в [.filename]#/etc/rc.conf#.

Синоним для интерфейса [.filename]#fxp0# выглядит следующим образом:

[.programlisting]
....
ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"
....

Заметьте, что записи синонимов должны начинаться с `alias0` и идти далее в определенном порядке (например, `_alias1`, `_alias2`, и т.д.). Конфигурационный процесс остановится на первом по порядку отсутствующем числе.

Определение маски подсети для синонима очень важно, но к счастью, так же просто. Для каждого интерфейса должен быть один адрес с истинной маской подсети. Любой другой адрес в сети должен иметь маску подсети, состоящую из всех единичек (что выражается как `255.255.255.255` или как `0xffffffff`).

Например, рассмотрим случай, когда интерфейс [.filename]#fxp0# подключён к двум сетям: к сети `10.1.1.0` с маской подсети `255.255.255.0` и к сети `202.0.75.16` с маской `255.255.255.240`.
Предполагается, что система должна быть сконфигурирована так, чтобы находиться в диапазоне с `10.1.1.1` по `10.1.1.5` и с `202.0.75.17` по `202.0.75.20`.
Только первый адрес в указанном диапазоне должен иметь реальную сетевую маску.
Все остальные (с `10.1.1.2` по `10.1.1.5` и с `202.0.75.18` по `202.0.75.20`) должны быть сконфигурированы с маской сети `255.255.255.255`.

Для этого в файл [.filename]#/etc/rc.conf# должны быть внесены следующие записи:

[.programlisting]
....
ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"
....

[[configtuning-syslog]]

== Настройка системного регистратора событий syslogd

Протоколирование системы является важным аспектом системного администрирования.
Оно используется для обнаружения ошибок в системе и проблем с оборудованием и программным обеспечением.
Оно также играет очень важную роль в аудите безопасности и реагировании на инциденты.
Системные даемоны без управляющего терминала также обычно протоколируют информацию через системные функции регистрации или другой файл журнала.

Этот раздел описывает, как настроить и использовать системный регистратор FreeBSD, man:syslogd[8], и как выполнять ротацию журналов и управление ими посредством man:newsyslog[8].
Внимание будет сосредоточено на настройке и использовании `syslogd` на локальной машине.
В случае более комплексных конфигураций, использующих отдельную машину для протоколирования, обратитесь к разделу <<network-syslogd>>.

=== Использование syslogd

В стандартной конфигурации FreeBSD man:syslogd[8] запускается при загрузке.
Это управляется при помощи переменной `syslogd_enable` в [.filename]#/etc/rc.conf#.
Имеется множество параметров приложения, которые влияют на поведение man:syslogd[8].
Для их изменения используйте `syslogd_flags` в [.filename]#/etc/rc.conf#.
Обратитесь к man:syslogd[8] для получения дополнительной информации о параметрах, а также к man:rc.conf[5], разделам <<configtuning-core-configuration>> и <<configtuning-rcd>> за дополнительной информацией о [.filename]#/etc/rc.conf# и подсистеме man:rc[8].

=== Настройка syslogd

Конфигурационный файл, которым по умолчанию является [.filename]#/etc/syslog.conf#, управляет тем, что делает man:syslogd[8] с записями о журналируемых событиях при их получении.
Имеется несколько параметров для управления обработкой поступающих событий, из которых самыми основными являются _facility_ (объект или подсистема) и _level_ (уровень).
Объект описывает, какая подсистема сформировала сообщение, например, ядро или даемон, а уровень описывает степень серьёзности произошедшего события.
Это делает возможным записывать события в разные файлы регистрации либо отбрасывать их в зависимости от подсистемы и важности.
Также возможно осуществление действий в зависимости от приложения, которое направило сообщение, а в случае удалённого протоколирования и от имени хоста машины, сформировавшей регистрируемое событие.

Настройка man:syslogd[8] достаточно незамысловата.
Конфигурационный файл состоит из строк, по одной на каждое действие, а синтаксически каждая строка состоит из поля выбора (селектора), за которым следует поле действия.
Поле выбора имеет вид _объект.уровень_, которое будет соотноситься с сообщениями о событиях от _объекта_ с уровнем серьёзности, соответствующим или превышающим _уровень_.
Перед уровнем можно добавить необязательный флажковый параметр сравнения для более точного указания того, что протоколируется.
Для одного и того же действия могут использоваться несколько селекторов, они разделяются точкой с запятой (`;`).
Используемый символ `*` будет соответствовать любому значению.
Поле действия указывает, куда направлять журналируемое сообщение, например, в файл или на удалённую протоколирующую машину.
В качестве примера это файл [.filename]#syslog.conf# из FreeBSD, используемый по умолчанию:

[.programlisting]
....
# $FreeBSD$
#
#	Spaces ARE valid field separators in this file. However,
#	other *nix-like systems still insist on using tabs as field
#	separators. If you are sharing this file between systems, you
#	may want to use only tabs as field separators here.
#	Consult the man:syslog.conf[5] manpage.
*.err;kern.warning;auth.notice;mail.crit	/dev/console <.>
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err	/var/log/messages
security.*					/var/log/security
auth.info;authpriv.info				/var/log/auth.log
mail.info					/var/log/maillog <.>
lpr.info					/var/log/lpd-errs
ftp.info					/var/log/xferlog
cron.*						/var/log/cron
*.=debug					/var/log/debug.log <.>
*.emerg						*
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info					/var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!ppp <.>
*.*						/var/log/ppp.log
!*
....

<.> Выбирать все сообщения с уровнем `err` и выше, а также `kern.warning`, `auth.notice` и `mail.crit`, при этом направлять эти сообщения о событиях на консоль ([.filename]#/dev/console#).
<.> Выбирать все сообщения от подсистемы `mail` с уровнем `info` и выше, при этом протоколировать эти сообщения в [.filename]#/var/log/maillog#.
<.> В этой строке используется флаг сравнения `=` для выбора сообщений только с уровнем `debug` и записи их в [.filename]#/var/log/debug.log#.
<.> Это пример использования функции _указания программы_. При этом последующие правила будут применяться только для указанной программы. В данном случае эта строка и последующие заставляют все сообщения от `ppp`, но не от других программ, направляться в [.filename]#/var/log/ppp.log#.

Этот пример показывает, что существует достаточное количество уровней и подсистем.
Имеются следующие уровни, в порядке снижения уровня критичности: `emerg`, `alert`, `crit`, `err`, `warning`, `notice`, `info` и `debug`.
Объекты без определённого порядка перечисления таковы: `auth`, `authpriv`, `console`, `cron`, `daemon`, `ftp`, `kern`, `lpr`, `mail`, `mark`, `news`, `security`, `syslog`, `user`, `uucp` и `local0` до `local7`.
Имейте в виду, что в других операционных системах могут быть подсистемы, отличающиеся от указанных.

Зная это, легко добавить новую строку в [.filename]#/etc/syslog.conf# для регистрации всех событий от различных даемонов на уровне `notice` и выше в файле [.filename]#/var/log/daemon.log#. Просто добавьте следующее:

[.programlisting]
....
daemon.notice					/var/log/daemon.log
....

Для получения дополнительной информации о различных уровнях и подсистемах, обратитесь к man:syslog[3] и man:syslogd[8].
Для получения дополнительной информации о [.filename]#syslog.conf# и его синтаксисе, а также дополнительных примеров расширенного использования обратитесь к man:syslog.conf[5] и разделу <<network-syslogd>>.

=== Управление журналами событий и ротацией при помощи newsyslog

Журналы событий имеют свойство быстро расти и постоянно накапливать данные.
Это приводит к тому, что файлы наполняются информацией, полезность которой невелика для использования в данный момент, при этом они занимают всё больше пространства на жёстком диске.
Управление журналами событий пытается решить это.
Во FreeBSD для управления файлами журналов событий применяется man:newsyslog[8].
Эта программа периодически ротирует и сжимает файлы журналов, а при необходимости создаёт отсутствующие файлы и уведомляет программы при перемещении файлов.
Файлы журналов не обязательно генерируются syslog, так как man:newsyslog[8] работает с любыми журналами, записываемыми любыми программами.
Заметьте, что `newsyslog` обычно запускается при помощи man:cron[8], и не является системным даемоном.
В стандартной конфигурации он запускается каждый час.

==== Настройка newsyslog

Для того, чтобы понимать, какие действия нужно предпринимать, man:newsyslog[8] считывает свой конфигурационный файл, которым по умолчанию является [.filename]#/etc/newsyslog.conf#.
В данном конфигурационном файле для каждого файла, управляемого man:newsyslog[8], выделена одна строка.
В каждой строке указан владелец файла, полномочия и то, когда ротировать файл, а также необязательные флажковые параметры, которые влияют на параметры ротации журнала, например, на сжатие, и программы, которым нужно отправить сигнал при ротации журнала.
Вот стандартный конфигурационный файл FreeBSD:

[.programlisting]
....
# configuration file for newsyslog
# $FreeBSD$
#
# Entries which do not specify the '/pid_file' field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the 'N' flag.
#
# The 'flags' field is one or more of the letters: BCDGJNUXZ or a '-'.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename		[owner:group]	mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log			600  7     *    @T00  J
/var/log/amd.log			644  7     100  *     J
/var/log/auth.log			600  7     100  @0101T JC
/var/log/console.log			600  5     100  *     J
/var/log/cron				600  3     100  *     JC
/var/log/daily.log			640  7     *    @T00  JN
/var/log/debug.log			600  7     100  *     JC
/var/log/init.log			644  3     100  *     J
/var/log/kerberos.log			600  7     100  *     J
/var/log/lpd-errs			644  7     100  *     JC
/var/log/maillog			640  7     *    @T00  JC
/var/log/messages			644  5     100  @0101T JC
/var/log/monthly.log			640  12    *    $M1D0 JN
/var/log/pflog				600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log	root:network	640  3     100  *     JC
/var/log/security			600  10    100  *     JC
/var/log/sendmail.st			640  10    *    168   B
/var/log/utx.log			644  3     *    @01T05 B
/var/log/weekly.log			640  5     1    $W6D0 JN
/var/log/xferlog			600  7     100  *     JC
....

Каждая строка начинается с имени файла для ротации, за которым может указываться владелец и группа для ротируемого и вновь создаваемого файлов.
Следующее поле, `mode`, является режимом доступа к файлам, а `count` указывает на количество ротируемых файлов с журналами событий, которое должно храниться.
Поля `size` и `when` говорят `newsyslog`, когда ротировать этот файл.
Файл журнала ротируется, когда либо его размер превышает значение поля `size`, либо после того, как истечёт время, указанное в поле `when`.
`*` означает, что данное поле игнорируется.
Поле _flags_ даёт man:newsyslog[8] дополнительные инструкции, такие как способ сжатия ротированного файла или необходимость создания файла журнала, если он отсутствует.
Последние два поля является необязательными и задают PID-файл некоторого процесса и номер сигнала, который будет направлен в этот процесс при ротации файла.
Для получения дополнительной информации обо всех полях, действующих флажковых параметрах и о том, как задать время ротации, обратитесь к  man:newsyslog.conf[5].
Не забывайте о том, что `newsyslog` запускается из `cron` и не может ротировать файлы чаще, чем он запускается из man:cron[8].

[[configtuning-configfiles]]
== Файлы настройки

=== Каталог [.filename]#/etc#

Во FreeBSD определён ряд каталогов, предназначенных для хранения конфигурационных файлов. Это:

[.informaltable]
[cols="1,1", frame="none"]
|===

|[.filename]#/etc#
|Основные файлы конфигурации системы. Тут размещены системно-зависимые данные.

|[.filename]#/etc/defaults#
|Версии системных конфигурационных файлов по умолчанию.

|[.filename]#/etc/mail#
|Дополнительные конфигурационные файлы man:sendmail[8], другие конфигурационные файлы MTA. 

|[.filename]#/etc/ppp#
|Настройка для user- и kernel-ppp программ. 

|[.filename]#/etc/namedb#
|Основное место расположения данных man:named[8]. Обычно [.filename]#named.conf# и файлы зон расположены здесь.

|[.filename]#/usr/local/etc#
|Конфигурационные файлы установленных приложений. Могут содержать подкаталоги приложений.

|[.filename]#/usr/local/etc/rc.d#
|Скрипты запуска/остановки установленных приложений.

|[.filename]#/var/db#
|Автоматически генерируемые системно-специфичные файлы баз данных, такие как база данных пакетов, и так далее
|===

=== Имена хостов

==== [.filename]#/etc/resolv.conf#

[.filename]#/etc/resolv.conf# определяет, как резолвер (resolver) FreeBSD получает доступ к Системе Доменных Имён (DNS).

Основные записи [.filename]#resolv.conf#: 

[.informaltable]
[cols="1,1", frame="none"]
|===

|`nameserver`
|IP адрес сервера имён. Сервера опрашиваются в порядке описания. Максимальное количество адресов - три.

|`search`
|Список доменов для поиска с помощью hostname lookup. Обычно определяется доменом, в котором находится компьютер.

|`domain`
|Домен, в котором находится компьютер.
|===

Типичный вид [.filename]#resolv.conf#:

[.programlisting]
....
search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30
....

[NOTE]
====
Опции `search` и `domain` нельзя использовать совместно.
====

При использовании DHCP man:dhclient[8] обычно перезаписывает [.filename]#resolv.conf# информацией, полученной от серверов DHCP.

==== [.filename]#/etc/hosts#

[.filename]#/etc/hosts# - простая текстовая база данных, напоминающая старый Интернет. Она работает совместно с DNS и NIS, сопоставляя доменные имена IP адресу. Отдельные компьютеры, соединённые с помощью локальной сети, могут быть записаны тут вместо man:named[8] сервера с целью упрощения. Кроме того, [.filename]#/etc/hosts# используется для записи IP адресов и соответствующих им доменов, избавляя от внешнего трафика, используемого для запросов к DNS серверам.

[.programlisting]
....
# $FreeBSD$
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace 'my.domain' below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#      10.0.0.0        -   10.255.255.255
#      172.16.0.0      -   172.31.255.255
#      192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#
....

Формат [.filename]#/etc/hosts#:

[.programlisting]
....
[IP адрес в Интернете] [имя компьютера] [alias1] [alias2] ...
....

Например:

[.programlisting]
....
10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2
....

За дополнительной информацией обращайтесь к man:hosts[5].

[[configtuning-sysctlconf]]
=== [.filename]#sysctl.conf#

[.filename]#sysctl.conf# очень похож на [.filename]#rc.conf#. Значения устанавливаются в виде `variable=value`. Указанные значения устанавливаются после перевода системы в многопользовательский режим. Однако не все переменные могут быть установлены в этом режиме.

Для того, чтобы отключить протоколирование прекращения работы программ из-за аварийных ошибок и ограничить пользователям просмотр процессов, запущенных другими пользователями, в [.filename]#sysctl.conf# могут быть заданы следующие параметры:

[.programlisting]
....
# Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0
....

[[configtuning-sysctl]]
== Тонкая настройка с использованием man:sysctl[8]

man:sysctl[8] используется для внесения изменений в работающую систему FreeBSD.
К ним относятся многие расширенные параметры стека TCP/IP и системы виртуальной памяти, которые в руках опытного системного администратора могут существенно улучшить производительность.
С помощью man:sysctl[8] можно считать и задать значения более пяти сотен системных переменных.

По своей сути, man:sysctl[8] выполняет две функции: чтение и изменение настроек системы.

Для просмотра всех доступных для чтения переменных:

[source,shell]
....
% sysctl -a
....

Чтобы прочитать определённую переменную, например, `kern.maxproc`, введите:

[source,shell]
....
% sysctl kern.maxproc
kern.maxproc: 1044
....

Для присвоения значения переменной, используйте выражение вида _переменная_=_значение_:

[source,shell]
....
# sysctl kern.maxfiles=5000
kern.maxfiles: 2088 -> 5000
....

Изменяемые с помощью sysctl переменные обычно принимают значения либо строкового, либо целого, либо булевого типа. Переменные булевого типа могут принимать два значения (`1` (истина) и `0` (ложь)).

Для автоматической установки некоторых переменных при каждой загрузке машины добавьте их в [.filename]#/etc/sysctl.conf#.
За дополнительной информацией обратитесь к man:sysctl.conf[5] и разделу <<configtuning-sysctlconf>>.

[[sysctl-readonly]]
=== Переменные man:sysctl[8] только для чтения

В некоторых случаях желательно изменить переменные man:sysctl[8] только для чтения. Иногда другого способа решить проблему нет; при этом, результат может быть достигнут только на этапе начальной загрузки.

Например, на некоторых моделях лэптопов диапазон памяти устройства man:cardbus[4] не определяется и выдается приблизительно такая ошибка:

[source,shell]
....
cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12
....

Ситуации, похожие на эту, требуют изменения некоторых значений man:sysctl[8], модификация которых запрещена. Для разрешения этой ситуации пользователь может поместить man:sysctl[8] "OID" в файл [.filename]#/boot/loader.conf#. Значения по умолчанию хранятся в файле [.filename]#/boot/defaults/loader.conf#.

Решение проблемы, приведенной выше, потребует помещения строки `hw.pci.allow_unsupported_io_range=1` в вышеупомянутый файл. Теперь man:cardbus[4] будет работать нормально.

[[configtuning-disk]]
== Оптимизация дисков

=== Переменные Sysctl

==== `vfs.vmiodirenable`

Значением переменной `vfs.vmiodirenable` может быть установлено в 0 (выключено) или 1 (включено); по умолчанию 1. Эта переменная отвечает за метод кэширования каталогов. Размер большинства каталогов невелик. Они могут поместиться в одном фрагменте (обычно 1K), и могут занимать ещё меньше места (обычно 512 байт) в кэше буфера.
При отключении этой переменной (при установке значения 0) кэширующий буфер будет кэшировать только фиксированное количество каталогов, даже если в системе имеется огромное количество памяти.
При включении (при установке значения 1) эта переменная sysctl позволит кэширующему буферу использовать кэш страниц памяти VM, делая доступным для кэширования каталогов весь объём памяти.
Однако, минимальный объём памяти, используемой для кэширования каталогов стал равен объёму страницы (обычно 4 K) вместо 512 байт.
Оставлять этот параметр включённым рекомендуется, если в системе работают сервисы, обрабатывающие значительное количество файлов.
Примером таких программ могут быть кэширующие прокси-серверы, большие почтовые серверы и серверы новостей. Обычно включение этой опции не понижает производительности, однако лучше поэкспериментировать, чтобы узнать оптимальное значение для вашей машины.

==== `vfs.write_behind`

Переменная sysctl `vfs.write_behind` по умолчанию установлена в `1` (включено). Она указывает системе выполнять запись на носитель по кластерам, что обычно делается для больших файлов. Идея в том, чтобы избежать заполнения кэша неполными буферами, когда это не увеличивает производительность.
Однако это может затормозить процессы и в некоторых случаях должно быть отключено.

==== `vfs.hirunningspace`

Переменная sysctl `vfs.hirunningspace` определяет число запросов записи на диск, которые могут быть поставлены в очередь.
Значения по умолчанию обычно бывает достаточно, но на машинах с большим количеством дисков попробуйте увеличить его до четырех или пяти _мегабайт_.
Учтите тот факт, что установка слишком большого значения (превышающего размер буфера записи) может привести к очень значительному падению общей производительности. Не делайте это значение произвольно большим! Большие значения могут привести к задержкам чтения, выполняемого в то же время

Имеются различные переменные sysctl, относящиеся к кэширующему буферу и кэшу страниц VM.
Изменение их значений не рекомендуется, поскольку система VM более чем хорошо справляется с задачей по автоматической самонастройке.

==== `vm.swap_idle_enabled`

Переменная sysctl `vm.swap_idle_enabled` полезна в больших многопользовательских системах, где есть много пользователей, входящих и выходящих из системы, и множество простаивающих процессов.
Подобные системы склонны к генерации большого объёма постоянной нагрузки на резервы свободной памяти.
Включение этой функции и манипуляции с задержкой выгрузки в память подкачки (в секундах простоя) посредством `vm.swap_idle_threshold1` и `vm.swap_idle_threshold2` понижает приоритет страниц памяти, занятых простаивающими процессами, быстрее, чем обычный алгоритм выгрузки страниц.
Это даёт руку помощи даемону выгрузки страниц.
Включайте этот параметр только при необходимости, так как негативным эффектом является по сущности более ранняя выгрузка страниц из памяти, что требует больше памяти подкачки и пропускной способности диска.
В небольших системах этот параметр будет давать предсказуемый эффект, однако в больших системах, уже осуществляющих определённый объём выгрузки страниц, данный параметр позволяет системе VM проще загружать и выгружать из памяти целые процессы.

==== `hw.ata.wc`

Во FreeBSD 4.3 кэширование записи на IDE диски было отключено. Это понижало производительность IDE дисков в тестах, но было необходимо для лучшей сохранности данных. Проблема состоит в том, что IDE диски неправильно указывают время завершения записи на диск. При включенном кэшировании IDE диски могут не только записать данные в неправильном порядке - при большой нагрузке на диск некоторые блоки могут задержаться до бесконечности. Сбой, или отключение питания могут могут стать причиной серьёзных повреждений в файловой системе. Поэтому для безопасности системы значение по умолчанию этого параметра было изменено.
К сожалению, результатом этого стала столь значительная потеря производительности, что после выхода релиза значение этого параметра было возвращено во включённое состояние по умолчанию.
Проверьте значение переменной sysctl `hw.ata.wc`, применяемое по умолчанию в системе.
Если кэширование выключено, то установка значения этой переменной в 1 включит его снова.
Это обязательно должно быть сделано при помощи загрузчика во время загрузки, так как попытка выполнить это после загрузки ядра не будет иметь эффекта.
 
За дополнительной информацией обратитесь к man:ata[4].

==== `SCSI_DELAY` (`kern.cam.scsi_delay`)

Параметр настройки ядра `SCSI_DELAY` может использоваться для уменьшения времени загрузки системы.
Используемое по умолчанию значение достаточно велико и может приводить к задержкам в `15` секунд в процессе загрузки.
Уменьшение его до `5` секунд обычно работает (особенно с современными накопителями).
Следует использовать настраиваемый параметр загрузки `kern.cam.scsi_delay`.
Этот настраиваемый параметр и параметр конфигурации ядра принимают значения в _миллисекундах_, а _не_ в _секундах_.

[[soft-updates]]
=== Мягкое обновление

Программа man:tunefs[8] используется для настройки файловой системы. Эта программа может принимать большое количество параметров, но мы рассмотрим лишь один из них - включение и выключение Soft Updates, что может быть достигнуто следующим образом:

[source,shell]
....
# tunefs -n enable /filesystem
# tunefs -n disable /filesystem
....

Нельзя изменять файловую систему с помощью man:tunefs[8] когда она смонтирована. Самое подходящее время для включения "Soft Updates" - перед монтированием разделов, в однопользовательском режиме.

Soft Updates существенно увеличивают скорость создания и удаления файлов путём использования кэширования. Мы рекомендуем использовать Soft Updates на всех ваших файловых системах. Однако у Soft Updates есть и обратные стороны: во-первых, Soft Updates гарантирует целостность файловой системы в случае сбоя, но может наблюдаться задержка в несколько секунд (или даже минуту!) перед записью на жесткий диск. Если система зависнет - вы можете потерять больше, чем, если бы вы не включили Soft Updates. Во-вторых, Soft Updates задерживает освобождение блоков файловой системы. Если ваша файловая система заполнена, выполнение значительного обновления, например, `make installworld`, может вызвать переполнение.

==== Дополнительная информация о мягком обновлении

Есть два традиционных способа записи метаданных файловых систем на диск (пример метаданных: индексные дескрипторы и каталоги).

Исторически, поведение по умолчанию заключается в синхронном обновлении метаданных. Если каталог был изменен, система ждет, пока изменение не будет физически записано на диск. Содержимое файлов проходит через кэш и записывается на диск асинхронно. Преимущество этого способа в его надежности. При сбое во время обновления метаданные остаются в нормальном состоянии. Файл либо создается целиком, либо вообще не создается. Если блоки данных не были записаны в файл из буфера во время сбоя, man:fsck[8] сможет определить это и восстановить файловую систему, установив длину файла в 0. Кроме того, реализация этого способа проста и понятна. Недостаток в том, что обновление метаданных занимает много времени. Команда `rm -r`, например, последовательно удаляет все файлы в каталоге, и каждое изменение в каталоге (удаление файла) будет синхронно записано на диск. Сюда включаются обновления самого каталога, таблицы индексных дескрипторов, и возможно блоков, занятых файлом. Те же соглашения работают при распаковке больших иерархий (`tar -x`).

Другой вариант это асинхронное обновление метаданных. Это поведение по умолчанию для Linux/ext2fs и *BSD ufs с параметром `mount -o async`. Все обновления метаданных просто пропускаются через кэш буфера, как и содержимое файлов. Преимущество этой реализации в том, что нет необходимости ждать каждый раз, пока метаданные будут записаны на диск, поэтому все операции с большим объемом обновления метаданных будут происходить гораздо быстрее, чем при синхронном обновлении. Кроме того, реализация все еще проста и понятна, поэтому риск появления ошибок в коде невелик. Недостаток в том, что нет никаких гарантий исправности файловой системы. Если во время обновления большого объема метаданных произойдет сбой (например, отключение питания, или нажатие кнопки reset), файловая система останется в непредсказуемом состоянии. Нет возможности определить состояние файловой системы после такого сбоя; блоки данных файла могут быть уже записаны на диск, а обновления таблицы индексных дескрипторов нет. Невозможно реализовать `fsck`, которая могла бы исправить получившийся хаос (поскольку необходимой информации нет на диске). Если файловая система была уничтожена во время восстановления, единственный способ восстановления - запустить man:newfs[8] и воспользоваться резервной копией.

Обычное решение этой проблемы состояло в реализации _протоколировании проблемной области (dirty region logging)_, известном как _журналирование_, хотя этот термин использовался неправильно и порой также применялся к другим формам протоколирования транзакций. Обновление метаданных как и прежде происходит синхронно, но в отдельную область диска. Позже они перемещаются туда, где должны быть. Поскольку область протоколирования это небольшая, последовательная область диска, головкам жесткого диска не приходится перемещаться на большие расстояния даже во время значительных обновлений, поэтому такой способ быстрее, чем синхронные обновления. Кроме того, сложность реализации довольно ограничена, поэтому риск внесения ошибок невелик. Недостаток в том, что все обновления метаданных записываются дважды (один раз в область протоколирования и один раз окончательно), поэтому при обычной работе производительность может понизиться. С другой стороны, в случае сбоя все незаконченные действия с метаданными могут быть быстро отменены, или завершены после загрузки системы, поэтому система после сбоя загружается быстрее.

Kirk McKusick, разработчик Berkeley FFS, решил эту проблему с помощью Soft Updates: все незавершенные обновления метаданных находятся в памяти и записываются на диск в упорядоченном виде ("упорядоченное обновления метаданных"). При значительных обновлениях метаданных более поздние обновления "присоединяются" к предыдущим, если они все еще находятся в памяти и еще не записаны на диск. Поэтому все операции, скажем, над каталогом, обычно выполняются в памяти перед записью обновления на диск (блоки данных сортируются в соответствии с их положением, так что они не будут записаны на диск до метаданных. При крахе операционной системы выполняется "откат": считается, что все операции, не записанные на диск, никогда не происходили. Файловая система находится в том состоянии, в котором она была за 30-60 секунд до сбоя. Используемый алгоритм гарантирует, что все используемые ресурсы маркированы соответствующим образом в своих областях: блоки и индексные дескрипторы. После сбоя могут остаться только ошибки выделения ресурсов, они помечаются как "используемые", хотя на самом деле "свободны". man:fsck[8] разбирается в ситуации и освобождает более не используемые ресурсы. После сбоя система может быть безопасно смонтирована с опцией `mount -f`. Для освобождения ресурсов, которые могут не использоваться, в дальнейшем потребуется запустить man:fsck[8]. Эта идея лежит в основе _background (фоновая) fsck_: во время запуска системы записывается только _снимок_ файловой системы. Все системы могут быть смонтированы в "грязном" состоянии, и система загружается в многопользовательский режим. Затем, фоновые `fsck` ставятся в очередь для всех систем, где это требуется, чтобы освободить неиспользуемые ресурсы. (Файловые системы, где не используются Soft Updates, все еще требуют запуска `fsck` в обычном режиме).

Преимущество заключается в том, что операции с метаданными производятся почти так же быстро, как при асинхронных обновлениях, которые быстрее, чем _журналирование_, когда метаданные должны быть записаны дважды.
Недостаток в сложности кода (подразумевающим больший риск появления ошибок в области, где вероятность потери данных пользователя особенно высока) и в более высоких требованиях к объему памяти. К тому же могут возникнуть некоторые странные на первый взгляд ситуации. После сбоя состояние файловой системы несколько более "старое". В ситуации, когда стандартный способ синхронизации оставит несколько файлов нулевой длины после выполнения `fsck`, в файловой системе с Soft Updates их не останется вовсе, поскольку ни метаданные, ни содержимое файлов не были записаны на диск. Дисковое пространство не будет освобождено пока обновления не будут записаны на диск, что может занять некоторое время после выполнения `rm`. Это может повлечь проблемы при установке большого количества файлов на файловую систему, где не хватает места для помещения всех файлов дважды.

[[configtuning-kernel-limits]]
== Изменение ограничений, накладываемых ядром

[[file-process-limits]]
=== Ограничения на Файлы/Процессы

[[kern-maxfiles]]
==== `kern.maxfiles`

Значение `kern.maxfiles` может быть увеличено или уменьшено в зависимости от потребностей системы.
Эта переменная указывает максимальное количество файловых дескрипторов в системе.
Когда таблица дескрипторов файлов полна, в буфере системных сообщений, который может быть просмотрен при помощи команды `dmesg`, будет повторяться сообщение `file: table is full`.

Каждый открытый файл, сокет или буфер использует дескриптор файла. Широкомасштабному серверу может понадобиться много тысяч дескрипторов файлов, в зависимости от количества программ, одновременно выполняемых на сервере.

В более старых релизах FreeBSD значение `kern.maxfile`, используемое по умолчанию, определяется на основании параметра `maxusers` в конфигурационном файле ядра.
`kern.maxfiles` растёт пропорционально значению `maxusers`.
При компиляции отдельного ядра рассмотрите установку значения этой переменной ядра в соответствии с использованием системы.
Значения большинства предопределённых лимитов ядра задаётся на основании этого показателя.
Даже если продуктивная машина может и не иметь 256 одновременно подключённых пользователей, требуемые ресурсы могут быть сравнимы с крупномасштабным веб-сервером.

Значение переменной `kern.maxusers` определяется автоматически при загрузке на основании данных об объёмах памяти, доступных системе, и может быть выяснено во время работы просмотром значения системной переменной `kern.maxusers`.
Некоторым системам будет требоваться более высокие или более низкие значения `kern.maxusers`, и они могут быть заданы как настраивемые параметры загрузчика; значения 64, 128 и 256 не являются редкими.
Выход за границы выше 256 не рекомендуется, если только не нужно иметь огромного количества файловых дескрипторов.
Многие из настраиваемых параметров, значения которых устанавливаются в значения по умолчанию на основании `kern.maxusers`, могут быть в индивидуальном порядке переопределены во время загрузки или во время работы системы в [.filename]#/boot/loader.conf#.
Обратитесь к man:loader.conf[5] и [.filename]#/boot/defaults/loader.conf# за дополнительной информацией и подсказками.

В более старых релизах система будет автоматически подстраивать показатель `maxusers`, если оно установлено в значение `0`.
При настройке этого параметра задайте значение `maxusers` по крайней мере равным 4, особенно если в системе запускается Xorg или она используется для компиляции программного обеспечения.
Самой важной таблицей, определяемой при помощи `maxusers`, является максимальное количество процессов, которое устанавливается равным `20 + 16 * maxusers`.
Если `maxusers` установлено в значение 1, то одновременно смогут существовать лишь 36 процессов, из них примерно 18 система запускает во время загрузки и около 15 используются в Xorg.
Даже такая простая задача, как чтение страницы Справочника, запускает девять процессов для её фильтрации, распаковки и просмотра.
Установка `maxusers` в значение 64 позволяет иметь одновременно вплоть до 1044 процессов, чего должно быть достаточно практически для любых применений.
Если, тем не менее, вы увидите пугающую ошибку  при попытке запуска другой программы, или вы используйте сервер с большим количеством одновременных пользователей (как `ftp.FreeBSD.org`), увеличьте значение и выполните повторную компиляцию.

[NOTE]
====
`maxusers` _не_ ограничивает количество пользователей, которые могут заходить на вашу машину.
Оно просто устанавливает различные размеры таблиц в разумные значения, учитывая максимальное количество пользователей в системе, и то, как много процессов каждый из них будет запускать одновременно.
====

==== `kern.ipc.somaxconn`

Переменная sysctl `kern.ipc.somaxconn` ограничивает размер очереди для приема новых TCP соединений. Значение по умолчанию `128` слишком мало для надежной обработки новых соединений для нагруженного web сервера. Для такого сервера рекомендуется увеличить это значение до `1024` или выше.
Даемон сервиса может сам ограничивать очередь приёма новых соединений (например, man:sendmail[8] или Apache), но обычно в файле настройки даемона есть директива для настройки длины очереди.
Более длинная очередь также помогает избежать атак типа Denial of Service (DoS).

[[nmbclusters]]
=== Сетевые Ограничения

Опция ядра `NMBCLUSTERS` обуславливает количество Mbuf, доступных на машине. На сервере с большим трафиком и маленьким Mbuf производительность будет пониженной. Каждый кластер представлен двумя килобайтами памяти, поэтому значение 1024 означает 2 мегабайта памяти ядра, зарезервированной для сетевых буферов.
Для определения их необходимого количества можно выполнить простой расчёт.
Веб-сервер с максимальным количеством одновременных соединений, равным 1000, при которых каждое соединение использует 6 K для буфера приёма и 16 K для буфера передачи, требует примерно 32 МБ для сетевых буферов, покрывающих потребности веб-сервера.
Хорошим правилом является умножение этого значения на 2, так что 2x32 МБ / 2 КБ = 64 МБ / 2 кБ = 32768.
Значения между 4096 и 32768 рекомендуются для машин с более высоким объёмом памяти.
Не указывайте произвольно большое значение параметра, так как это может привести к аварийной остановке системы при загрузке.
Для просмотра использования сетевых кластеров используйте man:netstat[1] с параметром `-m`.

Для настройки в процессе загрузки нужно использовать переменную загрузчика `kern.ipc.nmbclusters`.
Только в старых версиях FreeBSD требуется использование параметра `NMBCLUSTERS` конфигурации ядра man:config[8].

Для нагруженных серверов, интенсивно использующих системный вызов man:sendfile[2], может потребоваться увеличения буферов man:sendfile[2] с помощью параметра конфигурации ядра `NSFBUFS`, или изменения значения путем установки переменной в [.filename]#/boot/loader.conf# (обратитесь к man:loader[8] за подробностями). Общий признак того, что параметр требуется изменить - состояние процессов `sfbufa`. Переменная sysctl `kern.ipc.nsfbufs` установлена только для чтения. Этот параметр увеличивается вместе с `kern.maxusers`, хотя может потребоваться увеличить его отдельно.

[IMPORTANT]
====
Даже если сокет помечен как неблокирующий, вызов man:sendfile[2] на неблокирующем сокете может вызвать блокирование man:sendfile[2], пока не станет доступным достаточное количество `struct sf_buf`.
====

==== `net.inet.ip.portrange.*`

Переменные sysctl `net.inet.ip.portrange.*` контролируют диапазоны номеров портов, автоматически привязываемых к TCP и UDP сокетам. Есть три диапазона: нижний диапазон, диапазон по умолчанию и верхний диапазон. Большинство сетевых программ используют диапазон по умолчанию, контролируемый `net.inet.ip.portrange.first` и `net.inet.ip.portrange.last`, установленными соответственно в 1024 и 5000. Диапазоны портов привязки используются для исходящих соединений и при некоторых условиях портов может не хватить.
Чаще всего это происходит при работе сильно нагруженного проксирующего веб-сервера.
Диапазон портов не является проблемой при работе серверов, которые в основном обрабатывают входящие соединения, подобно обычному веб-серверу, или имеют ограниченное количество исходящих соединений, подобно почтовому узлу.
Для ситуаций, когда имеется нехватка портов, рекомендуется немного увеличить `net.inet.ip.portrange.last`.
Может подойти значение `10000`, `20000`, или `30000`.
Учтите влияние межсетевого экрана при изменении диапазона портов.
Некоторые межсетевые экраны могут блокировать большие диапазоны портов (обычно с небольшими номерами) и предполагают использование системами более высоких диапазонов для исходящих соединений - по этой причине не рекомендуется уменьшать значение `net.inet.ip.portrange.first`.

==== TCP Bandwidth Delay Product

TCP Bandwidth Delay Product Limiting похоже на TCP/Vegas в NetBSD. Оно может быть включено установкой переменной sysctl `net.inet.tcp.inflight.enable` в `1`. Система попытается вычислить задержку пакетов для каждого соединения и ограничить объем данных в очереди сети до значения, требуемого для поддержания оптимальной пропускной способности.

Эта возможность полезна при обработке данных через модемы, Gigabit Ethernet или даже высокоскоростные WAN-соединения (или любые другие соединения с большой задержкой передачи), особенно если также используется расширение размера окна или когда настроено большое окно передачи.
При включении этого параметра убедитесь также, что переменная `net.inet.tcp.inflight.debug` установлена в `0` (отладка выключена), а для использования в реальных задачах может понадобиться установка переменной `net.inet.tcp.inflight.min` в значение, равное как минимум `6144`.
Но учтите, что установка большого значения этой переменной может фактически отключить ограничение в зависимости от вида соединения.
Эта ограничивающая функция уменьшает количество данных в промежуточных очередях маршрутизации и коммутации пакетов и уменьшает объём данных в очереди интерфейса локального хоста.
С меньшим количеством пакетов в очереди интерактивные соединения, особенно на медленных модемах, будут осуществляться с меньшим показателем _Round Trip Times_.
Эта функция влияет только на передачу данных на стороне сервера, в частности, загрузку.
Она не влияет на приём данных или сгрузку.

Изменение значения переменной `net.inet.tcp.inflight.stab` _не_ рекомендуется. Этот параметр по умолчанию равен 20, что означает добавление 2 пакетов к вычислению задержки передачи.
Дополнительное окно требуется для стабилизации алгоритма и улучшения ответной реакции на изменение условий, но также приводит к более длительным задержкам ping на медленных соединениях, хотя всё же гораздо меньшим, чем без алгоритма inflight.
В таких случаях попробуйте уменьшить этот параметр до 15, 10 или 5; а также уменьшить `net.inet.tcp.inflight.min` (например, до 3500) для получения желаемого эффекта.
Уменьшение значений этих параметров может использоваться только как крайняя мера.

=== Виртуальная память

==== `kern.maxvnodes`

Файлы и каталоги в ядре представлены при помощи vnode (виртуальных узлов). Увеличение их числа может помочь уменьшить нагрузку на дисковую подсистему. Как правило, специальной настройки это значение не требует, однако, в некоторых случаях дисковая активность является узким местом, и система исчерпывает таблицу vnode, значение этой переменной следует увеличить. При этом необходимо оценить объем неактивной и свободной памяти.

Текущее количество использованных vnode можно посмотреть при помощи команды:

[source,shell]
....
#  sysctl vfs.numvnodes
vfs.numvnodes: 91349
....

Максимальное количество vnode, доступных системе:

[source,shell]
....
#  sysctl kern.maxvnodes
kern.maxvnodes: 100000
....

Если количество использованных vnode близко к максимуму, значение переменной `kern.maxvnodes` следует увеличить на 1000. Следите за динамикой изменения `vfs.numvnodes`. Если оно увеличивается, приближаясь к вновь установленному максимуму, процесс следует повторить. Изменение в распределении памяти должно быть видно в выводе утилиты man:top[1]: больше памяти перейдет в разряд активной.

[[adding-swap-space]]
== Увеличение объема подкачки

Несмотря на тщательное планирование, иногда система работает не так, как ожидалось.
Если требуется дополнительный объём памяти подкачки, его достаточно просто добавить.
Есть три способа увеличения объёма памяти подкачки: добавить новый жёсткий диск, включить подкачку поверх NFS или создать файл памяти подкачки на существующем разделе.

За информацией о шифровании памяти подкачки обратитесь к разделу crossref:disks[swap-encrypting,Шифрование области подкачки] Руководства.

[[new-drive-swap]]
=== Память подкачки на новом или существующем жёстком диске

Добавление нового жёсткого диска для памяти подкачки даёт более высокую производительность, чем добавление раздела на существующем устройстве.
Конфигурирование разделов и жёстких дисков описаны в <<disks-adding>>.
В разделе <<configtuning-initial>> обсуждаются планирование разделов и факторы, влияющие на размер раздела подкачки.

Используйте man:swapon[8] для добавления раздела подкачки в систему.
Например:

[source,shell]
....
# swapon /dev/ada1s1b
....

[WARNING]
====
Возможно использование любого не смонтированного в данный момент раздела, даже если он уже содержит данные.
Применение man:swapon[8] к разделу, содержащему данные, приведёт к перезаписи и уничтожению этих данных.
До запуска man:swapon[8] проверьте, что в качестве раздела, добавляемого как память подкачки, действительно указан тот раздел, что предполагался быть указанным.
====

Для автоматического добавления этого раздела подкачки при загрузке добавьте в [.filename]#/etc/fstab# запись о нём:

[.programlisting]
....
/dev/ada1s1b	none	swap	sw	0	0
....

Обратитесь к man:fstab[5] для получения описания записей в [.filename]#/etc/fstab#.

[[nfs-swap]]
=== Подкачка через NFS

Подкачка через NFS рекомендуется только в том случае, если в системе отсутствует жесткий диск; подкачка через NFS ограничена скоростью сетевого подключения и к тому же дополнительно нагружает NFS сервер.

[[create-swapfile]]
=== Файлы памяти подкачки

Вы можете создать файл определённого размера и использовать его как файл подкачки.
В последующем примере будет создан файл с именем [.filename]#/usr/swap0# и размером 64МБ.

.Создание файла подкачки в FreeBSD
[example]
====
. В ядро [.filename]#GENERIC# уже включён драйвер организации диска в оперативной памяти (man:md[4]), требуемый для этой операции.
При построении нестандартного ядра убедитесь, что в конфигурационном файле этого ядра присутствует следующая строка:
+
[.programlisting]
....
device	md
....
+
Для получения информации о построении кастомизированного ядра обратитесь к разделу <<kernelconfig>>.
+
. Создайте файл подкачки ([.filename]#/usr/swap0#):
+
[source,shell]
....
# dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
....

. Установите подходящие права на ([.filename]#/usr/swap0#):
+
[source,shell]
....
# chmod 0600 /usr/swap0
....

. Включите файл подкачки в [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
....

. Перегрузите компьютер или для включения подкачки прямо сейчас введите:
+
[source,shell]
....
# mdconfig -a -t vnode -f /usr/swap0 -u 0  swapon /dev/md0
....

====

[[acpi-overview]]
== Управление энергопотреблением и ресурсами

Важно использовать аппаратные ресурсы эффективно.
До того, как появился ACPI (Advanced Configuration and Power Interface), задачи управления энергопотреблением и температурными характеристиками системы на уровне операционных систем решались сложно и негибко.
Аппаратное обеспечение управлялось при помощи BIOS, и пользователь имел меньше возможностей по просмотру настроек управления энергопотреблением и их контролю.
Некоторые ограниченные возможности конфигурирования были доступны средствами _APM (Advanced Power Management)_.
Управление энергопотреблением и ресурсами являются одними из ключевых компонентов современной операционной системы.
Оно позволяет операционной системе выполнять мониторинг системных ограничений и, возможно, подавать предупреждающий сигнал при неожиданном росте температуры системы.

Этот раздел содержит исчерпывающую информацию об ACPI.
Будут даны ссылки для ознакомления с дополнительными материалами.

[[acpi-intro]]
=== Что такое ACPI?

ACPI является стандартом, написанный объединением производителей в целях предоставления стандартного интерфейса для аппаратных ресурсов и управления электропитанием.
Он является ключевым элементом концепции _Operating System-directed configuration and Power Management_, так как даёт операционной системе больше контроля и гибкости.
Современные системы вышли за пределы ограничений существующих Plug and Play интерфейсов до появления ACPI.
ACPI является прямым преемником APM.

[[acpi-old-spec]]
=== Недостатки Advanced Power Management (APM)

Подсистема APM управляет энергопотреблением системы в зависимости от её активности.
APM BIOS предоставляется поставщиком (системы) и специфичен для конкретной аппаратной платформы.
Драйвер APM операционной системы выступает посредником при обращении к _APM Software Interface_, позволяещем управлять уровнями энергопотребления.
APM должен продолжать использоваться для систем, произведённых в 2000 году и ранее.

В APM имеется четыре основных проблемы. Во-первых, управление энергопотреблением осуществляется через зависимый от поставщика BIOS, и OS ничего не знает нем. Один пример: когда пользователь устанавливает время ожидания для жесткого диска в APM BIOS, и это время истекает, BIOS останавливает жесткий диск без согласования с OS. Во-вторых, алгоритм APM встроен в BIOS, и все действия происходят вне контроля OS. Это означает, что пользователи могут решить проблемы с APM BIOS только путем перепрошивки его ROM; это очень опасная процедура, и если она завершится неудачно, система может оказаться в невосстановимом состоянии. В-третьих, реализация технологии APM зависит от поставщика, что означает дублирование усилий и если в BIOS одного из поставщиков будет найдена и исправлена ошибка, ее могли не исправить другие поставщики. Наконец, объем APM BIOS недостаточно велик для реализации сложной политики управления питанием, или такой политики, которая может хорошо адаптироваться к потребностям компьютера.

_Plug and Play BIOS (PNPBIOS)_ был неудобен во многих ситуациях. PNPBIOS это 16-битная технология, поэтому OS требовалось использовать 16-битную эмуляцию для "взаимодействия" с методами PNPBIOS.

FreeBSD драйвер APM документирован в странице справочника man:apm[4].

[[acpi-config]]
=== Настройка ACPI

По умолчанию драйвер [.filename]#acpi.ko# загружается при помощи man:loader[8] при запуске системы, его _не_ нужно компилировать как часть ядра.
Дело в том, что с модулями проще работать, например, при переключении на другой [.filename]#acpi.ko# без повторного построения ядра.
Такой подход имеет преимущество в упрощении тестирования.
Другая причина заключается в том, что запуск ACPI после запуска системы зачастую работает не очень хорошо.
Если вы сталкиваетесь с проблемами, то ACPI может быть полностью отключён.
Этот драйвер не должен и не может быть выгружен, поскольку системная шина использует его для различных взаимодействий с оборудованием.
ACPI может быть отключён установкой `hint.acpi.0.disabled="1"` в [.filename]#/boot/loader.conf# или командной строке man:loader[8].

[NOTE]
====
ACPI и APM не могут сосуществовать и должны использоваться раздельно.
Каждый из них при загрузке прекратит свою работу, если обнаружит, что уже используется другой.
====

ACPI может использоваться для перевода системы в спящий режим с помощью man:acpiconf[8] с флагом `-s` и параметром `1-5`.
Большинству пользователей будет требоваться только параметр `1` или `3` (приостановка работы с сохранением состояния в оперативной памяти).
Параметр `5` выполнит приостановку работы, что означает те же действия, что и:

[source,shell]
....
# halt -p
....

Доступны и другие варианты через man:sysctl[8].
Обратитесь к справочным страницам man:acpi[4] и man:acpiconf[8] для получения дополнительной информации.

[[ACPI-debug]]
== Использование и отладка FreeBSD ACPI

ACPI это фундаментально новый способ обнаружения устройств, управления энергопотреблением и предоставления стандартизированного доступа к различному оборудованию, ранее управлявшемуся BIOS. Был достигнут определенный прогресс в приспособлении ACPI к работе со всеми системами, но все еще встречаются ошибки в байткоде _ACPI Machine Language_ (AML) некоторых материнских плат, незавершенные участки кода в подсистемах ядра FreeBSD и ошибки в интерпретаторе Intel(R) ACPI-CA.

Этот раздел предназначен для того, чтобы помочь пользователям в содействии разработчикам FreeBSD ACPI в определении причин наблюдаемых вами проблем, осуществлении отладки и выработке решения.

[[ACPI-submitdebug]]
=== Отправка отладочной информации

[NOTE]
====
Перед отправкой сообщения об ошибке убедитесь, что у вас последняя версия BIOS, и, если доступна, последняя версия firmware встроенного контроллера.
====

При отправке сообщения о проблеме направляйте в адрес link:mailto:freebsd-acpi@FreeBSD.org[freebsd-acpi@FreeBSD.org] следующую информацию:

* Описание некорректного поведения, включая тип системы, модель и всё, что приводит к появлению ошибки. Отметьте настолько точно, насколько это возможно, когда ошибка начала появляться, если она является новой.
* Вывод man:dmesg[8] после `boot -v`, включая все сообщения, появляющиеся из-за ошибки.
* Вывод man:dmesg[8] после "boot ``-v``" с выключенным ACPI, если его отключение помогает решить проблему.
* Вывод `sysctl hw.acpi`. Это также является хорошим способом получения списка возможностей данной системы.
* URL, по которому можно найти соответствующий _ACPI Source Language_ (ASL). _Не_ отправляйте ASL непосредственно в список рассылки, поскольку он может быть очень большим. Сформируйте копию ASL запуском следующей команды:
+
[source,shell]
....
# acpidump -t -d  name-system.asl
....
+ 
(Замените вашим логином [.filename]#name# и производителем/моделью [.filename]#system#. Пример: [.filename]#njl-FooCo6000.asl#)

Большинство разработчиков FreeBSD отслеживают {freebsd-current}, но для уверенности в том, что проблемы будут замечены, отправьте их в {freebsd-acpi}.
Будьте терпеливы при ожидании отклика.
Если ошибка не будет очевидна сразу, вас могут попросить отправить PR при помощи man:send-pr[1].
При вводе PR, включите ту же информацию, что запрошена выше.
Это поможет разработчикам отследить эту проблему и решить её.
Не отправляйте PR без предварительной отправки письма в {freebsd-acpi}, поскольку вероятно, что о проблеме сообщалось ранее.

[[ACPI-background]]
=== Общие сведения

ACPI представлен во всех современных компьютерах, соответствующих архитектурам ia32 (x86), ia64 (Itanium) и amd64 (AMD). Полный стандарт включает множество возможностей, в том числе управление производительностью CPU, уровнем питания, температурой, различными системами аккумуляторов, встроенными контроллерами и опросом шины. В большинстве систем стандарт реализован не полностью. Например, настольные системы обычно реализуют только опрос шины, а портативные компьютеры кроме того могут поддерживать управление охлаждением и энергопотреблением. Они также поддерживают приостановку и последующий запуск системы различного уровня сложности.

ACPI-совместимые системы состоят из различных компонентов. Производители BIOS и чипсетов предоставляют различные жестко заданные таблицы, (например, FADT), которые определяют функции вроде карты APIC (используется для SMP), регистры настройки и простые значения параметров. Кроме того, предоставляется таблица байткода (_Differentiated System Description Table_, DSDT), определяющая древоподобное пространство имен устройств и методов.

Драйвер ACPI должен прочесть заданные таблицы, реализовать интерпретатор для байткода, модифицировать драйвера устройств и ядро для приема информации от подсистемы ACPI. Для FreeBSD Intel(R) предоставила интерпретатор (ACPI-CA), тот же что для Linux и NetBSD. Исходный код ACPI-CA находится в каталоге [.filename]#src/sys/contrib/dev/acpica#. Код для приспособления ACPI-CA к работе в FreeBSD, находится в [.filename]#src/sys/dev/acpica/Osd#.
Наконец, драйверы, реализующие различные устройства ACPI, находятся в [.filename]#src/sys/dev/acpica#.

[[ACPI-comprob]]
=== Часто встречающиеся проблемы

Для правильной работы ACPI все ее части должны работать правильно. Вот некоторые часто встречающиеся проблемы, в порядке частоты появления, и некоторые обходные пути или исправления.

==== Проблемы с мышью

В некоторых случаях при возобновлении работы после приостановки перестает работать мышь. Известным решением проблемы является добавление строки `hint.psm.0.flags="0x3000"` в файл [.filename]#/boot/loader.conf#.
Если это не срабатывает, то рассмотрите возможность направить сообщение об ошибке при помощи man:send-pr[1].

==== Приостановка/возобновление работы

ACPI поддерживает три состояния приостановки в RAM (STR), `S1`-`S3`, и одно состояние приостановки на диск (`STD`), называемое `S4`. `S5` это "мягкое выключение" и это нормальное состояние системы, когда она подключена к электросети, но не включена. `S4` может быть реализован двумя различными путями. ``S4``BIOS это BIOS-поддерживаемая приостановка на диск. ``S4``OS реализуется полностью операционной системой.

Начните с проверки переменных `sysctl hw.acpi`, относящихся к приостановке (suspend). Вот результат для Thinkpad:

[source,shell]
....
hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0
....

Используйте `acpiconf -s` для проверки `S3`, ``S4``OS, и `S5`.
Значение `s4bios`, равное единице (`1`), указывает на поддержку ``S4``BIOS, а не ``S4``OS.

При тестировании приостановки/возобновления работы начните с `S1`, если этот режим поддерживается.
Это состояние, скорее всего, поддерживается, поскольку не требует слишком серьёзной поддержки со стороны драйвера.
Никто не реализовал `S2`, который похож на `S1`.
Следующим режимом для тестирования является `S3`.
Это наиболее глубокое состояние режима STR, и оно требует существенной поддержки со стороны драйвера для корректной повторной инициализации аппаратного обеспечения.
Если у вас возникли проблемы при возобновлении работы, не стесняйтесь отправить письмо в адрес {freebsd-acpi}, но не ждите, что проблема будет решена, поскольку существует множество драйверов и оборудования, нуждающихся в дополнительном тестировании и работе над ними.

Распространённой проблемой с приостановкой/возобновлением работы является то, что многие драйверы устройств не сохраняют, не восстанавливают и не инициализируют повторно их микропрограммное обеспечение, регистры или память устройств.
В качестве первой попытки отладки проблемы, попробуйте:

[source,shell]
....
# sysctl debug.bootverbose=1
# sysctl debug.acpi.suspend_bounce=1
# acpiconf -s 3
....

Этот тест эмулирует цикл приостановки/возобновления всех драйверов устройств без фактического перехода в состояние `S3`.
В некоторых случаях таким способом могут быть выявлены такие проблемы, как потеря состояния микропрограммного обеспечения, таймаут таймера устройства и бесконечный цикл повторных попыток.
Заметьте, что система фактически не будет переходить в состояние `S3`, что означает, что устройства могут не потерять питание полностью, и многие будут нормально работать даже если методы приостановки/возобновления отсутствуют вовсе, в отличие от реального состояния `S3`.

Более сложные случаи требуют дополнительного оборудования, такого, как последовательный порт/кабель для последовательных консолей или порт/кабель Firewire для man:dcons[4], а также навыков отладки ядра.

Для того, чтобы помочь изолировать проблему, удалите из ядра столько драйверов, сколько возможно.
Если это работает, сузьте поиск драйвера, являющегося проблемным, путём загрузки драйверов до тех пор, пока снова не произойдёт сбой.
Обычно бинарные драйверы, такие как [.filename]#nvidia.ko#, драйвера дисплеев и USB вызывают большинство проблем, тогда как драйверы интерфейсов Ethernet, как правило, работают нормально.
Если вы можете нормально загрузить/выгрузить драйвера, автоматизируйте это, поместив соответствующие команды в [.filename]#/etc/rc.suspend# и [.filename]#/etc/rc.resume#.
Имеются заключённый в комментарии пример выгрузки и загрузки драйвера.
Попробуйте задать значение параметра `hw.acpi.reset_video` равным нулю (`0`), если дисплей не включается после возобновления работы.
Попробуйте установить более высокие или низкие значения для `hw.acpi.sleep_delay`, чтобы проверить, помогает ли это.

Другой способ, который можно попробовать, это запуск последнего дистрибутива Linux с поддержкой ACPI и тестирование поддержки остановки/возобновления работы на том же оборудовании.
Если она работает на Linux, проблема скорее всего в драйверах FreeBSD и поиск драйвера, вызывающего проблему, поможет разрешить ситуацию.
Имейте в виду, что те, кто поддерживают ACPI, обычно не поддерживают другие драйверы, такие как звук или ATA, так что все результаты работы с проблемой, вероятно, должны быть отправлены в список рассылки {freebsd-current} и человеку, поддерживающему соответствующий драйвер.
Опытные пользователи могут начать с добавления нескольких отладочных man:printf[3] в проблемный драйвер для отслеживания момента, в который останавливается функция возобновления работы.

Наконец, попробуйте отключить ACPI и включить APM. Если приостановка/возобновление работает с APM, вам возможно лучше подойдет APM, особенно на старом оборудовании (до 2000). Включение корректной поддержки ACPI поставщиками оборудования требует времени и вероятно в старом оборудовании поддержка ACPI в BIOS была некорректна.

==== Система зависает (насовсем или временно)

Большинство систем останавливаются в результате потери прерываний или "шторма" прерываний. В чипсетах существует много проблем, связанных с тем, как BIOS настраивает прерывания перед загрузкой, правильностью таблицы APIC (MADT), и маршрутизации _System Control Interrupt_ (SCI).

"Шторм" прерываний может быть обнаружен по потерянным прерываниям путем проверки вывода строки с `acpi0` команды `vmstat -i`.
Если счётчик увеличивается более чем несколько раз в секунду, то это является штормом прерываний.
Если система останавливается, попробуйте войти в DDB (kbd:[CTRL+ALT+ESC] на консоли) и ввести `show interrupts`.

При решении проблем с прерываниями попробуйте отключить поддержку APIC с помощью параметра `hint.apic.0.disabled="1"` в [.filename]#loader.conf#.

==== Паника

Паника, связанная с ACPI, случается довольно редко и имеет наибольший приоритет исправления. Первый шаг это изоляция действий, приводящих к панике (если это возможно) и получение отладки.
Следуйте инструкции по включению `options DDB` и настройке последовательной консоли (смотрите crossref:serialcomms[serialconsole-ddb,Вход в отладчик DDB с последовательной линии]) или настройке раздела man:dump[8].
Для того, чтобы получить обратную трассировку вызовов в DDB, используйте `tr`.
При ручной записи трассировки зафиксируйте по крайней мере пять (5) строк в самом низу и пять (5) строк в самом верху трассировки.

Затем попробуйте изолировать проблему, загрузившись с выключенным ACPI.
Если это срабатывает, изолируйте подсистему ACPI, используя различные значения `debug.acpi.disable`.
Обратитесь к man:acpi[4] для получения нескольких примеров.

==== Система включается после приостановки или завершения работы

Во-первых, попробуйте установить в man:loader.conf[5] параметр `hw.acpi.disable_on_poweroff="0"`. Это предотвращает отключение различных событий в ACPI во время завершения работы. В некоторых системах этот параметр необходимо установить в `1` (по умолчанию) по тем же причинам. Обычно это решает проблему, если система неожиданно включается после приостановки или отключения питания.

==== Другие проблемы

При возникновении других проблем с ACPI, таких как отсутствие работы с док-станцией или отсутствие обнаружения устройств, отправьте описание проблемы в список рассылки.
Некоторые из этих проблем могут быть связаны с незавершенными частями подсистемы ACPI, на реализацию котороых может потребоваться какое-то время.
Будьте терпеливыми, и подготовьтесь к тестированию исправлений.

[[ACPI-aslanddump]]
=== ASL, `acpidump`, и IASL

Наиболее часто встречается проблема, связанная с предоставлением поставщиками BIOS некорректного (или полностью ошибочного!) байткода. Это обычно проявляется появлением консольных сообщений ядра, подобных этому:

[source,shell]
....
ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
       (Node 0xc3f6d160), AE_NOT_FOUND
....

Зачастую эти проблемы могут быть решены обновлением BIOS до последней ревизии.
Большинство консольных сообщений безобидны, но если существуют другие проблемы, такие как неработающий статус батареи, то эти сообщения являются хорошей отправной точкой для поиска проблем в AML.
Байткод, известный как AML, компилируется из исходного текста на языке, называемом ASL.
AML находится в таблице, известной как DSDT.
Для получения копии ASL системы используйте man:acpidump[8].
Используйте оба параметра, как `-t`, показывающий содержимое постоянных таблиц, так и `-d`, дизассемблирующий AML.
Обратитесь к разделу <<ACPI-submitdebug,Отправка отладочной информации>> за примером синтаксиса.

Первой простейшей проверкой является перекомпиляция ASL для поиска ошибок.
Предупреждения обычно могут быть проигнорированы, но они являются ошибками, обычно не позволяющим ACPI работать корректно.
Для перекомпиляции ASL выполните следующую команду:

[source,shell]
....
# iasl your.asl
....

[[ACPI-fixasl]]
=== Исправление ASL

В конечном итоге цель FreeBSD состоит в том, чтобы практически у всех ACPI работал без какого-либо вмешательства пользователя.
На данный момент всё ещё разрабатываются обходные пути для решения распространённых ошибок поставщиков BIOS.
Интерпретатор Microsoft(R) ([.filename]#acpi.sys# и [.filename]#acpiec.sys#) не занимается проверкой четкости соблюдения стандартов, поэтому многие поставщики BIOS, проверяющие ACPI только под Windows(R), никогда не исправляют ASL.
Разработчики FreeBSD продолжают идентифицировать и документировать, какое именно нестандартное поведение разрешается интерпретатором Microsoft(R), а также воспроизводить его, чтобы FreeBSD могла работать без необходимости исправления ASL пользователями.
В качестве обходного пути и в качестве помощи в идентификации поведения, исправляйте ASL вручную.
Если это срабатывает, отправьте файл man:diff[1] разницы между старым и новым ASL, чтобы разработчики, возможно, смогли реализовать обходной путь для ошибочного поведения в ACPI-CA, делая исправление ненужным.

Вот список наиболее часто встречающихся проблем, их причин и способы исправления:

==== Зависимости от ОС

Некоторые AML предполагают, что мир состоит из различных версий Windows(R). Вы можете настроить FreeBSD, чтобы она сообщала любое другое имя OS и посмотреть, исправит ли это имеющуюся проблему. Простой способ указания другого имени системы это установка переменной [.filename]#/boot/loader.conf#`hw.acpi.osname="Windows 2001"` или в другое подобное значение, имеющееся в ASL.

==== Отсутствующие команды возврата

Некоторые методы не возвращают значение явно, как того требует стандарт. Хотя ACPI-CA не обрабатывает эту ситуацию, в FreeBSD существует обходной путь, позволяющей ей явно возвращать значение.
Если вы знаете, какое значение должно быть возвращено, то там, где требуется, могут быть добавлены явно указанные директивы Return.
Для принудительной компиляции ASL командой `iasl` используйте флаговый парааметр `-f`.

==== Перезапись AML по умолчанию

После внесения изменений в [.filename]#your.asl# скомпилируйте его этой командой:

[source,shell]
....
# iasl your.asl
....

Добавление флага `-f` приведёт к принудительному созданию AML, даже при наличии ошибок во время компиляции.
Некоторые ошибки, такие как отсутствие операторов Return, автоматически обходятся интерпретатором.

Файл [.filename]#DSDT.aml# используется `iasl` по умолчанию.
Загрузите этот файл вместо копии BIOS с ошибками, которая всё ещё присутствует во флэш-памяти, отредактировав [.filename]#/boot/loader.conf# следующим образом:

[.programlisting]
....
acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"
....

Убедитесь, что скопировали [.filename]#DSDT.aml# в каталог [.filename]#/boot#.

[[ACPI-debugoutput]]
=== Получение отладочной информации от ACPI

Драйвер ACPI обладает очень гибкими средствами отладки.
Могут быть указаны набор подсистем и уровень детализации.
Подсистемы для отладки указываются как "слои" и разделяется на компоненты ACPI-CA (ACPI_ALL_COMPONENTS) и поддержку оборудования ACPI (ACPI_ALL_DRIVERS).
Уровень детализации диагностических сообщений указывается как "level" и варьируется от ACPI_LV_ERROR (сообщать только об ошибках) до ACPI_LV_VERBOSE (всё).
Уровень отладки представляет собой битовую маску, поэтому возможна одновременная установка нескольких параметров, разделенных пробелами.
На практике, если выдаваемая информация настолько объёмна, что переполняет буфер консольных сообщений, то для протоколирования выдаваемой информации должна использоваться последовательная консоль.
Полный список отдельных слоёв и уровней находится в man:acpi[4].

Вывод отладочной информации по умолчанию не активирован.
Для его включения добавьте параметр `options ACPI_DEBUG` к соответствующему файлу конфигурации ядра, если ACPI встраивается в ядро.
Добавьте `ACPI_DEBUG=1` в [.filename]#/etc/make.conf# для его глобальной активации.
Если это модуль, перекомпилируйте только [.filename]#acpi.ko# следующим образом:

[source,shell]
....
# cd /sys/modules/acpi/acpi
 make clean  make
ACPI_DEBUG=1
....

Установите [.filename]#acpi.ko# в [.filename]#/boot/kernel# и добавьте соответствующий предпочитаемый уровень и слой к [.filename]#loader.conf#.
Этот пример активирует диагностические сообщения для всех компонентов ACPI-CA и всех драйверов оборудования ACPI, такого как CPU и LID.
Он выводит только сообщения об ошибках с наименьшим уровнем детализации.

[.programlisting]
....
debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"
....

Если требуемая информация формируется в результате определённого события, например, приостановки с последующим возобновлением работы, не вносите изменения в [.filename]#loader.conf#, но вместо этого используйте `sysctl` для указания слоя и уровня `sysctl` после загрузки и подготовки системы к определённому событию.
Переменные `sysctl` имеют те же имена, что и настроечные параметры в [.filename]#loader.conf#.

[[ACPI-References]]
=== Ссылки

Дальнейшую информацию о ACPI можно найти по следующим ссылкам:

* {freebsd-acpi}
* Архивы списка рассылки ACPI http://lists.freebsd.org/pipermail/freebsd-acpi/[http://lists.freebsd.org/pipermail/freebsd-acpi/]
* Старые архивы списка рассылки ACPI http://home.jp.FreeBSD.org/mail-list/acpi-jp/[http://home.jp.FreeBSD.org/mail-list/acpi-jp/]
* https://uefi.org/specifications#ACPI[Спецификация ACPI]
* Страницы справочника FreeBSD: man:acpi[4], man:acpi_thermal[4], man:acpidump[8], man:iasl[8], man:acpidb[8]
* http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt[ Ресурс по отладке DSDT]. (Использует в качестве примера Compaq, но обычно полезен.)
