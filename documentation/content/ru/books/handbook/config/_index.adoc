//
// The FreeBSD Russian Documentation Project
//
// Original RU revision (18.02.2025): 54ac237fdb34d9074316cd8f8a77832bd618e4f6
//
// Original EN revision (SVN): 39900
//

---
title: Глава 12. Настройка и оптимизация
part: Часть III. Системное администрирование
prev: books/handbook/partiii
next: books/handbook/boot
showBookMenu: true
weight: 16
params:
  path: "/books/handbook/config/"
---

[[config-tuning]]
= Настройка и оптимизация
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 12
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/config/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[config-synopsis]]
== Введение

Один из важных аспектов FreeBSD это настройка системы. Правильная настройка системы поможет избежать головной боли при последующих обновлениях. Эта глава описывает большую часть процесса настройки FreeBSD, включая некоторые параметры, которые можно установить для оптимизации системы FreeBSD.

После прочтения этой главы вы узнаете:

* Как эффективно работать с файловыми системами и разделами подкачки.
* Основы настройки [.filename]#rc.conf# и системы запуска приложений [.filename]#/usr/local/etc/rc.d#.
* Как настроить и протестировать сетевую карту.
* Как настроить виртуальные хосты на сетевых устройствах.
* Как использовать различные файлы конфигурации в [.filename]#/etc#.
* Как оптимизировать FreeBSD, используя переменные `sysctl`.
* Как увеличить скорость работы дисков и изменить ограничения, накладываемые ядром.

Перед прочтением этой главы вам следует:

* Понять основы UNIX(R) и FreeBSD (crossref:basics[basics, Основы FreeBSD]).
* Ознакомиться с основами конфигурации/компиляции ядра (crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]).

[[configtuning-initial]]
== Начальное конфигурирование

=== Разделы диска

==== Основы построения разделов

Во время разметки жёсткого диска с помощью man:bsdlabel[8] или man:sysinstall[8] важно помнить, что скорость чтения и записи данных уменьшается от внешних к внутренним трекам диска.
Таким образом, файловые системы меньшего размера и часто используемые должны быть ближе к внешнему краю диска, а более крупные, такие как [.filename]#/usr#, должны размещаться ближе к внутренним частям диска.
Хорошей идеей является создание разделов в порядке, подобном следующему: root, swap, [.filename]#/var#, [.filename]#/usr#.

Размер раздела [.filename]#/var# отражает предполагаемое использование машины.
Файловая система [.filename]#/var# используется для хранения почтовых ящиков, файлов журналов и очередей печати.
Размер почтовых ящиков и файлов журналов может вырасти до неожидаемых размеров неограниченно в зависимости от количества существующих пользователей и продолжительности хранения файлов журналов.
Большинству пользователей редко требуется более чем примерно гигабайта свободного дискового пространства в [.filename]#/var#.

[NOTE]
====
Есть несколько случаев, когда в [.filename]#/var/tmp# требуется много дискового пространства.
Когда при помощи man:pkg.add[1] устанавливается новое программное обеспечение, инструменты работы с пакетами разворачивают временную копию пакетов в [.filename]#/var/tmp#.
Если в [.filename]#/var/tmp# нет достаточного объёма дискового пространства, установка крупных пакетов программного обеспечения, подобных Firefox, OpenOffice или LibreOffice, может быть затруднена.
====

Раздел [.filename]#/usr# содержит многие их тех файлов, что необходимы для поддержки системы, в том числе рекомендуемую Коллекцию портов (man:ports[7]) и (необязательный) исходный код.
Как порты, так и исходный код базового комплекта системы не являются обязательными на этапе установки системы, однако мы рекомендуем выделять для этого раздела не менее 2 гигабайт.

При выборе объёмов разделов, не забудьте принять во внимание рост размера требуемого системе дискового пространства. Переполнение одного раздела даже при наличии свободного места на другом может вызвать затруднения.

[NOTE]
====
Многие пользователи обнаружили, что размер разделов, предлагаемый man:sysinstall[8]'ом по умолчанию, иногда меньше подходящего для разделов [.filename]#/var# и [.filename]#/#. Тщательно планируйте размер разделов и не жалейте места.
====

[[swap-design]]
==== Раздел подкачки

Как правило, размер раздела подкачки должен быть равен удвоенному размеру оперативной памяти. Например, если на машине установлено 128 мегабайт памяти, раздел подкачки должен быть 256 мегабайт. Системы с меньшим количеством памяти могут работать лучше с большим объёмом раздела подкачки. Не рекомендуется устанавливать размер раздела подкачки меньше 256 мегабайт, необходимо также принять во внимание возможное наращивание объема установленной на машине памяти. Алгоритмы кэширования VM настроены на максимальное быстродействие, когда размер раздела подкачки равен как минимум удвоенному размеру памяти. Заниженный размер раздела подкачки может привести к неэффективной работе постраничного сканирования VM и вызвать проблемы при увеличении объёма памяти.

На больших системах с несколькими SCSI дисками (или несколькими IDE дисками, находящимися на разных контроллерах), рекомендуется создавать раздел подкачки на каждом диске (до четырёх дисков). Разделы подкачки должны быть примерно одного размера. Ядро не накладывает ограничений на размер раздела подкачки, но внутренние структуры позволяют иметь общий размер разделов подкачки, равный наибольшему, умноженному на четыре. Выделение под разделы подкачки примерно одинакового места позволить ядру оптимально расположить разделы подкачки. Установка размера подкачки больше требуемого нормальна, даже если этот объем не используется. В этих условиях может быть проще восстановиться после зависания программы перед тем, как возникнет необходимость перезагрузки.

==== Зачем нужны разделы?

Некоторые пользователи считают, что лучше использовать один большой раздел, но есть несколько причин, по которым этого лучше не делать. Во-первых, у каждого раздела свои характеристики, и отделяя их, можно выполнить соответствующие настройки. Например, корневая и файловая система и [.filename]#/usr# в основном предназначены для чтения, без большого объема записи. В то же время множество операций чтения и записи выполняется в [.filename]#/var# и [.filename]#/var/tmp#.

При правильном размещении и выборе размера разделов системы, фрагментация в более маленьких разделах, куда часто записываются данные, не перенесётся на остальные разделы. Размещение самых часто используемых разделов ближе к началу диска увеличит скорость ввода/вывода там, где она нужна больше всего. Хотя производительность важна и для больших дисков, передвижение их ближе к концу диска не повлечёт значительного уменьшения быстродействия по сравнению с перемещением ближе к концу диска [.filename]#/var#. И, наконец, разделы существуют и из соображений безопасности. Наличие маленького аккуратного корневого раздела, доступного только для чтения даёт значительные шансы на "выживание" после краха системы.

[[configtuning-core-configuration]]
== Основные настройки

Основные настройки системы располагаются в [.filename]#/etc/rc.conf#. Этот файл вмещает широкий спектр конфигурационной информации, используемой при загрузке системы. Имя этого файла прямо отражает его назначение, это файл настройки для файлов [.filename]#rc*#.

Администратор должен сделать записи в [.filename]#rc.conf#, чтобы переопределить строки по умолчанию из [.filename]#/etc/defaults/rc.conf#. Файлы по умолчанию нельзя копировать в [.filename]#/etc# - они вмещают значения по умолчанию, а не примеры значений. Все специфичные для данной системы изменения должны быть сделаны в файле [.filename]#rc.conf#.

Для кластеризованных приложений существует несколько стратегий отделения общих настроек для всех систем от настроек конкретной системы в целях уменьшения дополнительных работ администратора.
Рекомендуемым методом является помещение настроек конкретной системы в файл [.filename]#/etc/rc.conf.local#.
Например:

* [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
sshd_enable="YES"
keyrate="fast"
defaultrouter="10.1.1.254"
....
+
* [.filename]#/etc/rc.conf.local#:
+
[.programlisting]
....
hostname="node1.example.org"
ifconfig_fxp0="inet 10.1.1.1/8"
....

Затем файл [.filename]#rc.conf# может быть распространён на все системы при помощи `rsync` или похожей программы, в то время как [.filename]#rc.conf.local# остаётся уникальным.

Модернизация системы с помощью man:sysinstall[8] или `make world` не повлекут за собой перезаписи [.filename]#rc.conf#.
Вся информация в этом файле сохранится.

[TIP]
====
Конфигурационный файл [.filename]#/etc/rc.conf# обрабатывается при помощи man:sh[1].
Это позволяет системным операторам добавлять определённую логику в этот файл, что может помочь в создании очень сложных конфигурационных сценариев.
Пожалуйста, обратитесь к man:rc.conf[5] для получения дополнительной информации по этой теме.
====

[[configtuning-appconfig]]
== Настройка приложений

Обычно, установленные приложения имеют свои конфигурационные файлы, со своим собственным синтаксисом. Важно хранить эти файлы отдельно от файлов основной системы, чтобы их можно было легко администрировать с помощью средств управления пакетами.

Обычно эти файлы устанавливаются в [.filename]#/usr/local/etc#. В случае, если приложению нужно большое количество конфигурационных файлов, для их хранения будет создан подкаталог.

Обычно, вместе с установкой портов и пакетов, устанавливаются и примеры конфигурационных файлов. Обычно они имеют расширение [.filename]#.default#. Если не существует конфигурационных файлов для этого приложения, они будут созданы путём копирования [.filename]#.default# файлов.

Например, [.filename]#/usr/local/etc/apache#:

....
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default
....

Размеры файлов показывают, что только файл [.filename]#srm.conf# был изменён. При следующем обновлении Apache этот файл уже не будет перезаписан.

[[configtuning-starting-services]]
== Запуск сервисов

Многие пользователи предпочитают устанавливать программы сторонних производителей в FreeBSD из набора портов. В подобных случаях может потребоваться сконфигурировать программы так, чтобы они запускались при инициализации системы. Сервисы, такие как package:mail/postfix[] или package:www/apache22[], являются лишь двумя примерами из множества программных пакетов, которые можно запускать при инициализации системы. В этом разделе описывается процедура, предназначенная для запуска программ сторонних разработчиков.

Большинство входящих в FreeBSD сервисов, таких как man:cron[8], запускается с помощью стартовых скриптов системы. Эти скрипты могут различаться в зависимости от версии FreeBSD или ее производителя; однако важнее всего учитывать, что их начальную конфигурацию можно задать с помощью простых стартовых скриптов.

=== Расширенное конфигурирование приложения

Теперь, когда FreeBSD включает [.filename]#rc.d#, конфигурирование запуска приложений стало более оптимальным; фактически, оно стало более тщательным. С помощью ключевых слов, рассмотренных в разделе <<configtuning-rcd,rc.d>>, приложения теперь можно настроить для запуска после других заданных сервисов, например, DNS; можно разрешить передачу дополнительных флагов через [.filename]#rc.conf# вместо жесткого задания флагов в стартовых скриптах, и т.д. Простой скрипт может иметь следующий вид:

[.programlisting]
....
#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command="/usr/local/sbin/utility"

load_rc_config $name

#
# НЕ МЕНЯЙТЕ ЗДЕСЬ ЭТИ СТАНДАРТНЫЕ ЗНАЧЕНИЯ
# ЗАДАВАЙТЕ ИХ В ФАЙЛЕ /etc/rc.conf
#
utility_enable=${utility_enable-"NO"}
pidfile=${utility_pidfile-"/var/run/utility.pid"}

run_rc_command "$1"
....

Этот скрипт будет обеспечить то, что указанное приложение utility будет запущено после псевдо-сервиса `DAEMON`.
Он также предоставляет инструмент для создания и отслеживания файла идентификатора процесса, PID.

Для этого приложения затем можно поместить следующую строку в файл [.filename]#/etc/rc.conf#:

[.programlisting]
....
utility_enable="YES"
....

Этот метод также позволяет легко работать с аргументами командной строки, включать стандартные функции из файла [.filename]#/etc/rc.subr#, обеспечивает совместимость с утилитой man:rcorder[8] и упрощает конфигурирование с помощью файла [.filename]#rc.conf#.

=== Использование сервисов для запуска сервисов

Другие сервисы, такие как даемоны серверов POP3, IMAP и тому подобные, могут быть запущены с помощью man:inetd[8].
Для этого необходимо установить сервисную утилиту из набора портов и добавить соответствующую строчку конфигурации в файл [.filename]#/etc/inetd.conf# или раскомментировать подходящую строку конфигурации из уже имеющихся.
Работа с даемоном inetd и его конфигурирование подробно описаны в разделе crossref:network-servers[network-inetd,inetd].

В некоторых случаях может быть более разумным использование для запуска системных служб даемона man:cron[8].
Такой подход имеет несколько преимуществ, поскольку даемон `cron` запускает эти процессы от имени владельца файла [.filename]#crontab#. Это позволяет обычным пользователям запускать и поддерживать некоторые приложения.

Утилита `cron` поддерживает уникальную возможность, `@reboot`, - это значение можно использовать вместо спецификации времени. В результате, задание будет выполнено при запуске man:cron[8], обычно - в ходе инициализации системы.

[[configtuning-cron]]
== Настройка утилиты `cron`

Одна из наиболее полезных утилит FreeBSD это man:cron[8]. Утилита `cron` работает в фоновом режиме и постоянно проверяет файл [.filename]#/etc/crontab#. Утилита `cron` проверяет также каталог [.filename]#/var/cron/tabs# в поиске новых файлов [.filename]#crontab#. Файлы [.filename]#crontab# содержат информацию об определенных функциях, которые `cron` выполняет в указанное время.

Утилита `cron` использует два разных вида конфигурационных файлов, системный и пользовательский.
Эти форматы отличаются только в шестом и последующем полях.
В случае системного файла `cron` будет запускать команду с полномочиями пользователя, указанного в шестом поле.
В случае пользовательского файла все команды запускаются с полномочиями пользователя, создавшего файл, так что шестое поле является последним; это важная особенность с точки зрения безопасности.
Последним полем всегда является запускаемая команда.

[NOTE]
====
Пользовательские crontab позволяют индивидуальным пользователям планировать задачи без привилегий суперпользователя (`root`). Команды из crontab пользователя запускаются с привилегиями этого пользователя.

Пользователь `root` может иметь собственный crontab, как и любой другой пользователь.
Файл пользователя `root` существует отдельно от [.filename]#/etc/crontab# (системного файла crontab).
Поскольку системный crontab фактически запускает указанные команды как root, то обычно создавать пользовательский crontab для `root` не требуется.
====

Давайте заглянем в [.filename]#/etc/crontab#, который является файлом crontab для системы:

[.programlisting]
....
# /etc/crontab - root's crontab for FreeBSD
#
# $FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp $
## <.>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <.>
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <.>
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <.>
....

<.> Как и в большинстве конфигурационных файлов FreeBSD, строки, начинающиеся с символа `#`, являются комментариями.  Комментарии нужны для напоминания о том, что означает строка и зачем она добавлена. Комментарии не могут находиться на той же строке, что и команда, или они будут восприняты как часть команды; располагайте их на новой строке. Пустые строки игнорируются.

<.> Сначала должны быть заданы переменные окружения. Знак равно (`=`) используется для задания переменных окружения, в этом примере `SHELL`, `PATH`, и `HOME`. Если переменная для оболочки не задана, `cron` использует оболочку по умолчанию, `sh`. Если не задана переменная `PATH`, значение по умолчанию не устанавливается и пути к файлам должны быть полными. Если не задана переменная `HOME`, `cron` будет использовать домашний каталог соответствующего пользователя.

<.> В строке всего семь полей. Их значения `minute`, `hour`, `mday`, `month`, `wday`, `who` (кто), и `command`. Значение полей почти очевидно. `minute` это время в минутах, когда будет запущена команда. `hour` означает то же самое для часов. `mday` означает день месяца. `month`, это то же самое, что час и минута, но для месяцев. Параметр `wday` это день недели. Все эти поля должны быть в числовом формате, время в двадцатичетырехчасовом исчислении. Поле `who` имеет специальное значение, и присутствует только в файле [.filename]#/etc/crontab#.  Это поле определяет пользователя, с полномочиями которого должна быть запущена команда.  Последнее поле является командой, которая должна быть выполнена.

<.> Последняя строка определяет параметры, описанные выше. Здесь задано значение `\*/5`, и несколько символов `\*`. Эти символы `*` означают "первый-последний", и могут быть интерпретированы как _каждый_. Таким образом, для этой строки соответствующая команда `atrun` вызывается под пользователем `root` каждые пять минут независимо от дня или месяца. За дополнительной информацией по команде `atrun` обращайтесь к странице справочника man:atrun[8].Команды могут принимать любое количество параметров; однако команды, состоящие из нескольких строк, должны быть объединены символом "\".

Такова базовая конфигурация каждого файла [.filename]#crontab#, однако имеется один нюанс.
Шестое поле, где мы указали имя пользователя, присутствует только в системном файле [.filename]#crontab#.
Это поле должно быть исключено из пользовательских файлов [.filename]#crontab#.

[[configtuning-installcrontab]]
=== Установка crontab

[IMPORTANT]
====
Не используйте процедуру, описанную здесь, для редактирования и установки системного файла crontab, [.filename]#/etc/crontab#.
Просто используйте предпочитаемый текстовый редактор: утилита `cron` узнает о том, что файл изменился, и сразу начнёт использовать обновлённую версию.
Обратитесь к extref:{faq}[этой части FAQ, ROOT-NOT-FOUND-CRON-ERRORS] за дальнейшей информацией.
====

Для установки готового [.filename]#crontab# пользователя, сначала создайте в вашем любимом редакторе файл соответствующего формата, а затем воспользуйтесь утилитой `crontab`. Обычно она запускается так:

[source,shell]
....
% crontab crontab-file
....

В этом примере, [.filename]#crontab-file# это имя файла crontab, который только что был создан.

Существует также параметр для просмотра установленных файлов [.filename]#crontab#: задайте `crontab` параметр `-l`.

Для пользователей, составляющих crontab вручную, без временного файла, существует параметр `crontab -e`. Она вызовет редактор с пустым файлом. Когда файл будет сохранен, `crontab` автоматически установит его.

Для того, чтобы полностью удалить пользовательский файл [.filename]#crontab#, используйте `crontab` с параметром `-r`.

[[configtuning-rcd]]
== Использование man:rc[8] во FreeBSD

В 2002 году во FreeBSD была интегрирована из NetBSD система [.filename]#rc.d#, используемая для старта системы. Многие из файлов в каталоге [.filename]#/etc/rc.d# предназначены для основных сервисов, они могут управляться параметрами `start`, `stop`, и `restart`. Например, man:sshd[8] может быть перезапущен следующей командой:

[source,shell]
....
# /etc/rc.d/sshd restart
....

Эта процедура похожа для других сервисов. Конечно, сервисы обычно запускаются автоматически при загрузке системы, как указано в man:rc.conf[5]. Например, включение даемона Network Address Translation при запуске выполняется простым добавлением следующей строки в [.filename]#/etc/rc.conf#:

[.programlisting]
....
natd_enable="YES"
....

Если `natd_enable="NO"` уже присутствует, просто измените `NO` на `YES`. Скрипты rc автоматически загрузят все другие зависимые сервисы, как описано ниже.

Поскольку система [.filename]#rc.d# в основном предназначена для запуска/отключения сервисов во время запуска/отключения системы, стандартные параметры `start`, `stop` и `restart` будут работать только если установлена соответствующая переменная в [.filename]#/etc/rc.conf#. Например, команда выше `sshd restart` будет работать только если переменная `sshd_enable` в файле [.filename]#/etc/rc.conf# установлена в `YES`.
Для выполнения скриптов независимо от установок в [.filename]#/etc/rc.conf#, параметры `start`, `stop` или `restart` необходимо задавать с префиксом "one".
Например, для перезапуска `sshd` независимо от параметров в [.filename]#/etc/rc.conf#, выполните следующую команду:

[source,shell]
....
# /etc/rc.d/sshd onerestart
....

Проверить состояние переменной в файле [.filename]#/etc/rc.conf# легко: запустите соответствующий скрипт из [.filename]#rc.d# с параметром `rcvar`. Проверка переменной для `sshd` выполняется следующей командой:

[source,shell]
....
# /etc/rc.d/sshd rcvar
# sshd
$sshd_enable=YES
....

[NOTE]
====
Вторая строка (`# sshd`) это вывод команды `sshd`, а не консоль `root`.
====

Чтобы определить, запущен ли сервис, существует параметр `status`. Например для проверки того, запущен ли `sshd`, выполните:

[source,shell]
....
# /etc/rc.d/sshd status
sshd is running as pid 433.
....

В некоторых случаях возможна также перегрузка (`reload`) сервиса. Скрипт, запущенный с этим параметром, попытается отправить сервису сигнал, вызывающий перезагрузку файлов настройки. В большинстве случаев это означает отправку сервису сигнала `SIGHUP`. Следует помнить, что эту функцию поддерживают не все сервисы.

Система [.filename]#rc.d# используется не только для сетевых серверов, она отвечает также за большую часть инициализации системы. Рассмотрим, к примеру, файл [.filename]#bgfsck#. Во время выполнения этот скрипт выводит следующее сообщение:

[source,shell]
....
Starting background file system checks in 60 seconds.
....

Следовательно, этот файл используется для фоновой проверки файловых систем, которая выполняется только в процессе инициализации системы.

Функционирование многих сервисов системы зависит от корректной работы других сервисов. Например, NIS и другие основанные на RPC сервисы могут не запуститься, пока не загрузится `rpcbind` (portmapper). Для разрешения этой проблемы, в начале каждого скрипта в комментарии включаются информация о зависимостях и другие метаданные.
Затем во время запуска системы используется программа man:rcorder[8] для обработки этих комментариев и определения порядка, в котором должны вызываться системные сервисы в соответствии со взаимными зависимостями.

Во все стартовые скрипты должны быть включены следующие слова (их требует man:rc.subr[8] для "включения" стартовых скриптов):

* `PROVIDE`: Задаёт сервисы, предоставляемые этим файлом.

Следующие слова могут быть включены в начало каждого стартового файла.
Они не являются строго обязательными, однако полезны в качестве подсказок для man:rcorder[8]:

* `REQUIRE`: Перечисляет сервисы, необходимые этому сервису. Этот файл будет запущен _после_ указанных сервисов.
* `BEFORE`: Перечисляет сервисы, зависящие от этого сервиса. Этот файл будет запущен _до_ указанных сервисов.

При помощи аккуратного указания этих ключевых слов для каждого стартового скрипта администратор получает очень детализированный уровень контроля над порядком запуска стартовых скриптов без использования "уровней запуска", как в некоторых других операционных системах UNIX(R).

Дополнительную информацию о системе [.filename]#rc.d# можно найти на страницах справочника man:rc[8] и man:rc.subr[8].
Если вы интересуетесь написанием собственных скриптов [.filename]#rc.d# или улучшении существующих, то extref:{rc-scripting}[эта статья] также может оказаться вам полезной.

[[config-network-setup]]
== Настройка карт сетевых интерфейсов

В наши дни мы не представляем себе компьютера без сетевого подключения. Добавление и настройка сетевой карты это обычная задача любого администратора FreeBSD.

=== Поиск подходящего драйвера

В первую очередь определите тип используемой карты (PCI или ISA), модель карты и используемый в ней чип. FreeBSD поддерживает многие PCI и ISA карты. Обратитесь к Списку поддерживаемого оборудования вашего релиза чтобы узнать, поддерживается ли карта.

Как только вы убедились, что карта поддерживается, потребуется определить подходящий драйвер. В файлах [.filename]#/usr/src/sys/conf/NOTES# и [.filename]#/usr/src/sys/arch/conf/NOTES# находится список драйверов сетевых интерфейсов с информацией о поддерживаемых чипсетах/картах. Если вы сомневаетесь в том, какой драйвер подойдет, прочтите страницу справочника к драйверу. Страница справочника содержит больше информации о поддерживаемом оборудовании и даже о проблемах, которые могут возникнуть.

Если ваша карта широко распространена, вам скорее всего не потребуется долго искать драйвер. Драйверы для широко распространенных карт представлены в ядре [.filename]#GENERIC#, так что ваша карта должна определиться при загрузке, примерно так:

[source,shell]
....
dc0: <82c169 PNIC 10/100BaseTX> port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: <MII bus> on dc0
bmtphy0: <BCM5201 10/100baseTX PHY> PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: [ITHREAD]
dc1: <82c169 PNIC 10/100BaseTX> port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: <MII bus> on dc1
bmtphy1: <BCM5201 10/100baseTX PHY> PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: [ITHREAD]
....

В этом примере две карты используют имеющийся в системе драйвер man:dc[4].

Если драйвер вашей сетевой карты отсутствует в [.filename]#GENERIC#, для ее использования потребуется загрузить подходящий драйвер. Это может быть сделано одним из двух способов:

* Самым лёгким способом является загрузка модуля ядра сетевой карты просто при помощи man:kldload[8] или автоматически во время загрузки, добавив соответствующую строку в файл [.filename]#/boot/loader.conf#. Не все драйверы сетевых адаптеров доступны в виде модулей; например, что существенно, модули отсутствуют для драйверов адаптеров ISA.
* Вместо этого, вы можете статически включить поддержку карты, скомпилировав собственное ядро. Информацию о том, какие параметры нужно включать в ядро, можно получить из [.filename]#/usr/src/sys/conf/NOTES#, [.filename]#/usr/src/sys/arch/conf/NOTES# и страницы справочника драйвера сетевой карты. За более подробной информацией о сборке собственного ядра обращайтесь к crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]. Если карта была обнаружена вашим ядром ([.filename]#GENERIC#) во время загрузки, собирать ядро не потребуется.

[[config-network-ndis]]
==== Использование NDIS-драйверов Windows(R)

К сожалению, всё ещё много производителей не предоставляют схем их драйверов сообществу открытого кода, так как считают эту информацию коммерческой тайной.
Соответственно, разработчикам FreeBSD и других операционных систем остаются два варианта: разрабатывать драйверы при помощи долгого и болезненного процесса обратного проектирования либо использовать существующие бинарные файлы драйверов, доступные для платформ Microsoft(R) Windows(R).
Большинство разработчиков, включая тех, что связаны с FreeBSD, выбрали последний подход.

Благодаря вкладу Билла Пола (wpaul) имеется "родная" поддержка NDIS (Network Driver Interface Specification).
Эмулятор NDIS (известный также как Project Evil) принимает бинарный файл Windows(R) и по сути заставляет его полагать, что он работает в Windows(R).
Так как драйвер man:ndis[4] использует бинарный файл Windows(R), он работает только в системах i386 и amd64.
Поддерживаются устройства PCI, CardBus, PCMCIA (PC-Card) и USB.

Для использования эмулятора NDIS необходимы три вещи:

. Исходный код ядра
. Бинарный файл драйвера Windows(R) XP (расширение [.filename]#.SYS#)
. Конфигурационный файл драйвера Windows(R) XP (расширение [.filename]#.INF#)

Поищите файлы для вашего конкретного адаптера.
Вообще говоря, их можно найти на поставляемых CD или на веб-сайте вендора.
В следующих примерах мы будем использовать [.filename]#W32DRIVER.SYS# и [.filename]#W32DRIVER.INF#.

Разрядность драйвера должна соответствовать версии FreeBSD.
В случае FreeBSD/i386 используйте 32-разрядный драйвер Windows(R).
Для FreeBSD/amd64 требуется 64-разрядный драйвер Windows(R).

Следующим шагом является компиляция бинарного файла драйвера в загружаемый модуль ядра.
Используйте man:ndisgen[8] как пользователь `root`:

[source,shell]
....
# ndisgen _/path/to/W32DRIVER.INF_ _/path/to/W32DRIVER.SYS_
....

man:ndisgen[8] работает в интерактивном режиме и запрашивает всю дополнительную информацию, которая требуется.
Новый модуль ядра записывается в текущий каталог.
Используйте man:kldload[8] для загрузки нового модуля:

[source,shell]
....
# kldload _./W32DRIVER_SYS.ko
....

Кроме сгенерированного модуля ядра вы должны загрузить модули [.filename]#ndis.ko# и [.filename]#if_ndis.ko#.
Это должно выполняться автоматически при загрузке любого модуля, зависящего от man:ndis[4].
Если вы хотите загружать их в неавтоматическом режиме, используйте следующие команды:

[source,shell]
....
# kldload ndis
# kldload if_ndis
....

Первая команда загружает оболочку драйвера минипорта NDIS, а вторая загружает реальный сетевой интерфейс.

Теперь проверьте man:dmesg[8] на предмет наличия ошибок загрузки.
Если всё прошло хорошо, вы должны получить выдачу, похожую на следующую:

[source,shell]
....
ndis0: <Wireless-G PCI Adapter> mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps
....

С этого момента вы можете считать устройство `ndis0` таким же сетевым интерфейсом, как и юбое другое (например, `dc0`).

Вы можете настроить систему на загрузку модуля NDIS при загрузке так же, как и для любого другого модуля.
Сначала скопируйте сгенерированный модуль [.filename]#W32DRIVER_SYS.ko# в каталог [.filename]#/boot/modules#.
Затем добавьте в [.filename]#/boot/loader.conf# следующую строку:

[.programlisting]
....
W32DRIVER_SYS_load="YES"
....

=== Настройка сетевой карты

Как только для сетевой карты загружен подходящий драйвер, ее потребуется настроить. Как и многое другое, сетевая карта может быть настроена во время установки с помощью sysinstall.

Для выдачи информации о настройке сетевых интерфейсов системы введите следующую команду:

[source,shell]
....
% ifconfig
dc0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	options=80008<VLAN_MTU,LINKSTATE>
	ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect (100baseTX <full-duplex>)
        status: active
dc1: flags=8802<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=80008<VLAN_MTU,LINKSTATE>
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
plip0: flags=8810<POINTOPOINT,SIMPLEX,MULTICAST> metric 0 mtu 1500
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> metric 0 mtu 16384
        options=3<RXCSUM,TXCSUM>
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
	nd6 options=3<PERFORMNUD,ACCEPT_RTADV>
....

В этом примере были показаны следующие устройства:

* [.filename]#dc0#: первый Ethernet интерфейс
* [.filename]#dc1#: второй Ethernet интерфейс
* [.filename]#plip0#: Интерфейс параллельного порта (если параллельный порт присутствует в машине)
* [.filename]#lo0#: устройство loopback

Для присвоения имени сетевой карте FreeBSD использует имя драйвера и порядковый номер, в котором карта обнаруживается при инициализации устройств. Например, [.filename]#sis2# это третья сетевая карта, использующая драйвер man:sis[4].

В этом примере, устройство [.filename]#dc0# включено и работает. Ключевые признаки таковы:

. `UP` означает, что карта настроена и готова.
. У карты есть интернет (`inet`) адрес (в данном случае `192.168.1.3`).
. Установлена маска подсети (`netmask`; `0xffffff00`, то же, что и `255.255.255.0`).
. Широковещательный адрес (в данном случае, `192.168.1.255`).
. Значение MAC адреса карты (`ether`) `00:a0:cc:da:da:da`
. Выбор физической среды передачи данных в режиме автовыбора (`media: Ethernet autoselect (100baseTX full-duplex)`). Мы видим, что [.filename]#dc1# была настроена для работы с `10baseT/UTP`. За более подробной информацией о доступных драйверу типах среды обращайтесь к странице справочника.
. Статус соединения (`status`) в состоянии `active`, то есть несущая обнаружена. Для [.filename]#dc1#, мы видим `status: no carrier`. Это нормально, когда Ethernet кабель не подключен к карте.

Если в выдаче man:ifconfig[8] присутствует что-то, подобное следующему:

[source,shell]
....
dc0: flags=8843<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500
	options=80008<VLAN_MTU,LINKSTATE>
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX <full-duplex>)
        status: active
....

это означает, что адаптер не был настроен.

Для настройки карты вам потребуются привилегии пользователя `root`. Настройка сетевой карты может быть выполнена из командной строки с помощью man:ifconfig[8], но вам потребуется делать это после каждой перезагрузки системы. Подходящее место для настройки сетевых карт это файл [.filename]#/etc/rc.conf#.

Откройте [.filename]#/etc/rc.conf# в текстовом редакторе. Вам потребуется добавить строку для каждой сетевой карты, имеющейся в системе, например, в нашем случае, было добавлено две строки:

[.programlisting]
....
ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"
....

Замените [.filename]#dc0#, [.filename]#dc1#, и так далее на соответствующие имена ваших карт, подставьте соответствующие адреса. Обратитесь к страницам справочника сетевой карты и man:ifconfig[8], за подробной информацией о доступных опциях и к странице справочника man:rc.conf[5] за дополнительной информацией о синтаксисе [.filename]#/etc/rc.conf#.

Если вы настроили сетевую карту в процессе установки системы, некоторые строки, касающиеся сетевой карты, могут уже присутствовать. Внимательно проверьте [.filename]#/etc/rc.conf# перед добавлением каких-либо строк.

Отредактируйте также файл [.filename]#/etc/hosts# для добавления имен и IP адресов различных компьютеров сети, если их еще там нет. За дополнительной информацией обращайтесь к man:hosts[5] и к [.filename]#/usr/shared/examples/etc/hosts#.

[NOTE]
====
Если с машины планируется доступ в Интернет, то вам также необходимо самостоятельно настроить шлюз и сервер имён:

[source,shell]
....
# echo 'defaultrouter="ваш_маршрутизатор_по_умолчанию"' >> /etc/rc.conf
# echo 'nameserver ваш_сервер_DNS' >> /etc/resolv.conf
....
====

=== Тестирование и решение проблем

Как только вы внесете необходимые изменения в [.filename]#/etc/rc.conf#, перегрузите компьютер. Изменения настроек интерфейсов будут применены, кроме того будет проверена правильность настроек.
Либо вы можете просто перезапустить систему работы с сетью:

[source,shell]
....
# /etc/rc.d/netif restart
....

[NOTE]
====
Если используемый по умолчанию шлюз был настроен в [.filename]#/etc/rc.conf#, также используйте эту команду:

[source,shell]
....
# /etc/rc.d/routing restart
....
====

После того, как система работы с сетью перезапустится, вы должны проверить сетевые интерфейсы.

==== Проверка Ethernet карты

Для проверки правильности настройки сетевой карты, попробуйте выполнить ping для самого интерфейса, а затем для другой машины в локальной сети.

Сначала проверьте локальный интерфейс:

[source,shell]
....
% ping -c5 192.168.1.3
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms
....

Затем проверьте другую машину в локальной сети:

[source,shell]
....
% ping -c5 192.168.1.2
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms
....

Вы можете также использовать имя машины вместо `192.168.1.2`, если настроен файл [.filename]#/etc/hosts#.

==== Решение проблем

Решение проблем с аппаратным и программным обеспечением всегда вызывает сложности, которые можно уменьшить, проверив сначала самые простые варианты. Подключен ли сетевой кабель? Правильно ли настроены сетевые сервисы? Правильно ли настроен брандмауэр? Поддерживается ли используемая карта в FreeBSD? Всегда проверяйте информацию об оборудовании перед отправкой сообщения об ошибке. Обновите FreeBSD до последней версии STABLE. Просмотрите архивы списков рассылки, или поищите информацию в интернет.

Если карта работает, но производительность низка, может помочь чтение страницы справочника man:tuning[7]. Проверьте также настройки сети, поскольку неправильные настройки могут стать причиной низкой скорости соединения.

Некоторые пользователи встречаются с несколькими `device timeouts`, что нормально для некоторых сетевых карт. Если это продолжается и надоедает, убедитесь, что устройство не конфликтует с другим устройством. Внимательно проверьте подключение кабеля. Возможно также, что вам просто надо установить другую карту.

Время от времени, пользователи видят несколько ошибок `watchdog timeout`. Первое, что требуется сделать, это проверить сетевой кабель. Многие карты требуют поддержки Bus Mastering слотом PCI. На некоторых старых материнских платах, только один PCI слот имеет такую поддержку (обычно слот 0). Сверьтесь с документацией на сетевую карту и материнскую плату, чтобы определить, может ли это быть проблемой.

Сообщение `No route to host` появляются, если система не в состоянии доставить пакеты к хосту назначения. Это может случиться, если не определен маршрут по умолчанию, или кабель не подключен. Проверьте вывод команды `netstat -rn` и убедитесь, что к соответствующему хосту есть работающий маршрут. Если это не так, прочтите crossref:advanced-networking[advanced-networking, Сложные вопросы работы в сети].

Сообщения `ping: sendto: Permission denied` зачастую появляются при неправильно настроенном брандмауэре. Если `ipfw` включен в ядре, но правила не определены, правило по умолчанию блокирует весь трафик, даже запросы ping! Прочтите crossref:firewalls[firewalls, Межсетевые экраны] с более подробной информацией.

Иногда скорость карты недостаточна, или ниже среднего. В этих случаях лучше всего изменить режим выбора типа подключения с `autoselect` на правильный тип. Обычно это работает для большинства оборудования, но не может решить проблему во всех случаях. Проверьте еще раз настройки сети и прочтите страницу справочника man:tuning[7].

[[configtuning-virtual-hosts]]
== Настройка виртуальных серверов

Очень часто FreeBSD используется для размещения сайтов, когда один сервер работает в сети как несколько серверов. Это достигается присвоением нескольких сетевых адресов одному интерфейсу.

У сетевого интерфейса всегда есть один "настоящий" адрес, хотя он может иметь любое количество "синонимов" (alias). Эти синонимы обычно добавляются путём помещения соответствующих записей в [.filename]#/etc/rc.conf#.

Синоним для интерфейса [.filename]#fxp0# выглядит следующим образом:

[.programlisting]
....
ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"
....

Заметьте, что записи синонимов должны начинаться с `alias0` и идти далее в определенном порядке (например, `_alias1`, `_alias2`, и т.д.). Конфигурационный процесс остановится на первом по порядку отсутствующем числе.

Определение маски подсети для синонима очень важно, но к счастью, так же просто. Для каждого интерфейса должен быть один адрес с истинной маской подсети. Любой другой адрес в сети должен иметь маску подсети, состоящую из всех единичек (что выражается как `255.255.255.255` или как `0xffffffff`).

Например, рассмотрим случай, когда интерфейс [.filename]#fxp0# подключён к двум сетям, к сети `10.1.1.0` с маской подсети `255.255.255.0` и к сети `202.0.75.16` с маской `255.255.255.240`. Мы хотим, чтобы система была видна по IP, начиная с `10.1.1.1` по `10.1.1.5` и с `202.0.75.17` по `202.0.75.20`. Как было сказано выше, только первый адрес в заданном диапазоне (в данном случае, `10.0.1.1` и `202.0.75.17`) должен иметь реальную маску сети; все остальные (с `10.1.1.2` по `10.1.1.5` и с `202.0.75.18` по `202.0.75.20`) должны быть сконфигурированы с маской сети `255.255.255.255`.

Для этого в файл [.filename]#/etc/rc.conf# должны быть внесены следующие записи:

[.programlisting]
....
ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"
....

[[configtuning-syslog]]

== Настройка системного регистратора событий syslogd

Протоколирование системы является важным аспектом системного администрирования.
Оно используется для обнаружения ошибок в системе и проблем с оборудованием и программным обеспечением.
Оно также играет очень важную роль в аудите безопасности и реагировании на инциденты.
Системные даемоны без управляющего терминала также обычно протоколируют информацию через системные функции регистрации или другой файл журнала.

В этом разделе будет описано, как настроить и использовать системный регистратор FreeBSD, man:syslogd[8], а также будут рассмотрены ротирование журналов и управление ими посредством man:newsyslog[8].
Внимание будет сосредоточено на настройке и использовании `syslogd` на локальной машине.
В случае более комплексных конфигураций, использующих отдельную машину для протоколирования, обратитесь к разделу <<network-syslogd>>.

=== Использование syslogd

В стандартной конфигурации FreeBSD man:syslogd[8] запускается при загрузке.
Это управляется при помощи переменной `syslogd_enable` в [.filename]#/etc/rc.conf#.
Имеется множество параметров приложения, которые влияют на поведение man:syslogd[8].
Для их изменения используйте `syslogd_flags` в [.filename]#/etc/rc.conf#.
Обратитесь к man:syslogd[8] для получения дополнительной информации о параметрах, а также к man:rc.conf[5], разделам <<configtuning-core-configuration>> и <<configtuning-rcd>> за дополнительной информацией о [.filename]#/etc/rc.conf# и подсистеме man:rc[8].

=== Настройка syslogd

Конфигурационный файл, которым по умолчанию является [.filename]#/etc/syslog.conf#, управляет тем, что делает man:syslogd[8] с записями о журналируемых событиях при их получении.
Имеется несколько параметров для управления обработкой поступающих событий, из которых самыми основными являются _facility_ (объект или подсистема) и _level_ (уровень).
Объект описывает, какая подсистема сформировала сообщение, например, ядро или даемон, а уровень описывает степень серьёзности произошедшего события.
Это делает возможным записывать события в разные файлы регистрации либо отбрасывать их в зависимости от подсистемы и важности.
Также возможно осуществление действий в зависимости от приложения, которое направило сообщение, а в случае удалённого протоколирования и от имени хоста машины, сформировавшей регистрируемое событие.

Настройка man:syslogd[8] достаточно незамысловата.
Конфигурационный файл состоит из строк, по одной на каждое действие, а синтаксически каждая строка состоит из поля выбора (селектора), за которым следует поле действия.
Поле выбора имеет вид _объект.уровень_, которое будет соотноситься с сообщениями о событиях от _объекта_ с уровнем серьёзности, соответствующим или превышающим _уровень_.
Перед уровнем можно добавить необязательный флажковый параметр сравнения для более точного указания того, что протоколируется.
Для одного и того же действия могут использоваться несколько селекторов, они разделяются точкой с запятой (`;`).
Используемый символ `*` будет соответствовать любому значению.
Поле действия указывает, куда направлять журналируемое сообщение, например, в файл или на удалённую протоколирующую машину.
В качестве примера это файл [.filename]#syslog.conf# из FreeBSD, используемый по умолчанию:

[.programlisting]
....
# $FreeBSD$
#
#	Spaces ARE valid field separators in this file. However,
#	other *nix-like systems still insist on using tabs as field
#	separators. If you are sharing this file between systems, you
#	may want to use only tabs as field separators here.
#	Consult the man:syslog.conf[5] manpage.
*.err;kern.warning;auth.notice;mail.crit	/dev/console <.>
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err	/var/log/messages
security.*					/var/log/security
auth.info;authpriv.info				/var/log/auth.log
mail.info					/var/log/maillog <.>
lpr.info					/var/log/lpd-errs
ftp.info					/var/log/xferlog
cron.*						/var/log/cron
*.=debug					/var/log/debug.log <.>
*.emerg						*
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info					/var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!ppp <.>
*.*						/var/log/ppp.log
!*
....

<.> Выбирать все сообщения с уровнем `err` и выше, а также `kern.warning`, `auth.notice` и `mail.crit`, при этом направлять эти сообщения о событиях на консоль ([.filename]#/dev/console#).
<.> Выбирать все сообщения от подсистемы `mail` с уровнем `info` и выше, при этом протоколировать эти сообщения в [.filename]#/var/log/maillog#.
<.> В этой строке используется флаг сравнения `=` для выбора сообщений только с уровнем `debug` и записи их в [.filename]#/var/log/debug.log#.
<.> Это пример использования функции _указания программы_. При этом последующие правила будут применяться только для указанной программы. В данном случае эта строка и последующие заставляют все сообщения от `ppp`, но не от других программ, направляться в [.filename]#/var/log/ppp.log#.

Этот пример показывает, что существует достаточное количество уровней и подсистем.
Имеются следующие уровни, в порядке снижения уровня критичности: `emerg`, `alert`, `crit`, `err`, `warning`, `notice`, `info` и `debug`.
Объекты без определённого порядка перечисления таковы: `auth`, `authpriv`, `console`, `cron`, `daemon`, `ftp`, `kern`, `lpr`, `mail`, `mark`, `news`, `security`, `syslog`, `user`, `uucp` и `local0` до `local7`.
Имейте в виду, что в других операционных системах могут быть подсистемы, отличающиеся от указанных.

Зная это, легко добавить новую строку в [.filename]#/etc/syslog.conf# для регистрации всех событий от различных даемонов на уровне `notice` и выше в файле [.filename]#/var/log/daemon.log#. Просто добавьте следующее:

[.programlisting]
....
daemon.notice					/var/log/daemon.log
....

Для получения дополнительной информации о различных уровнях и подсистемах, обратитесь к man:syslog[3] и man:syslogd[8].
Для получения дополнительной информации о [.filename]#syslog.conf# и его синтаксисе, а также дополнительных примеров расширенного использования обратитесь к man:syslog.conf[5] и разделу <<network-syslogd>>.

=== Управление журналами событий и ротацией при помощи newsyslog

Журналы событий имеют свойство быстро расти и постоянно накапливать данные.
Это приводит к тому, что файлы полны информацией, полезность которой невелика для использования в данный момент, при этом они занимают место на жёстком диске.
Для исключения этого в игру включается управление журналами событий.
Во FreeBSD в качестве инструмента управления файлами журналов событий применяется man:newsyslog[8].
Эта программа используется для периодической ротации и сжатия файлов журналов, а при необходимости создания отсутствующих файлов и уведомления программ при перемещении файлов.
Файлы журналов не обязательно должны происходить от syslog; man:newsyslog[8] работает с любыми журналами, записываемыми любыми программами.
Важно отметить, что `newsyslog` обычно запускается при помощи man:cron[8], и не является системным даемоном.
В стандартной конфигурации он запускается каждый час.

==== Настройка newsyslog

Для того, чтобы понимать, какие действия нужно предпринимать, man:newsyslog[8] считывает свой конфигурационный файл, которым по умолчанию яявляется [.filename]#/etc/newsyslog.conf#.
В данном конфигурационном файле для каждого файла, управляемого man:newsyslog[8], выделена одна строка.
В каждой строке указан владелец файла, полномочия и то, когда ротировать файл, а также необязательные флажковые параметры, которые влияют на ротацию журнала (например, на сжатие), и программы для уведомления при ротации журнала.


[.filename]#newsyslog.conf# - конфигурационный файл man:newsyslog[8], программы, обычно контролируемой man:cron[8]. man:newsyslog[8] определяет, когда лог-файлы нуждаются в архивировании и перегруппировке. [.filename]#logfile# перемещается в [.filename]#logfile.0#, [.filename]#logfile.0# перемещается в [.filename]#logfile.1#, и так далее. Другое именование получится при архивировании с помощью man:gzip[1]: [.filename]#logfile.0.gz#, [.filename]#logfile.1.gz#, и т.д.

[.filename]#newsyslog.conf# показывает, какие лог файлы должны быть проинспектированы, сколько их должно быть сохранено, и когда они должны быть пересмотрены. Лог файлы могут быть перегруппированы и/или заархивированы, когда они либо достигнут определённого размера, либо при достижении определённых даты/времени.
В качестве примера это конфигурационный файл FreeBSD, используемый по умолчанию:

[.programlisting]
....
# configuration file for newsyslog
# $FreeBSD$
#
# Entries which do not specify the '/pid_file' field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the 'N' flag.
#
# The 'flags' field is one or more of the letters: BCDGJNUXZ or a '-'.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename		[owner:group]	mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log			600  7     *    @T00  J
/var/log/amd.log			644  7     100  *     J
/var/log/auth.log			600  7     100  @0101T JC
/var/log/console.log			600  5     100  *     J
/var/log/cron				600  3     100  *     JC
/var/log/daily.log			640  7     *    @T00  JN
/var/log/debug.log			600  7     100  *     JC
/var/log/init.log			644  3     100  *     J
/var/log/kerberos.log			600  7     100  *     J
/var/log/lpd-errs			644  7     100  *     JC
/var/log/maillog			640  7     *    @T00  JC
/var/log/messages			644  5     100  @0101T JC
/var/log/monthly.log			640  12    *    $M1D0 JN
/var/log/pflog				600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log	root:network	640  3     100  *     JC
/var/log/security			600  10    100  *     JC
/var/log/sendmail.st			640  10    *    168   B
/var/log/utx.log			644  3     *    @01T05 B
/var/log/weekly.log			640  5     1    $W6D0 JN
/var/log/xferlog			600  7     100  *     JC
....

Каждая строка начинается с имени файла для ротации, за которым может указываться владелец и группа для ротируемого и вновь создаваемого файлов.
Следующее поле, `mode`, является режимом доступа к файлам, а `count` указывает на количество ротируемых файлов с журналами событий, которое должно храниться.
Поля `size` и `when` говорят `newsyslog`, когда ротировать этот файл.
Файл журнала ротируется, когда либо его размер превышает значение поля `size`, либо после того, как истечёт время, указанное в поле `when`.
`*` означает, что данное поле игнорируется.
Поле _flags_ даёт man:newsyslog[8] дополнительные инструкции, такие как способ сжатия ротированного файла или необходимость создания файла журнала, если он отсутствует.
Последние два поля является необязательными и задают PID-файл некоторого процесса и номер сигнала, который будет направлен в этот процесс при ротации файла.
Для получения дополнительной информации обо всех полях, действующих флажковых параметрах и о том, как задать время ротации, обратитесь к  man:newsyslog.conf[5].
Не забывайте о том, что `newsyslog` запускается из `cron` и не может ротировать файлы чаще, чем он запускается из man:cron[8].

[[configtuning-configfiles]]
== Файлы настройки

=== Каталог [.filename]#/etc#

Во FreeBSD определён ряд каталогов, предназначенных для хранения конфигурационных файлов. Это:

[.informaltable]
[cols="1,1", frame="none"]
|===

|[.filename]#/etc#
|Основные файлы конфигурации системы. Тут размещены системно-зависимые данные.

|[.filename]#/etc/defaults#
|Версии системных конфигурационных файлов по умолчанию.

|[.filename]#/etc/mail#
|Дополнительные конфигурационные файлы man:sendmail[8], другие конфигурационные файлы MTA. 

|[.filename]#/etc/ppp#
|Настройка для user- и kernel-ppp программ. 

|[.filename]#/etc/namedb#
|Основное место расположения данных man:named[8]. Обычно [.filename]#named.conf# и файлы зон расположены здесь.

|[.filename]#/usr/local/etc#
|Конфигурационные файлы установленных приложений. Могут содержать подкаталоги приложений.

|[.filename]#/usr/local/etc/rc.d#
|Скрипты запуска/остановки установленных приложений.

|[.filename]#/var/db#
|Автоматически генерируемые системно-специфичные файлы баз данных, такие как база данных пакетов, и так далее
|===

=== Имена хостов

==== [.filename]#/etc/resolv.conf#

[.filename]#/etc/resolv.conf# определяет, как резолвер (resolver) FreeBSD получает доступ к Системе Доменных Имён (DNS).

Основные записи [.filename]#resolv.conf#: 

[.informaltable]
[cols="1,1", frame="none"]
|===

|`nameserver`
|IP адрес сервера имён. Сервера опрашиваются в порядке описания. Максимальное количество адресов - три.

|`search`
|Список доменов для поиска с помощью hostname lookup. Обычно определяется доменом, в котором находится компьютер.

|`domain`
|Домен, в котором находится компьютер.
|===

Типичный вид [.filename]#resolv.conf#:

[.programlisting]
....
search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30
....

[NOTE]
====
Опции `search` и `domain` нельзя использовать совместно.
====

Если вы используете DHCP, man:dhclient[8] обычно перезаписывает [.filename]#resolv.conf# информацией, полученной от серверов DHCP.

==== [.filename]#/etc/hosts#

[.filename]#/etc/hosts# - простая текстовая база данных, напоминающая старый Интернет. Она работает совместно с DNS и NIS, сопоставляя доменные имена IP адресу. Отдельные компьютеры, соединённые с помощью локальной сети, могут быть записаны тут вместо man:named[8] сервера с целью упрощения. Кроме того, [.filename]#/etc/hosts# используется для записи IP адресов и соответствующих им доменов, избавляя от внешнего трафика, используемого для запросов к DNS серверам.

[.programlisting]
....
# $FreeBSD$
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace 'my.domain' below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#      10.0.0.0        -   10.255.255.255
#      172.16.0.0      -   172.31.255.255
#      192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#
....

Формат [.filename]#/etc/hosts#:

[.programlisting]
....
[IP адрес в Интернете] [имя компьютера] [alias1] [alias2] ...
....

Например:

[.programlisting]
....
10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2
....

За дополнительной информацией обращайтесь к man:hosts[5].

[[configtuning-sysctlconf]]
=== [.filename]#sysctl.conf#

[.filename]#sysctl.conf# очень похож на [.filename]#rc.conf#. Значения устанавливаются в виде `variable=value`. Указанные значения устанавливаются после перевода системы в многопользовательский режим. Однако не все переменные могут быть установлены в этом режиме.

Для того, чтобы отключить протоколирование прекращения работы программ из-за аварийных ошибок и ограничить пользователям просмотр процессов, запущенных другими пользователями, в [.filename]#sysctl.conf# могут быть заданы следующие параметры:

[.programlisting]
....
# Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0
....

[[configtuning-sysctl]]
== Тонкая настройка с использованием man:sysctl[8]

man:sysctl[8] - это интерфейс, позволяющий вам вносить изменения в работающую систему FreeBSD. Эти изменения касаются многих опций стека TCP/IP и виртуальной памяти; опытный системный администратор может использовать их для существенного увеличения производительности. Более пяти тысяч системных переменных могут быть прочитаны и записаны с помощью man:sysctl[8].

По своей сути, man:sysctl[8] выполняет две функции: чтение и изменение настроек системы.

Для просмотра всех доступных для чтения переменных:

[source,shell]
....
% sysctl -a
....

Чтобы прочитать определённую переменную, например, `kern.maxproc`, введите:

[source,shell]
....
% sysctl kern.maxproc
kern.maxproc: 1044
....

Для присвоения значения переменной, используйте выражение вида _переменная_=_значение_:

[source,shell]
....
# sysctl kern.maxfiles=5000
kern.maxfiles: 2088 -> 5000
....

Изменяемые с помощью sysctl переменные обычно принимают значения либо строкового, либо целого, либо булевого типа. Переменные булевого типа могут принимать два значения (`1` (истина) и `0` (ложь)).

Если вы хотите устанавливать некоторые переменные автоматически при каждой загрузке компьютера, добавьте их в файл [.filename]#/etc/sysctl.conf#. За дополнительной информацией обращайтесь к странице справочника man:sysctl.conf[5] и к <<configtuning-sysctlconf>>.

[[sysctl-readonly]]
=== Переменные man:sysctl[8] только для чтения

В некоторых случаях желательно изменить переменные man:sysctl[8] только для чтения. Иногда другого способа решить проблему нет; при этом, результат может быть достигнут только на этапе начальной загрузки.

Например, на некоторых моделях лэптопов диапазон памяти устройства man:cardbus[4] не определяется и выдается приблизительно такая ошибка:

[source,shell]
....
cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12
....

Ситуации, похожие на эту, требуют изменения некоторых значений man:sysctl[8], модификация которых запрещена. Для разрешения этой ситуации пользователь может поместить man:sysctl[8] "OID" в файл [.filename]#/boot/loader.conf#. Значения по умолчанию хранятся в файле [.filename]#/boot/defaults/loader.conf#.

Решение проблемы, приведенной выше, потребует помещения строки `hw.pci.allow_unsupported_io_range=1` в вышеупомянутый файл. Теперь man:cardbus[4] будет работать нормально.

[[configtuning-disk]]
== Оптимизация дисков

=== Переменные Sysctl

==== `vfs.vmiodirenable`

Значением переменной `vfs.vmiodirenable` может быть установлено в 0 (выключено) или 1 (включено); по умолчанию 1. Эта переменная отвечает за метод кэширования каталогов. Размер большинства каталогов невелик. Они могут поместиться в одном фрагменте (обычно 1K), и могут занимать ещё меньше места (обычно 512 байт) в кэше буфера. При отключении этой переменной (при установке значения 0) буфер прокэширует только заданное число каталогов даже если у вас много памяти. При включении (при установке значения 1) эта переменная sysctl позволит использовать страничное кэширование VM, делая доступным для кэширования каталогов весь объём памяти. Однако, минимальный объём памяти, используемой для кэширования каталогов стал равен объёму страницы (обычно 4 K) вместо 512 байт. Мы рекомендуем оставлять эту опцию включенной, если ваш компьютер исполняет программы, манипулирующие значительным количеством файлов. Примером таких программ могут быть кэширующие прокси-серверы, большие почтовые серверы и серверы новостей. Обычно включение этой опции не понижает производительности, однако лучше поэкспериментировать, чтобы узнать оптимальное значение для вашей машины.

==== `vfs.write_behind`

Переменная sysctl `vfs.write_behind` по умолчанию установлена в `1` (включено). Она указывает системе выполнять запись на носитель по кластерам, что обычно делается для больших файлов. Идея в том, чтобы избежать заполнения кэша неполными буферами, когда это не увеличивает производительность. Однако, это может заблокировать процессы и в некоторых случаях вам может понадобиться отключить этот параметр.

==== `vfs.hirunningspace`

Переменная sysctl `vfs.hirunningspace` определяет число запросов записи на диск, которые могут быть поставлены в очередь. Значение по умолчанию обычно подходит, но на компьютерах с большим количеством дисков вы можете увеличить его до четырех или пяти _мегабайт_. Учтите, что установка слишком большого значения (превышающего размер буфера записи) может привести к очень значительному падению общей производительности. Не делайте это значение произвольно большим! Большие значения могут привести к задержкам чтения, выполняемого в то же время

Есть много других переменных sysctl, относящихся к кэшированию в буфер и страничному кэшированию VM. Мы не рекомендуем изменять эти значения, поскольку система VM делает отличную работу по автоматической самонастройке.

==== `vm.swap_idle_enabled`

Переменная sysctl `vm.swap_idle_enabled` полезна в больших многопользовательских системах, где есть много пользователей, входящих и выходящих из системы, и множество ожидающих процессов. Такие системы обычно генерируют большое количество запросов на выделение памяти. Включение этой переменной и настройка задержки выгрузки (swapout hysteresis, в секундах) установкой переменных `vm.swap_idle_threshold1` и `vm.swap_idle_threshold2` позволит освобождать страницы памяти, занятые ожидающими процессами, более быстро, чем при нормальном алгоритме выгрузки. Это помогает даемону выгрузки страниц. Не включайте этот параметр, пока он на самом деле вам не понадобится, поскольку его действие в сущности заключается в более ранней выгрузке страниц из памяти; это повышает нагрузку на подкачку и диск. В малых системах эффект от включения этого параметра предсказуем, но в больших системах нагруженной на подкачкой этот параметр позволяет системе VM проще загружать и выгружать процессы из памяти.

==== `hw.ata.wc`

Во FreeBSD 4.3 кэширование записи на IDE диски было отключено. Это понижало производительность IDE дисков в тестах, но было необходимо для лучшей сохранности данных. Проблема состоит в том, что IDE диски неправильно указывают время завершения записи на диск. При включенном кэшировании IDE диски могут не только записать данные в неправильном порядке - при большой нагрузке на диск некоторые блоки могут задержаться до бесконечности. Сбой, или отключение питания могут могут стать причиной серьёзных повреждений в файловой системе. Поэтому для безопасности системы значение по умолчанию этого параметра было изменено. К сожалению, результатом этого стало столь значительная потеря производительности, что после выхода релиза значение этого параметра было возвращено в первоначальное состояние. Вам следует проверить значение переменной sysctl `hw.ata.wc` на вашей машине. Если кэширование выключено - вы можете включить его, установив значение переменной ядра, равное 1. Это должно быть сделано при помощи загрузчика при загрузке. Если вы сделаете это позже - изменения не будут иметь силы.

За более подробной информацией обращайтесь к man:ata[4].

==== `SCSI_DELAY` (`kern.cam.scsi_delay`)

Параметр настройки ядра `SCSI_DELAY` может использоваться для уменьшения времени загрузки системы.
Используемое по умолчанию значение достаточно велико и может приводить к задержкам в `15` секунд в процессе загрузки.
Уменьшение его до `5` секунд обычно работает (особенно с современными накопителями).
Следует использовать настраиваемый параметр загрузки `kern.cam.scsi_delay`.
Этот настраиваемый параметр и параметр конфигурации ядра принимают значения в _миллисекундах_, а _не_ в _секундах_.

[[soft-updates]]
=== Мягкое обновление

Программа man:tunefs[8] используется для настройки файловой системы. Эта программа может принимать большое количество параметров, но мы рассмотрим лишь один из них - включение и выключение Soft Updates, что может быть достигнуто следующим образом:

[source,shell]
....
# tunefs -n enable /filesystem
# tunefs -n disable /filesystem
....

Нельзя изменять файловую систему с помощью man:tunefs[8] когда она смонтирована. Самое подходящее время для включения "Soft Updates" - перед монтированием разделов, в однопользовательском режиме.

Soft Updates существенно увеличивают скорость создания и удаления файлов путём использования кэширования. Мы рекомендуем использовать Soft Updates на всех ваших файловых системах. Однако у Soft Updates есть и обратные стороны: во-первых, Soft Updates гарантирует целостность файловой системы в случае сбоя, но может наблюдаться задержка в несколько секунд (или даже минуту!) перед записью на жесткий диск. Если система зависнет - вы можете потерять больше, чем, если бы вы не включили Soft Updates. Во-вторых, Soft Updates задерживает освобождение блоков файловой системы. Если ваша файловая система заполнена, выполнение значительного обновления, например, `make installworld`, может вызвать переполнение.

==== Дополнительная информация о мягком обновлении

Есть два традиционных способа записи метаданных файловых систем на диск (пример метаданных: индексные дескрипторы и каталоги).

Исторически, поведение по умолчанию заключается в синхронном обновлении метаданных. Если каталог был изменен, система ждет, пока изменение не будет физически записано на диск. Содержимое файлов проходит через кэш и записывается на диск асинхронно. Преимущество этого способа в его надежности. При сбое во время обновления метаданные остаются в нормальном состоянии. Файл либо создается целиком, либо вообще не создается. Если блоки данных не были записаны в файл из буфера во время сбоя, man:fsck[8] сможет определить это и восстановить файловую систему, установив длину файла в 0. Кроме того, реализация этого способа проста и понятна. Недостаток в том, что обновление метаданных занимает много времени. Команда `rm -r`, например, последовательно удаляет все файлы в каталоге, и каждое изменение в каталоге (удаление файла) будет синхронно записано на диск. Сюда включаются обновления самого каталога, таблицы индексных дескрипторов, и возможно блоков, занятых файлом. Те же соглашения работают при распаковке больших иерархий (`tar -x`).

Другой вариант это асинхронное обновление метаданных. Это поведение по умолчанию для Linux/ext2fs и *BSD ufs с параметром `mount -o async`. Все обновления метаданных просто пропускаются через кэш буфера, как и содержимое файлов. Преимущество этой реализации в том, что нет необходимости ждать каждый раз, пока метаданные будут записаны на диск, поэтому все операции с большим объемом обновления метаданных будут происходить гораздо быстрее, чем при синхронном обновлении. Кроме того, реализация все еще проста и понятна, поэтому риск появления ошибок в коде невелик. Недостаток в том, что нет никаких гарантий исправности файловой системы. Если во время обновления большого объема метаданных произойдет сбой (например, отключение питания, или нажатие кнопки reset), файловая система останется в непредсказуемом состоянии. Нет возможности определить состояние файловой системы после такого сбоя; блоки данных файла могут быть уже записаны на диск, а обновления таблицы индексных дескрипторов нет. Невозможно реализовать `fsck`, которая могла бы исправить получившийся хаос (поскольку необходимой информации нет на диске). Если файловая система была уничтожена во время восстановления, единственный способ восстановления - запустить man:newfs[8] и воспользоваться резервной копией.

Обычное решение этой проблемы состояло в реализации _протоколировании проблемной области (dirty region logging)_, известном как _журналирование_, хотя этот термин использовался неправильно и порой также применялся к другим формам протоколирования транзакций. Обновление метаданных как и прежде происходит синхронно, но в отдельную область диска. Позже они перемещаются туда, где должны быть. Поскольку область протоколирования это небольшая, последовательная область диска, головкам жесткого диска не приходится перемещаться на большие расстояния даже во время значительных обновлений, поэтому такой способ быстрее, чем синхронные обновления. Кроме того, сложность реализации довольно ограничена, поэтому риск внесения ошибок невелик. Недостаток в том, что все обновления метаданных записываются дважды (один раз в область протоколирования и один раз окончательно), поэтому при обычной работе производительность может понизиться. С другой стороны, в случае сбоя все незаконченные действия с метаданными могут быть быстро отменены, или завершены после загрузки системы, поэтому система после сбоя загружается быстрее.

Kirk McKusick, разработчик Berkeley FFS, решил эту проблему с помощью Soft Updates: все незавершенные обновления метаданных находятся в памяти и записываются на диск в упорядоченном виде ("упорядоченное обновления метаданных"). При значительных обновлениях метаданных более поздние обновления "присоединяются" к предыдущим, если они все еще находятся в памяти и еще не записаны на диск. Поэтому все операции, скажем, над каталогом, обычно выполняются в памяти перед записью обновления на диск (блоки данных сортируются в соответствии с их положением, так что они не будут записаны на диск до метаданных. При крахе операционной системы выполняется "откат": считается, что все операции, не записанные на диск, никогда не происходили. Файловая система находится в том состоянии, в котором она была за 30-60 секунд до сбоя. Используемый алгоритм гарантирует, что все используемые ресурсы маркированы соответствующим образом в своих областях: блоки и индексные дескрипторы. После сбоя могут остаться только ошибки выделения ресурсов, они помечаются как "используемые", хотя на самом деле "свободны". man:fsck[8] разбирается в ситуации и освобождает более не используемые ресурсы. После сбоя система может быть безопасно смонтирована с опцией `mount -f`. Для освобождения ресурсов, которые могут не использоваться, в дальнейшем потребуется запустить man:fsck[8]. Эта идея лежит в основе _background (фоновая) fsck_: во время запуска системы записывается только _снимок_ файловой системы. Все системы могут быть смонтированы в "грязном" состоянии, и система загружается в многопользовательский режим. Затем, фоновые `fsck` ставятся в очередь для всех систем, где это требуется, чтобы освободить неиспользуемые ресурсы. (Файловые системы, где не используются Soft Updates, все еще требуют запуска `fsck` в обычном режиме).

Преимущество этого способа в том, что обновления метаданных происходят почти так же быстро, как при асинхронных обновлениях (то есть быстрее, чем при _журналировании_, когда метаданные записываются дважды).
Недостаток в сложности кода (подразумевающим больший риск появления ошибок в области, где вероятность потери данных пользователя особенно высока) и в более высоких требованиях к объему памяти. К тому же могут возникнуть некоторые странные на первый взгляд ситуации. После сбоя состояние файловой системы несколько более "старое". В ситуации, когда стандартный способ синхронизации оставит несколько файлов нулевой длины после выполнения `fsck`, в файловой системе с Soft Updates их не останется вовсе, поскольку ни метаданные, ни содержимое файлов не были записаны на диск. Дисковое пространство не будет освобождено пока обновления не будут записаны на диск, что может занять некоторое время после выполнения `rm`. Это может повлечь проблемы при установке большого количества файлов на файловую систему, где не хватает места для помещения всех файлов дважды.

[[configtuning-kernel-limits]]
== Изменение ограничений, накладываемых ядром

[[file-process-limits]]
=== Ограничения на Файлы/Процессы

[[kern-maxfiles]]
==== `kern.maxfiles`

Значение `kern.maxfiles` может быть увеличено или уменьшено в зависимости от потребностей вашей системы. Эта переменная определяет максимальное число дескрипторов файлов. Когда таблица дескрипторов файлов полна, в очереди системных сообщений появится сообщение `file: table is full`. Это сообщение может быть прочитано с помощью команды `dmesg`.

Каждый открытый файл, сокет или буфер использует дескриптор файла. Широкомасштабному серверу может понадобиться много тысяч дескрипторов файлов, в зависимости от количества программ, одновременно выполняемых на сервере.

В более старых релизах FreeBSD значение `kern.maxfile`, используемое по умолчанию, определяется на основании параметра `maxusers` в вашем конфигурационном файле ядра.
Значение `kern.maxfiles` увеличивается пропорционально значению `maxusers`. При компилировании ядра, нужно установить эту переменную согласно потребностям вашей системы. Исходя из значения этой переменной, ядро устанавливает значения большинства предопределённых переменных. Даже если предполагается, что к компьютеру не будут одновременно подсоединяться 256 пользователей, требуемые ресурсы могут быть такими же, как у крупномасштабного сервера.

Значение переменной `kern.maxusers` определяется автоматически при загрузке на основании данных об объёмах памяти, доступных системе, и может быть выяснено во время работы просмотром значения системной переменной `kern.maxusers`.
Некоторым системам будет требоваться более высокие или более низкие значения `kern.maxusers`, и они могут быть заданы как настраивемые параметры загрузчика; значения 64, 128 и 256 не являются редкими.
Мы не рекомендуем выходить за границы выше 256, если только вам не нужно огромного количества файловых дескрипторов; многие из настраиваемых параметров, значения которых устанавливаются в значения по умолчанию при помощи `kern.maxusers`, могут быть в индивидуальном порядке переопределены во время загрузки или во время работы системы в файле [.filename]#/boot/loader.conf# (за подсказками обратитесь к странице справочника по man:loader.conf[5] или к файлу [.filename]#/boot/defaults/loader.conf#) или в порядке, описанном в других разделах этого документа.

В более старых релизах система будет автоматически подстраивать `maxusers` за вас, если вы явно установите его значение равным `0`.
Если вы желаете выставить значение самостоятельно, то задайте `maxusers` по меньшей мере равным 4, особенно если вы используйте X Window System или компилируйте программное обеспечение. Причина в том, что самая значимая таблица, устанавливаемая `maxusers` - это максимальное количество процессов, которая устанавливается равным `20 + 16 * maxusers`, и поэтому, если вы установите `maxusers` в 1, то вы сможете иметь только 36 одновременных процессов, включая 18 или около того, что система запустит во время загрузки и 15 или около того, что вы создадите при запуске X Window System. Даже простая задача, как чтение страницы справочника породит 9 процессов для фильтрации, декомпрессии и её просмотра. Установка `maxusers` в 64 позволит иметь вам до 1044 одновременных процессов, чего должно быть достаточно примерно для всех использований. Если, тем не менее, вы увидите пугающую ошибку  при попытке запуска другой программы, или вы используйте сервер с большим количеством одновременных пользователей (как `ftp.FreeBSD.org`), то вы всегда можете увеличить значение и пересобрать систему.

[NOTE]
====
`maxusers` _не_ ограничивает количество пользователей, которые могут заходить на вашу машину.
Оно просто устанавливает различные размеры таблиц в разумные значения, учитывая максимальное количество пользователей, которое вы, вероятно, будете иметь на вашей системе, и как много процессов каждый из них будет запускать одновременно.
====

==== `kern.ipc.somaxconn`

Переменная sysctl `kern.ipc.somaxconn` ограничивает размер очереди для приема новых TCP соединений. Значение по умолчанию `128` слишком мало для надежной обработки новых соединений для нагруженного web сервера. Для такого сервера рекомендуется увеличить это значение до `1024` или выше.
Даемон сервиса может сам ограничивать очередь приёма новых соединений (например, man:sendmail[8] или Apache), но обычно в файле настройки даемона есть директива для настройки длины очереди.
Более длинная очередь также помогает избежать атак типа Denial of Service (DoS).

[[nmbclusters]]
=== Сетевые Ограничения

Опция ядра `NMBCLUSTERS` обуславливает количество Mbuf, доступных на машине. На сервере с большим трафиком и маленьким Mbuf производительность будет пониженной. Каждый кластер представлен двумя килобайтами памяти, поэтому значение 1024 означает 2 мегабайта памяти ядра, зарезервированной для сетевых буферов. Для определения оптимального значения необходимо провести простые вычисления. Если у вас веб сервер, который может обслуживать 1000 одновременных соединений, и каждое соединение "съедает" 16 K буфера приема и 16 K буфера отправки, вам потребуется 32 MB памяти под буферы. Хорошее правило - умножение этого значения на 2, 2x32 MB / 2 KB = 64 MB / 2 kB = 32768. Мы рекомендуем значения между 4096 и 32768 для машин с большим объемом памяти. Не указывайте произвольно большое значение параметра, это может привести к падению системы при загрузке. Используйте man:netstat[1] с опцией `-m` для определения количества используемых сетевых кластеров.

Для настройки в процессе загрузки используйте в loader переменную `kern.ipc.nmbclusters`. Только в старых версиях FreeBSD потребуется пересобрать ядро (man:config[8]) с измененным параметром `NMBCLUSTERS`.

Для нагруженных серверов, интенсивно использующих системный вызов man:sendfile[2], может потребоваться увеличения буферов man:sendfile[2] с помощью параметра конфигурации ядра `NSFBUFS`, или изменения значения путем установки переменной в [.filename]#/boot/loader.conf# (обратитесь к man:loader[8] за подробностями). Общий признак того, что параметр требуется изменить - состояние процессов `sfbufa`. Переменная sysctl `kern.ipc.nsfbufs` установлена только для чтения. Этот параметр увеличивается вместе с `kern.maxusers`, хотя может потребоваться увеличить его отдельно.

[IMPORTANT]
====
Даже если сокет помечен как неблокирующий, вызов man:sendfile[2] на неблокирующем сокете может вызвать блокирование man:sendfile[2], пока не станет доступным достаточное количество `struct sf_buf`.
====

==== `net.inet.ip.portrange.*`

Переменные sysctl `net.inet.ip.portrange.*` контролируют диапазоны номеров портов, автоматически привязываемых к TCP и UDP сокетам. Есть три диапазона: нижний диапазон, диапазон по умолчанию и верхний диапазон. Большинство сетевых программ используют диапазон по умолчанию, контролируемый `net.inet.ip.portrange.first` и `net.inet.ip.portrange.last`, установленными соответственно в 1024 и 5000. Диапазоны портов привязки используются для исходящих соединений и при некоторых условиях портов может не хватить. Это чаще всего происходит на сильно загруженном прокси сервере. Диапазон портов не становится проблемой при работе серверов, которые обрабатывают в основном входящие соединения, или с небольшим количеством исходящих соединений, например mail relay. Для ситуаций, когда возможен недостаток портов, рекомендуется немного увеличить `net.inet.ip.portrange.last`. Может подойти значение `10000`, `20000`, или `30000`. Учтите также возможное влияние брандмауэра при изменении диапазона портов. Некоторые могут блокировать большие диапазоны портов (обычно с небольшими номерами) и вынуждают использовать более высокие диапазоны для исходящих соединений. По этой причине не рекомендуется уменьшать значение `net.inet.ip.portrange.first`.

==== TCP Bandwidth Delay Product

TCP Bandwidth Delay Product Limiting похоже на TCP/Vegas в NetBSD. Оно может быть включено установкой переменной sysctl `net.inet.tcp.inflight.enable` в `1`. Система попытается вычислить задержку пакетов для каждого соединения и ограничить объем данных в очереди сети до значения, требуемого для поддержания оптимальной пропускной способности.

Эта возможность полезна при передаче данных через модемы, Gigabit Ethernet, или даже через высокоскоростные WAN соединения (или любые другие соединения с большой задержкой передачи), особенно если вы также используете изменение размера окна или настроили большое окно передачи. Если вы включили этот параметр, убедитесь также, что переменная `net.inet.tcp.inflight.debug` установлена в `0` (отладка выключена), а для использования в реальных задачах может понадобиться установка переменной `net.inet.tcp.inflight.min` к значению как минимум `6144`. Но учтите, что установка большого значения этой переменной может фактически отключить ограничение в зависимости от вида соединения. Ограничение уменьшает количество данных на определенном маршруте и управляет очередью пакетов, как и уменьшает общее количество данных в очереди локального интерфейса хоста. С меньшим количеством пакетов в очереди двусторонние интерактивные соединения, особенно на медленных линиях, могут проходить быстрее. Но имейте ввиду, что эта функция работает только при передаче данных (передача данных / сторона сервера). Она не работает при получении данных (загрузке).

Изменение значения переменной `net.inet.tcp.inflight.stab` _не_ рекомендуется. Этот параметр по умолчанию равен 20, что означает добавление 2 пакетов к вычислению задержки передачи. Дополнительное окно требуется для стабилизации алгоритма и улучшения ответной реакции на изменение условий, но также приводит к большему времени ping на медленных соединениях (задержка все же гораздо меньше, чем без алгоритма inflight). Вы можете попробовать уменьшить этот параметр до 15, 10 или 5; а также уменьшить `net.inet.tcp.inflight.min` (например, до 3500) для получения желаемого эффекта. Уменьшение значений этих параметров может использоваться только как крайняя мера.

=== Виртуальная память

==== `kern.maxvnodes`

Файлы и каталоги в ядре представлены при помощи vnode (виртуальных узлов). Увеличение их числа может помочь уменьшить нагрузку на дисковую подсистему. Как правило, специальной настройки это значение не требует, однако, в некоторых случаях дисковая активность является узким местом, и система исчерпывает таблицу vnode, значение этой переменной следует увеличить. При этом необходимо оценить объем неактивной и свободной памяти.

Текущее количество использованных vnode можно посмотреть при помощи команды:

[source,shell]
....
#  sysctl vfs.numvnodes
vfs.numvnodes: 91349
....

Максимальное количество vnode, доступных системе:

[source,shell]
....
#  sysctl kern.maxvnodes
kern.maxvnodes: 100000
....

Если количество использованных vnode близко к максимуму, значение переменной `kern.maxvnodes` следует увеличить на 1000. Следите за динамикой изменения `vfs.numvnodes`. Если оно увеличивается, приближаясь к вновь установленному максимуму, процесс следует повторить. Изменение в распределении памяти должно быть видно в выводе утилиты man:top[1]: больше памяти перейдет в разряд активной.

[[adding-swap-space]]
== Увеличение объема подкачки

Вне зависимости от того, что вы планировали, иногда система ведет себя неожиданно. Если вам потребовался дополнительный объем подкачки, его довольно просто добавить. Есть три способа увеличения объема подкачки: добавить новый жесткий диск, включить подкачку по NFS, или создать файл подкачки на существующем разделе.

За информацией о криптовании раздела подкачки обращайтесь к crossref:disks[swap-encrypting,Шифрование области подкачки] данного Руководства.

[[new-drive-swap]]
=== Память подкачки на новом или существующем жёстком диске

Добавление нового жёсткого диска для памяти подкачки даёт более высокую производительность, чем добавление раздела на существующем устройстве.
Конфигурирование разделов и жёстких дисков описаны в <<disks-adding>>.
В разделе <<configtuning-initial>> обсуждаются планирование разделов и факторы, влияющие на размер раздела подкачки.

Используйте man:swapon[8] для добавления раздела подкачки в систему.
Например:

[source,shell]
....
# swapon /dev/ada1s1b
....

[WARNING]
====
Возможно использование любого не смонтированного в данный момент раздела, даже если он уже содержит данные.
Применение man:swapon[8] к разделу, содержащему данные, приведёт к перезаписи и уничтожению этих данных.
До запуска man:swapon[8] проверьте, что в качестве раздела, добавляемого как память подкачки, действительно указан тот раздел, что предполагался быть указанным.
====

Для автоматического добавления этого раздела подкачки при загрузке добавьте в [.filename]#/etc/fstab# запись о нём:

[.programlisting]
....
/dev/ada1s1b	none	swap	sw	0	0
....

Обратитесь к man:fstab[5] для получения описания записей в [.filename]#/etc/fstab#.

[[nfs-swap]]
=== Подкачка через NFS

Подкачка через NFS рекомендуется только в том случае, если в системе отсутствует жесткий диск; подкачка через NFS ограничена скоростью сетевого подключения и к тому же дополнительно нагружает NFS сервер.

[[create-swapfile]]
=== Файлы подкачки

Вы можете создать файл определенного размера и использовать его как файл подкачки. В нашем примере будет использован файл [.filename]#/usr/swap0# размером 64MB. Конечно, вы можете использовать любое имя.

.Создание файла подкачки в FreeBSD
[example]
====
. В ядро [.filename]#GENERIC# уже включён драйвер организации диска в оперативной памяти (man:md[4]), требуемый для этой операции.
При построении нестандартного ядра убедитесь, что в конфигурационном файле этого ядра присутствует следующая строка:
+
[.programlisting]
....
device	md
....
+
Для получения информации о построении вашего собственного ядра, пожалуйста, обратитесь к разделу <<kernelconfig>>.
+
. Создайте файл подкачки ([.filename]#/usr/swap0#):
+
[source,shell]
....
# dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
....

. Установите подходящие права на ([.filename]#/usr/swap0#):
+
[source,shell]
....
# chmod 0600 /usr/swap0
....

. Включите файл подкачки в [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
....

. Перегрузите компьютер или для включения подкачки прямо сейчас введите:
+
[source,shell]
....
# mdconfig -a -t vnode -f /usr/swap0 -u 0  swapon /dev/md0
....

====

[[acpi-overview]]
== Управление питанием и ресурсами

Важно использовать аппаратные ресурсы эффективно.
До того, как появился ACPI, задачи управления энергопотреблением и температурными характеристиками системы являлись сложными для операционных систем.
Аппаратное обеспечение управлялось при помощи BIOS, и поэтому пользователь имел меньше возможностей по просмотру и контролю настроек управления питанием.
Определённые ограниченные возможности настройки были доступны средствами _APM (Advanced Power Management)_.
Управление питанием и ресурсами являются одними из ключевых компонентов современной операционной системы.
Например, вам может потребоваться, чтобы операционная система следила за температурными ограничениями и возможно, предупреждала при неожиданном росте температуры.

В этом разделе Руководства FreeBSD мы предоставим исчерпывающую информацию о ACPI. В конце раздела есть ссылки для дальнейшего чтения.

[[acpi-intro]]
=== Что такое ACPI?

Advanced Configuration and Power Interface (ACPI) это стандарт, написанный объединением поставщиков в целях предоставления стандартного интерфейса для аппаратных ресурсов и управления питанием (отсюда и название). Это ключевой элемент _Operating System-directed configuration and Power Management_, т.е.: он предоставляет операционной системе (OS) больше контроля и более универсален. Современные системы вышли за пределы ограничений существующих Plug and Play интерфейсов до появления ACPI. ACPI это прямой наследник APM (Advanced Power Management).

[[acpi-old-spec]]
=== Недостатки Advanced Power Management (APM)

Средства _Advanced Power Management (APM)_ управляют энергопотреблением системы в зависимости от нагрузки. APM BIOS предоставляется поставщиком системы и специфичен для данной аппаратной платформы. Драйвер APM в OS обеспечивает доступ к _APM Software Interface_, который позволяет управлять уровнями потребления питания.
APM должен продолжать использоваться для систем, произведённых в 2000 году и ранее.

В APM имеется четыре основных проблемы. Во-первых, управление энергопотреблением осуществляется через зависимый от поставщика BIOS, и OS ничего не знает нем. Один пример: когда пользователь устанавливает время ожидания для жесткого диска в APM BIOS, и это время истекает, BIOS останавливает жесткий диск без согласования с OS. Во-вторых, алгоритм APM встроен в BIOS, и все действия происходят вне контроля OS. Это означает, что пользователи могут решить проблемы с APM BIOS только путем перепрошивки его ROM; это очень опасная процедура, и если она завершится неудачно, система может оказаться в невосстановимом состоянии. В-третьих, реализация технологии APM зависит от поставщика, что означает дублирование усилий и если в BIOS одного из поставщиков будет найдена и исправлена ошибка, ее могли не исправить другие поставщики. Наконец, объем APM BIOS недостаточно велик для реализации сложной политики управления питанием, или такой политики, которая может хорошо адаптироваться к потребностям компьютера.

_Plug and Play BIOS (PNPBIOS)_ был неудобен во многих ситуациях. PNPBIOS это 16-битная технология, поэтому OS требовалось использовать 16-битную эмуляцию для "взаимодействия" с методами PNPBIOS.

FreeBSD драйвер APM документирован в странице справочника man:apm[4].

[[acpi-config]]
=== Настройка ACPI

По умолчанию драйвер [.filename]#acpi.ko# загружается при помощи man:loader[8] при запуске системы, его _не_ нужно компилировать как часть ядра.
Дело в том, что с модулями проще работать, например, при переключении на другой [.filename]#acpi.ko# без повторного построения ядра.
Такой подход имеет преимущество в упрощении тестирования.
Другая причина заключается в том, что запуск ACPI после запуска системы зачастую работает не очень хорошо.
Если вы сталкиваетесь с проблемами, то можете совсем отключить ACPI.
Этот драйвер не должен и не может быть выгружен, поскольку системная шина использует его для различных взаимодействий с оборудованием.
ACPI может быть отключён установкой `hint.acpi.0.disabled="1"` в [.filename]#/boot/loader.conf# или командной строке man:loader[8].

[NOTE]
====
ACPI и APM не могут сосуществовать и должны использоваться раздельно.
Каждый из них при загрузке прекратит свою работу, если обнаружит, что уже используется другой.
====

ACPI может использоваться для перевода системы в спящий режим с помощью man:acpiconf[8] с флагом `-s` и параметром `1-5`.
Большинству пользователей будет требоваться только параметр `1` или `3` (приостановка работы с сохранением состояния в оперативной памяти).
Параметр `5` выполнит приостановку работы, что означает те же действия, что и:

[source,shell]
....
# halt -p
....

Доступны и другие варианты через man:sysctl[8].
Обратитесь к справочным страницам man:acpi[4] и man:acpiconf[8] для получения дополнительной информации.

[[ACPI-debug]]
== Использование и отладка FreeBSD ACPI

ACPI это фундаментально новый способ обнаружения устройств, управления энергопотреблением и предоставления стандартизированного доступа к различному оборудованию, ранее управлявшемуся BIOS. Был достигнут определенный прогресс в приспособлении ACPI к работе со всеми системами, но все еще встречаются ошибки в байткоде _ACPI Machine Language_ (AML) некоторых материнских плат, незавершенные участки кода в подсистемах ядра FreeBSD и ошибки в интерпретаторе Intel(R) ACPI-CA.

Этот раздел предназначен для того, чтобы упростить ваше содействие разработчикам FreeBSD ACPI в определении причин наблюдаемых вами проблем, выполнении отладки и выработке решения. Спасибо за помощь и надеемся, что мы сможем помочь в решении проблем вашей системы.

[[ACPI-submitdebug]]
=== Отправка отладочной информации

[NOTE]
====
Перед отправкой сообщения об ошибке убедитесь, что у вас последняя версия BIOS, и, если доступна, последняя версия firmware встроенного контроллера.
====

Те из вас, кто желает составить сообщение о проблеме прямо сейчас, могут воспользоваться адресом link:mailto:freebsd-acpi@FreeBSD.org[ freebsd-acpi@FreeBSD.org], отправив на него следующую информацию:

* Описание неправильного поведения, включая тип системы, модель и все, что приводит к появлению ошибки. Кроме того, сообщите настолько точно, насколько возможно, когда появилась ошибка, если ранее вы ее не видели.
* Вывод man:dmesg[8] после "boot ``-v``", включая все сообщения, появившиеся при изучении ошибки.
* Вывод man:dmesg[8] после "boot ``-v``" с выключенным ACPI, если его отключение помогает решить проблему.
* Вывод `sysctl hw.acpi`. Это также хороший способ получения списка возможностей системы.
* URL где можно найти ваш _ACPI Source Language_ (ASL). _Не_ отправляйте ASL непосредственно в список рассылки, поскольку он может быть очень большим. Сформируйте копию ASL запуском следующей команды:
+
[source,shell]
....
# acpidump -t -d  name-system.asl
....
+ 
(Замените вашим логином [.filename]#name# и производителем/моделью [.filename]#system#. Пример: [.filename]#njl-FooCo6000.asl#)

Большинство разработчиков читают {freebsd-current}, но для уверенности, что проблему увидят, отправьте ее в {freebsd-acpi}. Будьте терпеливы, все мы заняты полный рабочий день где-то еще. Если ваше сообщение не заметили сразу, мы возможно попросим вас отправить PR (сообщение о проблеме) через man:send-pr[1]. При вводе PR, включайте ту же информацию, что запрошена выше. Это поможет нам отследить проблему и решить ее. Не отправляйте PR без предварительной отправки письма в {freebsd-acpi}, поскольку мы используем PR в качестве напоминаний о существующих проблемах, а не как механизм сообщений об ошибках. Вероятно, о вашей проблеме кто-то уже сообщал ранее.

[[ACPI-background]]
=== Общие сведения

ACPI представлен во всех современных компьютерах, соответствующих архитектурам ia32 (x86), ia64 (Itanium) и amd64 (AMD). Полный стандарт включает множество возможностей, в том числе управление производительностью CPU, уровнем питания, температурой, различными системами аккумуляторов, встроенными контроллерами и опросом шины. В большинстве систем стандарт реализован не полностью. Например, настольные системы обычно реализуют только опрос шины, а портативные компьютеры кроме того могут поддерживать управление охлаждением и энергопотреблением. Они также поддерживают приостановку и последующий запуск системы различного уровня сложности.

ACPI-совместимые системы состоят из различных компонентов. Производители BIOS и чипсетов предоставляют различные жестко заданные таблицы, (например, FADT), которые определяют функции вроде карты APIC (используется для SMP), регистры настройки и простые значения параметров. Кроме того, предоставляется таблица байткода (_Differentiated System Description Table_, DSDT), определяющая древоподобное пространство имен устройств и методов.

Драйвер ACPI должен прочесть заданные таблицы, реализовать интерпретатор для байткода, модифицировать драйвера устройств и ядро для приема информации от подсистемы ACPI. Для FreeBSD Intel(R) предоставила интерпретатор (ACPI-CA), тот же что для Linux и NetBSD. Исходный код ACPI-CA находится в каталоге [.filename]#src/sys/contrib/dev/acpica#. Код для приспособления ACPI-CA к работе в FreeBSD, находится в [.filename]#src/sys/dev/acpica/Osd#.
Наконец, драйверы, реализующие различные устройства ACPI, находятся в [.filename]#src/sys/dev/acpica#.

[[ACPI-comprob]]
=== Часто встречающиеся проблемы

Для правильной работы ACPI все ее части должны работать правильно. Вот некоторые часто встречающиеся проблемы, в порядке частоты появления, и некоторые обходные пути или исправления.

==== Проблемы с мышью

В некоторых случаях при возобновлении работы после приостановки перестает работать мышь. Известным решением проблемы является добавление строки `hint.psm.0.flags="0x3000"` в файл [.filename]#/boot/loader.conf#. Если это не помогло, стоит сообщить о проблеме, как описано выше.

==== Приостановка/возобновление работы

ACPI поддерживает три состояния приостановки в RAM (STR), `S1`-`S3`, и одно состояние приостановки на диск (`STD`), называемое `S4`. `S5` это "мягкое выключение" и это нормальное состояние системы, когда она подключена к сети, но не включена. `S4` может быть реализован двумя различными путями. ``S4``BIOS это BIOS-поддерживаемая приостановка на диск. ``S4``OS реализуется полностью операционной системой.

Начните с проверки переменных `sysctl hw.acpi`, относящихся к приостановке (suspend). Вот результат для Thinkpad:

[source,shell]
....
hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0
....

Это означает, что мы можем использовать `acpiconf -s` для тестирования `S3`, ``S4``OS, и `S5`. Если `s4bios` был единицей (`1`), это означает поддержку ``S4``BIOS вместо ``S4``OS.

При тестировании приостановки/возобновления работы, начните с `S1`, если этот режим поддерживается. Это состояние скорее всего поддерживается, поскольку не требует слишком серьезной поддержки со стороны драйвера. Никто не реализовал `S2`, который похож на `S1`. Следующий режим для тестирования это `S3`. Это наиболее глубокое STR состояние, оно требует существенной поддержки со стороны драйвера, чтобы правильно реинициализировать оборудование. Если у вас возникли проблемы при выходе из этого состояния, отправьте письмо в рассылку {freebsd-acpi}, но не ждите, что проблема будет обязательно решена, поскольку существует множество драйверов/оборудования, нуждающихся в дальнейшем тестировании и разработке.

Распространённой проблемой с приостановкой/возобновлением работы является то, что многие драйверы устройств не сохраняют, не восстанавливают и не инициализируют повторно их микропрограммное обеспечение, регистры или память устройств.
В качестве первой попытки отладки проблемы, попробуйте:

[source,shell]
....
# sysctl debug.bootverbose=1
# sysctl debug.acpi.suspend_bounce=1
# acpiconf -s 3
....

Этот тест эмулирует цикл приостановки/возобновления всех драйверов устройств без фактического перехода в состояние `S3`.
В некоторых случаях таким способом вы можете легко выявить проблемы (к примеру, потерю состояния микропрограммного обеспечения, таймаут таймера устройства и бесконечный цикл повторных попыток).
Заметьте, что система фактически не будет переходить в состояние `S3`, что означает, что устройства могут не потерять питание полностью, и многие будут нормально работать даже если методы приостановки/возобновления отсутствуют вовсе, в отличие от реального состояния `S3`.

В более сложных случаях требуется дополнительное оборудование, то есть последовательный порт/кабель для последовательных консолей или порт/кабель Firewire для man:dcons[4], а также навыки отладки ядра.

Для изоляции проблемы удалите из ядра столько драйверов, сколько возможно. Если это работает, вы можете выяснить, какой драйвер вызывает проблему путем загрузки драйверов до тех пор, пока опять не произойдет сбой. Обычно бинарные драйвера, такие как [.filename]#nvidia.ko#, драйвера дисплея X11 и USB вызывают большинство проблем, а драйвера Ethernet интерфейсов как правило работают отлично. Если вы можете нормально загрузить/выгрузить драйвера, автоматизируйте этот процесс, поместив соответствующие команды в [.filename]#/etc/rc.suspend# и [.filename]#/etc/rc.resume#.
Имеются заключённый в комментарии пример выгрузки и загрузки драйвера.
Попробуйте задать значение параметра `hw.acpi.reset_video` равным нулю (`0`), если ваш дисплей не включается после возобновления работы.
Попробуйте установить более высокие или низкие значения для `hw.acpi.sleep_delay`, чтобы проверить, помогает ли это.

Другой способ, который можно попробовать, это запуск последнего дистрибутива Linux с поддержкой ACPI и тестирование поддержки остановки/возобновления работы на том же оборудовании.
Если она работает на Linux, проблема скорее всего в драйверах FreeBSD и поиск драйвера, вызывающего проблему, поможет разрешить ситуацию.
Имейте в виду, что те, кто поддерживают ACPI, обычно не поддерживают другие драйверы (звук, ATA, и т.п.), так что все результаты работы с проблемой, вероятно, должны быть отправлены в список рассылки {freebsd-current} и человеку, поддерживающему соответствующий драйвер.
Если вы решитесь заняться отладкой, поместите соответствующий код (man:printf[3]) в вызывающий проблему драйвер для обнаружения места, где прерывается функция восстановления.

Наконец, попробуйте отключить ACPI и включить APM. Если приостановка/возобновление работает с APM, вам возможно лучше подойдет APM, особенно на старом оборудовании (до 2000). Включение корректной поддержки ACPI поставщиками оборудования требует времени и вероятно в старом оборудовании поддержка ACPI в BIOS была некорректна.

==== Система зависает (насовсем или временно)

Большинство систем останавливаются в результате потери прерываний или "шторма" прерываний. В чипсетах существует много проблем, связанных с тем, как BIOS настраивает прерывания перед загрузкой, правильностью таблицы APIC (MADT), и маршрутизации _System Control Interrupt_ (SCI).

"Шторм" прерываний может быть обнаружен по потерянным прерываниям путем проверки вывода строки с `acpi0` команды `vmstat -i`. Если счетчик увеличивается более, чем несколько раз в секунду, это "шторм" прерываний. Если система останавливается, попробуйте войти в DDB (kbd:[CTRL+ALT+ESC] на консоли) и ввести `show interrupts`.

Наиболее надежный способ избавиться от проблемы с прерываниями, это отключение поддержки APIC с помощью параметра [.filename]#loader.conf#`hint.apic.0.disabled="1"`.

==== Паника

Паника, связанная с ACPI, случается довольно редко и имеет наибольший приоритет исправления. Первый шаг это изоляция действий, приводящих к панике (если это возможно) и получение отладки. Следуйте инструкции по включению `options DDB` и настройке последовательной консоли (смотрите crossref:serialcomms[serialconsole-ddb,Вход в отладчик DDB с последовательной линии]) или настройке раздела man:dump[8]. Вы можете получить отладочную информацию DDB с помощью `tr`. Если вы записываете отладку вручную, убедитесь, что переписали как минимум пять (5) строк снизу и пять (5) строк сверху.

Затем попробуйте изолировать проблему, загрузившись с выключенным ACPI. Если это работает, вы можете изолировать подсистему ACPI, используя различные параметры `debug.acpi.disable`. Обратитесь к странице справочника man:acpi[4] за примерами.

==== Система включается после приостановки или завершения работы

Во-первых, попробуйте установить в man:loader.conf[5] параметр `hw.acpi.disable_on_poweroff="0"`. Это предотвращает отключение различных событий в ACPI во время завершения работы. В некоторых системах этот параметр необходимо установить в `1` (по умолчанию) по тем же причинам. Обычно это решает проблему, если система неожиданно включается после приостановки или отключения питания.

==== Другие проблемы

Если вы наблюдаете другие проблемы с ACPI (работа с внешним оборудованием, проблемы с обнаружением устройств, и т.д.), отправьте описание проблемы в список рассылки; однако, некоторые из этих проблем могут относиться к незавершенным частям подсистемы ACPI, поэтому может потребоваться время на их реализацию. Будьте терпеливы, и подготовьтесь к тестированию исправлений, которые мы можем вам выслать.

[[ACPI-aslanddump]]
=== ASL, `acpidump`, и IASL

Наиболее часто встречается проблема, связанная с предоставлением поставщиками BIOS некорректного (или полностью ошибочного!) байткода. Это обычно проявляется появлением консольных сообщений ядра, подобных этому:

[source,shell]
....
ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
       (Node 0xc3f6d160), AE_NOT_FOUND
....

Зачастую вы можете разрешить эти проблемы путем обновления BIOS до последней ревизии. Большинство консольных сообщений безвредны, но если существуют другие проблемы, такие как не работающий статус батареи, возможно существуют проблемы в AML. Байткод, известный как AML, компилируется из исходного текста на языке ASL. AML находится в таблице, известной как DSDT. Для получения копии ASL, используйте man:acpidump[8]. Вы можете использовать оба параметра `-t` (показывать содержимое постоянных таблиц) и `-d` (дизассемблировать AML в ASL). Обратитесь к разделу <<ACPI-submitdebug,Отправка отладочной информации>> за примером синтаксиса.

Простейшая первая проверка, которую вы можете провести, это перекомпиляция ASL для поиска ошибок. Предупреждения обычно могут быть проигнорированы, но ошибки обычно не позволяют ACPI работать правильно. Для перекомпиляции ASL, выполните следующую команду:

[source,shell]
....
# iasl your.asl
....

[[ACPI-fixasl]]
=== Исправление ASL

В дальней перспективе, наша задача состоит в том, чтобы обеспечить поддержку ACPI практически для каждой системы без вмешательства пользователя. Однако, на данный момент мы все еще разрабатываем обходные пути для ошибок, которые часто делают поставщики BIOS. Интерпретатор Microsoft(R) ([.filename]#acpi.sys# и [.filename]#acpiec.sys#) не занимается проверкой четкости соблюдения стандартов, поэтому многие поставщики BIOS, проверяющие ACPI только под Windows(R), никогда не исправляют ASL. Мы надеемся продолжать обнаружение и документацию нестандартных поведений, позволяемых интерпретатором Microsoft(R), и воспроизводить их, чтобы FreeBSD могла работать без необходимости исправления ASL пользователями. В качестве обходного пути для обнаружения неправильного поведения, вы можете исправить ASL вручную. Если исправления будут работать, пожалуйста отправьте man:diff[1] между старым и новым ASL, чтобы мы могли реализовать обходной путь для неправильного поведения ACPI-CA, чтобы исправление вручную больше не требовалось.

Вот список наиболее часто встречающихся проблем, их причин и способы исправления:

==== Зависимости от ОС

Некоторые AML предполагают, что мир состоит из различных версий Windows(R). Вы можете настроить FreeBSD, чтобы она сообщала любое другое имя OS и посмотреть, исправит ли это имеющуюся проблему. Простой способ указания другого имени системы это установка переменной [.filename]#/boot/loader.conf#`hw.acpi.osname="Windows 2001"` или в другое подобное значение, имеющееся в ASL.

==== Отсутствующие команды возврата

Некоторые методы не возвращают значение явно, как того требует стандарт. Хотя ACPI-CA не обрабатывает эту ситуацию, в FreeBSD существует обходной путь, позволяющей ей явно возвращать значение. Вы можете также добавить явные операторы Return (возврат) там, где требуется, если знаете, что значение должно быть возвращено. Для принудительного компилирования ASL командой `iasl`, используйте флаг `-f`.

==== Перезапись AML по умолчанию

После настройки [.filename]#your.asl# для компиляции запустите:

[source,shell]
....
# iasl your.asl
....

Вы можете добавить флаг `-f` для создания AML даже при наличии ошибок компиляции. Помните, что некоторые ошибки (например, отсутствующие операторы Return), автоматически обходятся интерпретатором.

Файл [.filename]#DSDT.aml# используется `iasl` по умолчанию. Вы можете загрузить его вместо ошибочной копии BIOS (которая остается в постоянной памяти) путем редактирования [.filename]#/boot/loader.conf#:

[.programlisting]
....
acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"
....

Убедитесь, что скопировали [.filename]#DSDT.aml# в каталог [.filename]#/boot#.

[[ACPI-debugoutput]]
=== Получение отладочной информации от ACPI

Возможности отладки драйвера ACPI очень гибкие. Они позволяют вам указывать набор подсистем, а также уровень отладки. Подсистемы, которые вы хотите отлаживать, указываются как "слои", и подразделяются на компоненты ACPI-CA (ACPI_ALL_COMPONENTS) и поддержку оборудования ACPI (ACPI_ALL_DRIVERS). Уровень отладки варьируется от ACPI_LV_ERROR (только сообщать об ошибках) до ACPI_LV_VERBOSE (все сообщения). Уровень отладки представляет собой битовую маску, поэтому возможна одновременная установка нескольких параметров, разделенных пробелами. На практике, при использовании для получения отладочной информации последовательной консоли, слишком большое количество информации может переполнить буфер консоли. Полный список отдельных слоев и уровней можно найти на странице справочника man:acpi[4].

Вывод отладочной информации по умолчанию не включен. Для его включения добавьте параметр `options ACPI_DEBUG` к файлу настройки ядра, если ACPI встроен в ядро. Вы можете добавить параметр `ACPI_DEBUG=1` в файл [.filename]#/etc/make.conf# для глобального включения этого параметра. Если вы используете модуль [.filename]#acpi.ko# , его можно пересобрать индивидуально:

[source,shell]
....
# cd /sys/modules/acpi/acpi
 make clean  make
ACPI_DEBUG=1
....

Установите [.filename]#acpi.ko# в [.filename]#/boot/kernel# и добавьте предпочитаемый уровень и слой к [.filename]#loader.conf#.
Этот пример включает диагностические сообщения для всех компонентов ACPI-CA и всех драйверов оборудования ACPI (CPU, LID и т.д.).
Будут выводиться только сообщения об ошибках, с наименьшим уровнем детализации.

[.programlisting]
....
debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"
....

Если требуемая информация получается в результате определенного события (скажем, приостановка и восстановление), вы можете не изменять [.filename]#loader.conf# и использовать для указания слоя и уровня `sysctl` после загрузки и подготовки системы к определенному событию. Имена переменных `sysctl` те же, что и имена параметров настройки в [.filename]#loader.conf#.

[[ACPI-References]]
=== Ссылки

Дальнейшую информацию о ACPI можно найти по следующим ссылкам:

* {freebsd-acpi}
* Архивы списка рассылки ACPI http://lists.freebsd.org/pipermail/freebsd-acpi/[http://lists.freebsd.org/pipermail/freebsd-acpi/]
* Старые архивы списка рассылки ACPI http://home.jp.FreeBSD.org/mail-list/acpi-jp/[http://home.jp.FreeBSD.org/mail-list/acpi-jp/]
* https://uefi.org/specifications#ACPI[Спецификация ACPI]
* Страницы справочника FreeBSD: man:acpi[4], man:acpi_thermal[4], man:acpidump[8], man:iasl[8], man:acpidb[8]
* http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt[ Ресурс по отладке DSDT]. (Использует в качестве примера Compaq, но обычно полезен.)
