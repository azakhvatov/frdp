//
// The FreeBSD Russian Documentation Project
//
// Original EN revision (SVN): 41159
//

---
title: Глава 4. Основы UNIX
part: Часть I. В начале
prev: books/handbook/bsdinstall
next: books/handbook/ports
showBookMenu: true
weight: 6
path: "/books/handbook/basics/"
---

[[basics]]
= Основы UNIX
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 4
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/basics/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[basics-synopsis]]
== Краткий обзор

Эта глава посвящена основным командам и функциональности операционной системы FreeBSD.
Большая часть нижеизложенного материала применима к любой UNIX(R)-подобной операционной системе.
Новые пользователи FreeBSD призываются к внимательному чтению всей главы.

Прочитав эту главу, вы узнаете:

* Как использовать "виртуальные консоли" FreeBSD.
* Как работают права доступа на файлы в UNIX(R) и файловые флаги во FreeBSD.
* Иерархия каталогов FreeBSD.
* Организация дисков FreeBSD.
* Как монтировать и размонтировать файловые системы.
* Что такое процессы, даемоны и сигналы.
* Что такое командная оболочка (или интерпретатор команд) и как настроить личное рабочее окружение.
* Как пользоваться стандартными текстовыми редакторами.
* Что такое устройства и файлы устройств.
* Какие бинарные форматы используются в FreeBSD.
* Как пользоваться справочным руководством для получения дополнительной информации.

[[consoles]]
== Виртуальные консоли и терминалы

FreeBSD можно использовать разными способами. Один из них - набор команд в текстовом терминале. Используйте этот способ, и вся гибкость и мощь систем UNIX(R) будет в ваших руках. Этот раздел рассказывает о "терминалах", "консолях" и о том, как их можно использовать во FreeBSD.

[[consoles-intro]]
=== Консоль

Если только FreeBSD не была настроена на автоматический запуск графической среды при загрузке, система будет запускаться в режиме запроса ввода имени учётной записи в командной строке, как в этом примере:

[source,shell]
....
FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:
....

Первая строка содержит определённую информацию о системе.
`amd64` указывает на то, что в системе в данном примере работает 64-разрядная версия FreeBSD.
`pc3.example.org` является именем хоста, а `ttyv0` указывает на то, что это системная консоль.

Вторая строка является приглашением к входу в систему.
Следующий раздел описывает, как входить во FreeBSD по этому приглашению.

[[consoles-login]]
=== Вход во FreeBSD

FreeBSD является многопользовательской многозадачной системой.
Это формальное описание системы, которая может быть использована множеством разных людей, одновременно запускающих большое количество программ на одном компьютере.

Любой многопользовательской системе нужен способ отличать каждого "пользователя" от остальных.
Во FreeBSD (и всех UNIX(R)-подобных операционных системах), эта задача решается путем "входа" пользователя в систему перед запуском каких-либо программ. У каждого пользователя есть уникальное имя ("имя пользователя") и персональный, секретный ключ ("пароль").
Перед тем, как разрешить пользователю выполнять какие-либо программы, FreeBSD запрашивает оба этих параметра.

Когда выполняется загрузка системы FreeBSD, автоматически выполняются скрипты её запуска, предназначенные для подготовки системы и запуска каких бы то ни было сервисов, которые были настроены на запуск при загрузке системы. 

Сразу после завершения работы стартовых скриптов система выдаст приглашение к входу:

[source,shell]
....
login:
....

Наберите имя пользователя, которое было настроено во время <<bsdinstall-addusers,установки системы>> и нажмите kbd:[Enter].
Затем введите пароль, соответствующий этому пользовательскому имени и нажмите kbd:[Enter].
Пароль _не отображается_ по соображениям безопасности.

После ввода корректного пароля будет выдано сообщение дня MOTD (Message Of The Day), за которым последует приглашение командной строки (символ `#`, `$` или `%`).
Теперь вы вошли в консоль FreeBSD и можете попытаться использовать имеющиеся команды.

[[consoles-virtual]]
=== Виртуальные консоли

FreeBSD может быть настроена на обеспечение нескольких виртуальных консолей для ввода команд.
Каждая виртуальная консоль обладает собственным приглашением к входу в систему и канал выдачи, а FreeBSD заботится о корректном перенаправлении клавиатурного ввода и экранной выдачи, когда вы переключаетесь между виртуальными консолями.

Для переключения между консолями во FreeBSD зарезервированы специальные комбинации клавиш.
Обратитесь к справке по man:syscons[4], man:atkbd[4], man:vidcontrol[1] и man:kbdcontrol[1] для получения более технического описания консоли FreeBSD и её драйверах клавиатуры.

Используйте kbd:[Alt+F1], kbd:[Alt+F2], и далее до kbd:[Alt+F8] для переключения между различными виртуальными консолями во FreeBSD.

При переключении от одной консоли к другой FreeBSD заботится о сохранении и восстановлении экранного вывода.
Результатом является "иллюзия" наличия множества "виртуальных" экранов и клавиатур, которые могут быть использованы для ввода и запуска команд FreeBSD.
Программы, запущенные на одной из виртуальных консолей, не прекращают своей работы, когда консоль становится невидимой из-за того, что пользователь переключился на другую виртуальную консоль.

[[consoles-ttys]]
=== Файл [.filename]#/etc/ttys#

По умолчанию FreeBSD настроена на запуск восьми виртуальных консолей.
Эта настройка может быть модифицирована для запуска большего или меньшего количества виртуальных консолей.
Для того, чтобы изменить количество и параметры виртуальных консолей, отредактируйте файл [.filename]#/etc/ttys#.

Каждая из незакомментированных строк (то есть строк, не начинающихся с символа `#`) в файле [.filename]#/etc/ttys# содержит настройки для одного терминала или виртуальной консоли.
В стандартной версии этого файла настроены девять виртуальных консолей и активированы восемь из них.
Это строки, начинающиеся с `ttyv`:

[.programlisting]
....
# name	getty				type	status	comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

За детальным описанием каждой колонки этого файла и доступных параметров виртуальных консолей обратитесь к man:ttys[5].

[[consoles-singleuser]]
=== Консоль в однопользовательском режиме

Детальное описание "однопользовательского режима" можно найти в crossref:boot[boot-singleuser,здесь].
Когда FreeBSD находится в однопользовательском режиме, имеется только одна консоль, других виртуальных консолей в этом режиме нет.
Настройки для однопользовательского режима находятся в следюущем разделе файла [.filename]#/etc/ttys#:

[.programlisting]
....
# name	getty	type	status	comments
#
# Если консоль помечена как "insecure", то init будет запрашивать пароль
# пользователя root при переходе в однопользовательский режим
console	none	unknown	off	secure
....

[NOTE]
====
Как указано в комментариях выше строки `console`, изменение `secure` на `insecure` приведёт к тому, что при загрузке в однопользовательском режиме будет запрашиваться пароль пользователя `root`.
При стандартных настройках переход в однопользовательский режим не сопровождается запросом пароля.

__Будьте осторожны при изменении этого значения на ``insecure``__.
Даже если вы забудете пароль пользователя `root`, загрузка в однопользовательском режиме всё ещё будет возможна, но может быть затруднена для тех, кто ещё не очень хорошо освоился с процессом загрузки FreeBSD.
====

[[consoles-vidcontrol]]
=== Изменение видеорежимов консоли

Установленный по умолчанию режим видео для консоли FreeBSD может быть изменён до значения 1024x768, 1280x1024 или любого другого, который поддерживается вашим монитором и видеокартой.
Для использования другого видеорежима загрузите модуль `VESA`:

[source,shell]
....
# kldload vesa
....

Для определения того, какие видеорежимы поддерживаются вашим оборудованием, воспользуйтесь man:vidcontrol[1].
Чтобы получить список поддерживаемых видеорежимов, выполните следующую команду:

[source,shell]
....
# vidcontrol -i mode
....

Выдача этой команды отобразит список видеорежимов, поддерживаемых оборудованием.
Для выбора нового видеорежима укажите его при помощи man:vidcontrol[1], работая как пользователь `root`.

[source,shell]
....
# vidcontrol MODE_279
....

Если новый видеорежим приемлем, то его можно определить постоянно устанавливаемым при загрузке, добавив в [.filename]#/etc/rc.conf#:

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[users-synopsis]]
== Пользователи и основы управления учетными записями

FreeBSD допускает одновременную работу множества пользователей на одном компьютере. В то время, как только один пользователь может сидеть за клавиатурой и перед экраном в один момент времени, любое количество пользователей может войти в систему через сеть. Для использования системы у каждого пользователя должна быть учетная запись.

В этом разделе описаны:

* Разные типы учетных записей в системе FreeBSD.
* Как добавлять, удалять и изменять учетные записи пользователей.
* Как устанавливать ограничения на использование ресурсов для учетных записей или групп учетных записей.
* Как использовать группы для упрощения управлением учетными записями.

[[users-introduction]]
=== Разновидности учетных записей

Так как доступ к системе FreeBSD осуществляется через учетные записи, и все процессы запускаются пользователями, то управление пользователями и учетными записями является важным аспектом администрирования.

Существует три разновидности учетных записей: системные учетные записи, учетные записи пользователей и суперпользователь.

[[users-system]]
==== Системные учетные записи

Системные учетные записи предназначены для запуска сервисов, таких как DNS, почта, веб серверы. Это необходимо по соображениям безопасности; если бы все сервисы работали от суперпользователя, они могли бы действовать без ограничений.

Примеры системных учетных записей: `daemon`, `operator`, `bind`, `news` и `www`.

`nobody` это общепринятая непривилегированная системная учетная запись. Однако, чем больше сервисов используют `nobody`, тем больше файлов и процессов связано с этим пользователем, и следовательно тем больше привилегий появляется у этого пользователя.

[[users-user]]
==== Учетные записи пользователей

Учетные записи пользователей служат для предоставления доступа к системе обычным людям. Каждый человек, имеющий доступ к системе, должен иметь уникальную учетную запись пользователя. Это позволяет администратору выяснять кто что делает и предотвращает сбивание одним пользователем настроек других пользователей.

Каждый пользователь посредством выбора оболочки, редактора, привязок клавиш и настроек языка может настраивать свою собственную рабочую среду для приспособления системы под свои нужды.

С каждой учетной записью в системе FreeBSD связана определенная идентификационная информация:

Имя пользователя::
Имя пользователя вводится в приглашение `login:`. Имена пользователей должны быть уникальны. Существует множество правил для создания допустимых имен пользователей, документированных в man:passwd[5]. Рекомендуется составлять имена пользователей из восьми или меньшего количества символов в нижнем регистре, чтобы поддерживать обратную совместимость с приложениями.

Пароль::
С каждой учетной записью связан пароль.

ID пользователя (User ID, UID)::
Идентификатор пользователя (UID) - это номер, используемый для однозначной идентификации пользователя в системе FreeBSD. Любая команда, принимающая в качестве аргумента имя пользователя, первым делом преобразует его к UID. Рекомендуется выбирать значения UID, не превышающие 65535, так как большие значения могут вызывать проблемы совместимости для некоторых пользовательских программ.

Идентификатор группы (Group ID, GID)::
Идентификатор группы (GID) - это номер, используемый для однозначной идентификации главной группы, к которой принадлежит пользователь. Группы это механизм для контроля доступа к ресурсам на основе GID пользователя вместо его UID. Это может значительно уменьшить размер некоторых файлов настройки. Кроме того, пользователь может быть включен более чем в одну группу. Рекомендуется использовать значения GID, не превышающие 65535, так как большие значения могут стать проблемой для некоторых программ.

Класс доступа (login class)::
Классы доступа это расширение к механизму групп, позволяющее более гибко приспосабливать систему для различных пользователей. Классы доступа описаны в <<users-limiting>>.

Срок действия пароля::
По умолчанию пароли не устаревают. Однако, есть возможность ограничить срок действия текущего пароля пользователя, и тем самым обязать его обновить пароль.

Срок действия учетной записи::
По умолчанию во FreeBSD время действия учетных записей не ограничено. При создании учетных записей ограниченного срока действия, например для студентов в учебном заведении, при помощи man:pw[8] укажите дату истечения действия учетной записи. После наступления указанной даты учетная запись становится непригодной для входа в систему, хотя каталоги и файлы этой учетной записи останутся нетронутыми.

Полное имя пользователя::
Имя пользователя является уникальным идентификатором учетной записи в FreeBSD, однако оно не обязано соответствовать реальному имени пользователя. Это поле может содержать реальное имя пользователя. Здесь допустимы пробелы, символы подчеркивания, строка не ограничена до 8 символов.

Домашний каталог::
Домашний каталог определяется полным путем в системе. С него пользователь начнет работу после входа в систему. По общепринятому соглашению все домашние каталоги пользователей помещаются в [.filename]#/home/username# или [.filename]#/usr/home/username#. Пользователи хранят личные файлы и подкаталоги в своих домашних каталогах.

Оболочка пользователя::
Оболочка необходима пользователям как средство взаимодействия с системой. Существует множество различных видов оболочек, опытные пользователи работают с собственными настройками, которые могут быть отражены в установках их учетных записей.

[[users-superuser]]
==== Учетная запись суперпользователя

Учетная запись суперпользователя, обычно называемая `root`, используется для управления системой без ограничения привилегий. Поэтому она не должна использоваться для повседневных задач, таких как получение и отправка почты, общее исследование системы или программирование.

Суперпользователь, в отличие от обычных пользователей, может работать без ограничений и поэтому неправильное использование учетной записи суперпользователя может привести к полному уничтожению системы. Учетные записи пользователей не способны уничтожить систему вследствие ошибки, поэтому если нет необходимости в привилегиях суперпользователя, то лучше использовать учетные записи обычных пользователей везде, где это возможно.

Всегда перепроверяйте и переперепроверяйте команды, выполняемые под учетной записью суперпользователя, поскольку даже один лишний пробел или отсутствующий символ может привести к безвозвратной потере данных.

Есть несколько способов получения привилегий суперпользователя. Наименее удобный способ - войти в систему под учетной записью `root`.

Вместо этого можно воспользоваться man:su[1]. Если при запуске этой команды указывается ключ `-`, пользователь получит настройки окружения учетной записи `root`. Пользователь, запускающий эту команду, обязан входить в группу `wheel`, в противном случае команда не выполнится. Пользователь также должен знать пароль учетной записи `root`.

В следующем примере пользователь повышает привилегии для запуска команды `make install`, так как этот шаг требует прав суперпользователя. По завершении работы команды пользователь набирает `exit`, тем самым выходя из учетной записи суперпользователя и возвращая привилегии собственной учетной записи.

.Установка программы с привилегиями суперпользователя
[example]
====

[source,shell]
....
% configure
% make
% su -
Password:
# make install
# exit
%
....

====

Утилита man:su[1] прекрасно подходит для одиночных систем или небольших сетей с единственным системным администратором. В качестве альтернативы ей следует упомянуть порт или пакет package:security/sudo[]. Эта утилита предоставляет журналирование активности, а также позволяет администратору указывать перечень утилит, доступных пользователю для запуска с правами суперпользователя.

[[users-modifying]]
=== Изменение учетных записей

FreeBSD располагает набором различных команд для работы с учетными записями пользователей. <<users-modifying-utilities>> перечисляет наиболее часто используемые команды, ниже находятся примеры их использования. За исчерпывающей информацией по каждой утилите следует обратиться к соответствующим страницам справочников.
[[users-modifying-utilities]]
.Утилиты для управления учетными записями
[cols="1,1", frame="none", options="header"]
|===
| Команда
| Краткое описание

|man:adduser[8]
|Рекомендуемое приложение командной строки для добавления новых пользователей.

|man:rmuser[8]
|Рекомендуемое приложение командной строки для удаления пользователей.

|man:chpass[1]
|Гибкий инструмент для изменения информации в базе данных пользователей.

|man:passwd[1]
|Инструмент командной строки для изменения паролей пользователей.

|man:pw[8]
|Мощный и гибкий инструмент для изменения любой информации, связанной с учетными записями пользователей.
|===

[[users-adduser]]
==== `adduser`

Для добавления новых пользователей рекомендуется использовать man:adduser[8]. При добавлении нового пользователя программа автоматически обновляет [.filename]#/etc/passwd# и [.filename]#/etc/group#. Она также создает домашний каталог для нового пользователя, копируя файлы настройки по умолчанию из [.filename]#/usr/shared/skel#, и может отправлять новому пользователю приветственное сообщение электронной почтой. Эту утилиту необходимо запускать с правами суперпользователя.

Утилита man:adduser[8] является интерактивной. Для создания новой учетной записи потребуется ответить на несколько вопросов. Как показано в <<users-modifying-adduser>>, ответом считается либо ввод необходимой информации, либо нажатие клавиши kbd:[Return] для принятия значения по умолчанию, которое показано в квадратных скобках. В этом примере пользователь включен в группу `wheel`, что дает возможность ему повышать привилегии до суперпользователя при помощи man:su[1]. На последнем шаге утилита предложит создать еще одну учетную запись или завершить работу.

[[users-modifying-adduser]]
.Добавление пользователя в FreeBSD
[example]
====

[source,shell]
....
# adduser
Username: jru
Full name: J. Random User
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: wheel
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: zsh
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): yes
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): no
Goodbye!
#
....

====

[NOTE]
====
При наборе пароля текст не отображается, поэтому постарайтесь не допускать опечаток в пароле при создании учетной записи.
====

[[users-rmuser]]
==== `rmuser`

Для полного удаления пользователя из системы запустите man:rmuser[8] с правами суперпользователя. Эта программа выполняет следующие действия:

[.procedure]
====
. Если в man:crontab[1] существуют записи пользователя, то они удаляются.
. Удаляются принадлежащие пользователю задачи man:at[1].
. Уничтожаются все процессы, принадлежащие пользователю.
. Удаляется запись пользователя из локального файла паролей.
. Если домашний каталог принадлежит пользователю, то каталог удаляется.
. Удаляется принадлежащая пользователю входящая почта из [.filename]#/var/mail#.
. Удаляются все файлы, принадлежащие пользователю, из каталогов с временными файлами, например из [.filename]#/tmp#.
. Наконец, в [.filename]#/etc/group# из всех групп удаляется имя пользователя. Если после этого удаления группа остается пустой и имя группы совпадает с именем пользователя, она удаляется. Это необходимо для удаления пользовательских уникальных групп, создаваемых man:adduser[8].
====

man:rmuser[8] не может использоваться для удаления учетной записи суперпользователя, поскольку это почти всегда означает разрушение системы.

По умолчанию используется интерактивный режим, это показано в следующем примере.

.Интерактивное удаление учетной записи с помощью `rmuser`
[example]
====

[source,shell]
....
# rmuser jru
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user's home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
#
....

====

[[users-chpass]]
==== `chpass`

При помощи man:chpass[1] любой пользователь может изменять информацию, связанную с его учетной записью. И только суперпользователю разрешено менять информацию других пользователей.

При запуске без параметров (кроме необязательного имени пользователя), man:chpass[1] вызывает редактор, содержащий информацию о пользователе. Когда пользователь выходит из редактора, база данных пользователей обновляется новой информацией.

[NOTE]
====
Если утилита не была запущена с правами суперпользователя, то после выхода из редактора будет запрошен пароль пользователя.
====

В <<users-modifying-chpass-su>> суперпользователь, выполнив команду `chpass jru`, просматривает доступные для изменения поля. Если `jru` запустит эту команду, то лишь последние шесть строк будут доступны ему для редактирования. Это показано в <<users-modifying-chpass-ru>>.

[[users-modifying-chpass-su]]
.Работа с `chpass` с правами суперпользователя
[example]
====

[source,shell]
....
#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....

====

[[users-modifying-chpass-ru]]
.Работа с `chpass` с правами обычного пользователя
[example]
====

[source,shell]
....
#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....

====

[NOTE]
====
man:chfn[1] и man:chsh[1] это ссылки на man:chpass[1], как и man:ypchpass[1], man:ypchfn[1] и man:ypchsh[1]. Так как NIS поддерживается автоматически, указание `yp` перед командой не обязательно. Настройка NIS будет рассмотрена в crossref:network-servers[network-servers, Сетевые серверы].
====

[[users-passwd]]
==== `passwd`

Любой пользователь может изменить собственный пароль при помощи man:passwd[1]. Для предотвращения случайного или несанкционированного изменения, команда запрашивает текущий пароль пользователя перед установкой нового:

.Изменение пароля
[example]
====

[source,shell]
....
% passwd
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done
....

====

Суперпользователь может изменить пароль любого пользователя, указав его имя при запуске man:passwd[1]. Утилита, запущенная с правами суперпользователя, не запрашивает текущий пароль пользователя. Благодаря этому возможно устанавливать новые пароли забывчивым пользователям.

.Изменение пароля другого пользователя суперпользователем
[example]
====

[source,shell]
....
# passwd jru
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done
....

====

[NOTE]
====
Как и в случае с man:chpass[1], man:yppasswd[1] это всего лишь ссылка на man:passwd[1], так что NIS работает с обеими командами.
====

[[users-pw]]
==== `pw`

man:pw[8] это утилита командной строки для создания, удаления, модифицирования и отображения пользователей и групп. Она функционирует как внешний интерфейс к системным файлам пользователей и групп. У man:pw[8] очень мощный набор параметров командной строки, что делает это программу подходящей для использования в shell скриптах, но новым пользователям она может показаться более сложной, чем другие представленные здесь команды.

[[users-limiting]]
=== Ограничение пользователей

FreeBSD предоставляет администратору несколько способов ограничения количества занимаемых пользователями системных ресурсов. Дисковые квоты, как один из видов ограничения ресурсов, обсуждаются в отдельном разделе, остальные ограничения перечислены далее в тексте.

Дисковые квоты ограничивают объем дискового пространства, занимаемого пользователями, а также предоставляют способ быстрой проверки занимаемого объема без пересчета его каждый раз. Квоты обсуждаются в crossref:disks[quotas,Квотирование файловых систем].

Другие ограничения ресурсов включают способы ограничения использования CPU, памяти и других ресурсов, которые могут потребляться пользователем. Ограничения накладываются с помощью классов учетных записей и обсуждаются в этом разделе.

Классы учетных записей определяются в [.filename]#/etc/login.conf#, они детально описаны на странице справочника man:login.conf[5]. Каждой учетной записи присвоен класс (`default` по умолчанию), и каждому классу присвоен набор характеристик. Характеристика определяется в виде пары `имя=значение`, где _имя_ это определенный идентификатор, а _значение_ это произвольная строка, обрабатываемая в зависимости от _имени_. Настройка классов и характеристик довольно проста, и также описана в man:login.conf[5].

[NOTE]
====
FreeBSD, как правило, не читает настройки в [.filename]#/etc/login.conf# непосредственно, вместо этого она обращается к файлу базы данных [.filename]#/etc/login.conf.db# для ускорения доступа к данным. Всякий раз после редактирования [.filename]#/etc/login.conf# необходимо обновить [.filename]#/etc/login.conf.db# при помощи следующей команды:

[source,shell]
....
# cap_mkdb /etc/login.conf
....

====

Ограничения на ресурсы отличаются от обычных характеристик: во-первых, для каждого ограничения существует "мягкое" (текущее) и "жесткое" ограничение. Мягкое ограничение может настраиваться пользователем или приложением, но не может превышать жесткое ограничение. Последнее может быть уменьшено пользователем, а увеличено - лишь суперпользователем. Во-вторых, большинство ограничений ресурсов накладываются на каждый процесс определенного пользователя, а не к пользователю вообще. Эти различия диктуются особенностями обработки ограничений, а не реализацией структуры характеристик учетных записей.

Ниже приведен список наиболее часто используемых ограничений на ресурсы. Остальные, вместе с другими характеристиками, можно найти в man:login.conf[5].

`coredumpsize`::
Ограничение на размер файла дампа памяти , генерируемого программой, подчиняющееся другим ограничениям  на используемое дисковое пространство, таким как `filesize`, или дисковым квотам. Это ограничение часто используется как менее строгий метод контролирования потребления дискового пространства. Поскольку пользователь не создает файлы дампов памяти самостоятельно, и зачастую не удаляет их, установка этого параметра может предохранить пользователя от выхода за пределы ограничений на дисковое пространство, в случае если большая программа создаст файл аварийного дампа памяти.

`cputime`::
Это максимальное количество времени  ЦПУ, потребляемого пользователем. Превысившие это время процессы будут уничтожены ядром.
+

[NOTE]
====
Это ограничение потребляемого _времени_ ЦПУ, а не процентов использования ЦПУ, которые отображаются в некоторых полях man:top[1] и man:ps[1].
====

`filesize`::
Это максимальный размер файла , которым может владеть пользователь. В отличие от crossref:disks[quotas,дисковых квот], это ограничение применяется к отдельным файлам, а не ко всему набору принадлежащих пользователю файлов.

`maxproc`::
Это максимальное число процессов , которые могут быть запущены пользователем. В это число включаются и консольные, и фоновые процессы. Это ограничение не может превышать системный лимит, указываемый через переменную man:sysctl[8] `kern.maxproc`. Установка слишком жестких ограничений может стать помехой работе пользователя: зачастую ему удобно входить в систему с нескольких консолей или использовать каналы. Некоторые задачи, такие как компиляция большой программы, порождают множество процессов.

`memorylocked`::
Это максимальный объем памяти , блокировка которого может быть запрошена процессом при помощи man:mlock[2]. Некоторые критически важные для системы программы, такие как man:amd[8], блокируют отведенную процессу память так, что в случае "пробуксовывания" системы (system thrashing) они не усугубляют проблему.

`memoryuse`::
Это максимальный объем памяти , которая может быть занята процессом в любой момент времени. Сюда входит основная память и использование подкачки. Это ограничение не снимает все вопросы, связанные с использованием памяти, но для начала это подходящее ограничение.

`openfiles`::
Это максимальное количество файлов, которые могут быть открыты  процессом. В FreeBSD файлы также используются для представления сокетов и каналов IPC, поэтому не устанавливайте слишком маленькое значение. Ограничение этого параметра, устанавливаемое для всей системы, определяется переменной man:sysctl[8] `kern.maxfiles`.

`sbsize`::
Это ограничение на объем сетевой памяти, т.е. mbufs , которую может занять пользователь. В общем, это ограничение может быть использовано для ограничения сетевых взаимодействий.

`stacksize`::
Это максимальный размер сегмента стека  процесса. Сам по себе этот параметр не может ограничить размер используемой программой памяти, следовательно, его необходимо использовать вместе с другими ограничениями.

Существуют несколько других аспектов, которые необходимо учитывать при установке ограничений ресурсов. Ниже приведены некоторые общие подсказки, советы и различные комментарии.

* Процессам, загружаемым при старте системы скриптами [.filename]#/etc/rc# присваивается класс `daemon`.
* Хотя поставляемый с системой [.filename]#/etc/login.conf# - это хороший источник корректных значений для большинства ограничений, сами ограничения могут не подходить для конкретной системы. Установка слишком слабых ограничений может повлечь злоупотребления системой, а установка слишком сильных ограничений может стать помехой производительности.
* Пользователи Xorg возможно должны получить больше ресурсов, чем другие пользователи. Xorg сама по себе потребляет много ресурсов, а также провоцирует пользователей на одновременный запуск большего количества программ.
* Многие ограничения применяются к отдельным процессам, а не к пользователю вообще. Например, установка `openfiles` в 50 означает, что каждый процесс, запущенный пользователем, может открывать до 50 файлов. Общее количество файлов, которые могут быть открыты пользователем, вычисляется как `openfiles`, умноженное на `maxproc`. Это также применимо к потребляемой памяти.

За дальнейшей информацией по ограничениям на ресурсы, классам учетных записей и характеристикам, обращайтесь к man:cap.mkdb[1], man:getrlimit[2], и man:login.conf[5].

[[users-groups]]
=== Группы

Группа это список пользователей. Группа идентифицируется по имени и GID (Group ID). В FreeBSD для определения прав процесса ядро использует UID процесса, а также список групп, которым он принадлежит. В большинстве случаев, GID пользователя означает первую группу из списка.

Имена групп связываются с GID в файле [.filename]#/etc/group#. Это текстовый файл с четырьмя разделенными двоеточием полями. Первое поле это имя группы, второе это зашифрованный пароль, третье это GID, а четвертое это разделенный запятыми список членов группы. За более полным описанием синтаксиса обратитесь к man:group[5].

Суперпользователь может редактировать [.filename]#/etc/group# при помощи текстового редактора. Как вариант, можно задействовать man:pw[8] для добавления и редактирования групп. Например, для добавления группы, называемой `teamtwo`, и проверки ее существования вы можете использовать:

.Добавление группы с использованием man:pw[8]
[example]
====

[source,shell]
....
# pw groupadd teamtwo
# pw groupshow teamtwo
teamtwo:*:1100:
....

====

В этом примере число `1100` это GID группы `teamtwo`. На данный момент в `teamtwo` нет членов. Следующая команда добавит `jru` в группу `teamtwo`.

.Добавление пользователей в новую группу при помощи man:pw[8]
[example]
====

[source,shell]
....
# pw groupmod teamtwo -M jru
# pw groupshow teamtwo
teamtwo:*:1100:jru
....

====

Аргумент к параметру `-M` это разделенный запятыми список пользователей, которые добавляются в новую (пустую) группу или заменяют существующих членов группы. Что касается пользователя - это членство в группе отличается от первичной группы пользователя, указанного в файле паролей. Это значит, что пользователь не будет показан как член группы при использовании man:pw[8] `groupshow`, но будет отображен при использовании man:id[1] или похожего инструмента. Когда программа man:pw[8] задействована для добавления пользователя в группу, то она работает только с файлом [.filename]#/etc/group# и не ищет дополнительную информацию в файле [.filename]#/etc/passwd#.

.Добавление нового члена группы с использованием man:pw[8]
[example]
====

[source,shell]
....
# pw groupmod teamtwo -m db
# pw groupshow teamtwo
teamtwo:*:1100:jru,db
....

====

В этом примере аргументом к опции `-m` является разделенный запятыми список пользователей, добавляемых в группу. В отличие от предыдущего примера, пользователи добавляются в группу, а не замещают имеющийся список пользователей группы.

.Использование man:id[1] для определения принадлежности к группам
[example]
====

[source,shell]
....
% id jru
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)
....

====

В этом примере `jru` является членом групп `jru` и `teamtwo`.

За дальнейшей информацией об этой команде и о формате файла [.filename]#/etc/group# обратитесь к man:pw[8] и man:group[5].

[[permissions]]
== Права доступа

FreeBSD, являясь прямым потомком BSD UNIX(R), основывается на нескольких ключевых концепциях UNIX(R).
Первая и наиболее заметная заключается в том, что FreeBSD является многопользовательской операционной системой, способной обеспечивать одновременную работу нескольких пользователей с разными совершенно несвязанными задачами.
Система отвечает за корректное и справедливое распределение и управление запросами на доступ к оборудованию, периферийным устройствам, памяти и времени ЦПУ.

Многопользовательская среда предполагает наличие механизма регулирования прав доступа к любому ресурсу в системе. Существует три типа прав доступа: на чтение, запись и исполнение. Права сгруппированы три по три, соответственно чтение/запись/выполнение для владельца/группы/всех остальных. Численное представление:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Значение
| Права доступа
| Список файлов каталога

|0
|Ничего не разрешено
|`---`

|1
|Нельзя читать и писать, разрешено исполнять
|`--x`

|2
|Нельзя читать и исполнять, разрешено писать
|`-w-`

|3
|Нельзя читать, разрешено писать и исполнять
|`-wx`

|4
|Разрешено читать, нельзя писать и исполнять
|`r--`

|5
|Разрешено читать и исполнять, нельзя писать
|`r-x`

|6
|Разрешено читать и писать, нельзя исполнять
|`rw-`

|7
|Разрешено все
|`rwx`
|===

Используйте параметр `-l` команды man:ls[1] для получения подробного списка содержимого каталога, включающего столбец с информацией о полномочиях на файл для владельца, группы и всех остальных.
Например, команда `ls -l` в произвольном каталоге может выдать следующее:

[source,shell]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
....

Первый (самый левый) символ в первом столбце указывает на то, обычный ли это файл, каталог, специальное символьное устройство, сокет или какое-то другое псевдофайловое устройство.
В данном примере `-` указывает на то, что это обычный файл.
Следующие три символа (в данном примере это `rw-`) определяют полномочия владельца файла.
Последующие три символа, `r--`, определяют полномочия группы, которой принадлежит файл.
Последние три символа, `r--`, определяют полномочия для всего остального мира.
Дефис означает, что полномочия отсутствуют.
В этом примере полномочия установлены таким образом, что владелец может выполнять операции чтения и записи в файл, группа может читать файл, а весь остальной мир может только читать файл.
В соответствии с таблицей выше, полномочия для этого файлы могли бы быть представлены как `644`, где каждая цифра представляет три части полномочий на файл.

Как система управляет полномочиями на устройства?
Во FreeBSD большинство устройств представлено в виде файлов, которые программы могут открывать, читать и записывать в них данные.
Эти специальные файлы устройств находятся в каталоге [.filename]#/dev#.

Каталоги обрабатываются так же, как и файлы.
У них также имеются полномочия на чтение, запись и выполнение.
Бит исполнимости для каталога имеет несколько другой, отличающийся от файлов, смысл.
Когда каталог помечен как исполняемый, это означает, что в него можно перейти с помощью команды cd.
Это также означает, что можно получить доступ к файлам в данном каталоге с учётом собственных полномочий на эти файлы.

Для того, чтобы получить список файлов в каталоге, на него должны быть установлены полномочия на чтение.
Для того, чтобы удалить из каталога какой-либо файл, имя которого известно, необходимо иметь полномочия на запись _и_ исполнение каталога, содержащего соответствующий файл.

Существуют и другие права доступа, но они как правило используются в особых случаях, например, setuid-бит на выполняемые файлы и sticky-бит на каталоги.
За дополнительной информацией о файловых полномочиях и о том, как их устанавливать, обратитесь к man:chmod[1].

=== Символические обозначения прав

Символическое обозначение полномочий использует буквы вместо восьмеричных значений для назначения прав на файлы или каталоги.
Символическое обозначение использует формат (кто) (действие) (полномочия), при этом доступны следующие значения:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Опция
| Буква
| Значение

|(кто)
|u
|Пользователь (User)

|(кто)
|g
|Группа (Group)

|(кто)
|o
|Другие (Other)

|(кто)
|a
|Все (All, "world")

|(действие)
|+
|Добавление прав

|(действие)
|-
|Удаление прав

|(действие)
|=
|Явная установка прав

|(права)
|r
|Чтение (Read)

|(права)
|w
|Запись (Write)

|(права)
|x
|Выполнение (Execute)

|(права)
|t
|Sticky бит

|(права)
|s
|SUID или SGID
|===

Эти значения используются с командой man:chmod[1], но с буквами вместо цифр.
Например, следующая команда блокирует доступ сторонних пользователей к _FILE_:

[source,shell]
....
% chmod go= FILE
....

Для изменения более чем одного набора прав можно применить список значений, разделённых запятыми.
Например, следующая команда удаляет права группы и "всех остальных" на запись в _FILE_ и добавляет права на выполнение любым пользователям:

[source,shell]
....
% chmod go-w,a+x FILE
....

=== Флаги файлов в FreeBSD

Кроме прав доступа к файлам, FreeBSD поддерживает использование "файловых флагов".
Эти флаги привносят дополнительный уровень защиты и контроля над файлами, но не каталогами.
При помощи этих флагов даже пользователь `root` может быть ограничен в удалении или изменении файлов.

Файловые флаги изменяются при помощи man:chflags[1].
К примеру, для установки системного флага неудаляемости на файл [.filename]#file1#, выполните следующую команду:

[source,shell]
....
# chflags sunlink file1
....

Чтобы отключить системный флаг неудаляемости, укажите "no" перед `sunlink`:

[source,shell]
....
# chflags nosunlink file1
....

Чтобы просмотреть флаги какого-либо файла, используйте команду man:ls[1] с параметрами `-lo`:

[source,shell]
....
# ls -lo file1
....

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

Некоторые файловые флаги могут быть установлены или сняты только пользователем `root`.
В остальных случаях флаги файла может устанавливать его владелец.
Обратитесь к man:chflags[1] и man:chflags[2] для получения дополнительной информации.

=== Права доступа `setuid`, `setgid` и `sticky`

В дополнение к рассмотренным выше правам доступа и флагам файлов необходимо также упомянуть еще три бита прав доступа, о которых должны знать все системные администраторы. Это такие биты, как `setuid`, `setgid` и `sticky`.

Эти биты играют важную роль в определённых моментах работы UNIX(R), так как они предоставляют функциональность, расширяющую права обычного пользователя.
Чтобы понять, как они работают, необходимо отметить различия между реальным идентификатором пользователя (UID) и действующим идентификатором пользователя (effective UID, EUID).

Реальный UID - это идентификатор пользователя, запустившего процесс на выполнение. Действующий UID (EUID) - это идентификатор пользователя, с которым на самом деле выполняется процесс.
Например, утилита man:passwd[1] во время смены пароля пользователем запускается с реальным ID пользователя.
Однако для того, чтобы актуализировать базу данных паролей, команда работает с действующим ID пользователя `root`.
Это позволяет пользователям изменять их пароли и не наблюдать ошибку `Permission Denied`.

Полномочие setuid устанавливается добавлением цифры четыре (4) перед численным представлением прав доступа, например:

[source,shell]
....
# chmod 4755 suidexample.sh
....

Теперь права доступа на файл `suidexample.sh` выглядят подобно следующему:

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

Заметьте, что `s` теперь является частью набора полномочий, относящихся к владельцу файла, и заменяет бит выполнимости.
Это позволяет работать утилитам, которым требуются более высокие полномочия, таким как `passwd`.

[NOTE]
====
Указание параметра `nosuid` при запуске команды man:mount[8] приводит к тому, что такие программы перестают работать без выдачи предупреждений пользователям.
Указанная возможность не является абсолютно надёжно работающей, так как обработчик `nosuid` может её обойти.
====

Чтобы убедиться в этом, откройте два терминала.
В одном из них запустите команду `passwd` с правами обычного пользователя.
Пока она ждёт ввода нового пароля, просмотрите таблицу процессов и обратите внимание на информацию о пользователе процесса `passwd`.

В терминале А:

[source,shell]
....
Changing local password for trhodes
Old Password:
....

В терминале Б:

[source,shell]
....
# ps aux | grep passwd
....

[source,shell]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

Как уже было сказано, утилита `passwd` запущена с правами обычного пользователя, но ее действующий UID - `root`.

Полномочие `setgid` выполняет ту же функцию, что и `setuid`; отличие заключается в том, что изменяются настройки прав для группы.
Когда выполняются приложение или утилита с этой настройкой, то им назначаются полномочия на основании группы, владеющей файлом, а не пользователя, запустившего процесс.

Чтобы установить на какой-либо файл полномочие `setgid`, выполните команду `chmod`, добавив цифру два (2) в начале:

[source,shell]
....
# chmod 2755 sgidexample.sh
....

В следующей выдаче обратите внимание на наличие `s` в перечне прав доступа для группы:

[source,shell]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
В этих примерах, несмотря на то, что сценарий оболочки является исполняемым файлом, он не будет выполняться с другим действующим идентификатором пользователя (EUID). Так происходит потому, что сценариям командного интерпретатора недоступен системный вызов man:setuid[2].
====

Позволяя повышать права доступа, биты полномочий `setuid` и `setgid` могут снижать безопасность системы.
Третье специальное полномочие, `sticky bit`, может усиливать безопасность системы.

`Sticky bit`, будучи установленным на каталог, позволяет производить удаление файла только его владельцем.
Это полезно для предотвращения удаления файлов в общедоступных каталогах, таких как [.filename]#/tmp#, пользователями, которые не являются их владельцами.
Чтобы использовать это полномочие, добавьте единицу (1) перед набором прав доступа:

[source,shell]
....
# chmod 1777 /tmp
....

Полномочие `sticky bit` будет отображаться как `t` в самом конце набора прав доступа:

[source,shell]
....
# ls -al / | grep tmp
....

[source,shell]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

[[dirstructure]]
== Структура каталогов

Структура каталогов FreeBSD является фундаментальным вопросом в достижении общего понимания устройства всей системы.
Самым важным понятием является, несомненно, корневой каталог, или "/".
Этот каталог является самым первым, монтируемым на этапе загрузки и содержащим базовую систему, необходимую для подготовки операционной системы к работе в многопользовательском режиме.
Корневой каталог также содержит точки монтирования для других файловых систем, которые монтируются во время перехода к функционированию в многопользовательском режиме.

Точкой монтирования называется каталог, находящийся в родительской (обычно - корневой) файловой системе, к которому может быть подсоединена другая файловая система.
Более глубоко это описывается в <<disk-organization>>.
К стандартным точкам монтирования относятся [.filename]#/usr#, [.filename]#/var#, [.filename]#/tmp#, [.filename]#/mnt# и [.filename]#/cdrom#.
Эти каталоги обычно перечислены как отдельные записи в файле [.filename]#/etc/fstab#.
Этот файл является таблицей с различными файловыми системами и точками монтирования, которая считывается системой.
Большинство файловых систем в [.filename]#/etc/fstab# монтируются во время загрузки автоматически из скрипта man:rc[8], если только в соответствующей записи для них не указано `noauto`.
Более подробную информацию можно найти в <<disks-fstab>>.

Полное описание иерархии файловой системы есть в man:hier[7].
Таблица ниже содержит краткое описание наиболее часто упоминаемых каталогов.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Каталог
| Описание

|[.filename]#/#
|Корневой каталог файловой системы.

|[.filename]#/bin/#
|Основные утилиты, необходимые для работы как в однопользовательском, так и в многопользовательском режимах.

|[.filename]#/boot/#
|Программы и конфигурационные файлы, необходимые для нормальной загрузки операционной системы.

|[.filename]#/boot/defaults/#
|Конфигурационные файлы, используемые в процессе загрузки операционной системы, со стандарными настройками. Обратитесь к man:loader.conf[5] для получения более подробной информации.

|[.filename]#/dev/#
|Файлы устройств. Обратитесь к man:intro[4] для получения более подробной информации.

|[.filename]#/etc/#
|Основные конфигурационные файлы системы и скрипты.

|[.filename]#/etc/defaults/#
|Конфигурационные файлы системы со стандартными настройками. Обратитесь к man:rc[8] для получения более подробной информации.

|[.filename]#/etc/mail/#
|Конфигурационные файлы для систем обработки почты (например, man:sendmail[8]).

|[.filename]#/etc/namedb/#
|Конфигурационные файлы для `named`. Обратитесь к man:named[8] для получения более подробной информации.

|[.filename]#/etc/periodic/#
|Файлы сценариев, выполняемые ежедневно, еженедельно и ежемесячно при помощи man:cron[8]. Обратитесь к man:periodic[8] для получения более подробной информации.

|[.filename]#/etc/ppp/#
|Конфигурационные файлы для `ppp`, как это описано в man:ppp[8].

|[.filename]#/mnt/#
|Пустой каталог, часто используемый системными администраторами как временная точка монтирования.

|[.filename]#/proc/#
|Файловая система процессов. Обратитесь к man:procfs[5] и man:mount_procfs[8] для получения более подробной информации.

|[.filename]#/rescue/#
|Статически скомпилированные программы для восстановления после сбоев, как описано в man:rescue[8].

|[.filename]#/root/#
|Домашний каталог пользователя `root`.

|[.filename]#/sbin/#
|Системные утилиты и утилиты администрирования, необходимые для работы как в однопользовательском, так и в многопользовательском режимах.

|[.filename]#/tmp/#
|Временные файлы, которые обычно _не_ сохраняются при перезагрузке системы. Размещаемая в оперативной памяти файловая система часто монтируется в [.filename]#/tmp#. Это может быть автоматизировано с помощью переменных, относящихся к tmpmfs, в man:rc.conf[5] или с помощью записи в [.filename]#/etc/fstab#; обратитесь к man:mdmfs[8] для получения более подробной информации.

|[.filename]#/usr/#
|Большинство пользовательских утилит и приложений.

|[.filename]#/usr/bin/#
|Пользовательские утилиты и приложения общего назначения.

|[.filename]#/usr/include/#
|Стандартные заголовочные файлы для языка C.

|[.filename]#/usr/lib/#
|Файлы стандартных библиотек.

|[.filename]#/usr/libdata/#
|Файлы данных для различных утилит.

|[.filename]#/usr/libexec/#
|Системные даемоны и системные утилиты, вызываемые другими программами.

|[.filename]#/usr/local/#
|Локальные исполнимые файлы и библиотеки. Также используется в качестве стандартного целевого каталога в рамках механизма портов. Внутри [.filename]#/usr/local# иерархия каталогов должна следовать man:hier[7] для [.filename]#/usr#. Исключение составляют каталог [.filename]#man#, который расположен непосредственно в [.filename]#/usr/local#, а не в [.filename]#/usr/local/share#, и документация портов, которая расположена в [.filename]#share/doc/port#. 

|[.filename]#/usr/obj/#
|Архитектурно-зависимые файлы и каталоги, образующиеся в процессе сборки системы из исходных текстов в [.filename]#/usr/src#.

|[.filename]#/usr/ports/#
|Коллекция портов FreeBSD (опционально).

|[.filename]#/usr/sbin/#
|Системные даемоны и системные утилиты, запускаемые пользователями.

|[.filename]#/usr/shared/#
|Архитектурно-независимые файлы.

|[.filename]#/usr/src/#
|Исходные тексты BSD и/или программ.

|[.filename]#/var/#
|Файлы журналов общего назначения, временные, перемещаемые файлы и файлы очередей. Файловая система в памяти иногда монтируется в [.filename]#/var#. Это может быть автоматизированно с помощью переменных, относящихся к varmfs, в man:rc.conf[5] или с помощью записи в [.filename]#/etc/fstab#; обратитесь к man:mdmfs[8] для получения подробной информации.

|[.filename]#/var/log/#
|Различные файлы системных журналов.

|[.filename]#/var/mail/#
|Почтовые ящики пользователей.

|[.filename]#/var/spool/#
|Файлы очередей печати, почты, и пр.

|[.filename]#/var/tmp/#
|Временные файлы, которые обычно сохраняются после перезагрузки системы, если только [.filename]#/var# не является файловой системой, размещённой в оперативной памяти.

|[.filename]#/var/yp/#
|Карты (maps) NIS.
|===

[[disk-organization]]
== Организация дисков

Наименьшей единицей, которую FreeBSD использует для поиска файлов, является имя файла.
Имена файлов чувствительны к регистру, поэтому [.filename]#readme.txt# и [.filename]#README.TXT# - два разных файла.
FreeBSD не использует расширение файла для определения того, является ли файл программой, документом или какой-то иной формой данных.

Файлы хранятся в каталогах. Каталоги могут не содержать файлов, или могут содержать много сотен файлов.
Каталог также может содержать другие каталоги, что позволяет создавать иерархию вложенных друг в друга каталогов для организации данных.

Обращение к файлам и каталогам осуществляется указанием имени файла или каталога, дополняемого прямым слэшем `/`, за которым при необходимости могут следовать имена других каталогов.
К примеру, если каталог [.filename]#foo# содержит каталог [.filename]#bar#, который содержит файл [.filename]#readme.txt#, то полным именем, или _путём_ файла будет является [.filename]#foo/bar/readme.txt#.
Заметьте, что это отличается от Windows(R), в которой для отделения имён файлов и каталогов используется `\`.
FreeBSD не использует символьных или каких-либо других именований устройств в пути.
К примеру, набирать [.filename]#c:/foo/bar/readme.txt# во FreeBSD не нужно.

Каталоги и файлы хранятся в файловой системе.
Каждая файловая система на самом верхнем уровне содержит ровно один каталог, называемый _корневым каталогом_ этой файловой системы.
Этот корневой каталог может содержать другие каталоги.
Одна из файловых систем назначается _корневой файловой системой_, или `/`.
Любая другая файловая система _монтируется_ в корневой файловой системе.
Вне зависимости от того, сколько дисков присутствует в вашей системе FreeBSD, каждый каталог будет выглядеть как являющийся частью одного диска.

Предположим, у вас есть три файловых системы: `A`, `B`, и `C`. Каждая файловая система имеет один корневой каталог, в котором содержатся другие каталоги, называемые `A1`, `A2` (и аналогично `B1`, `B2` и `C1`, `C2`).

Назовём `A` корневой файловой системой.
Если бы вы воспользовались командой `ls` для просмотра содержимого этого каталога, то увидели бы два подкаталога, `A1` и `A2`.
Дерево каталогов выглядит так:

image::example-dir1.png[]

Файловая система должна быть смонтирована в каталог другой файловой системы.
При монтировании файловой системы `B` в каталог `A1`, корневой каталог `B` заменяет `A1`, а каталоги в `B` отображаются в соответствии с этим:

image::example-dir2.png[]

Если потребуется, любые файлы из каталогов `B1` или `B2` могут быть получены через путь [.filename]#/A1/B1# или [.filename]#/A1/B2#. Все файлы, бывшие в [.filename]#/A1#, временно скрыты. Они появятся, если `B` будет _размонтирована_ с A.

Если `B` была смонтирована на `A2,` диаграмма будет выглядеть так:

image::example-dir3.png[]

а пути будут [.filename]#/A2/B1# и [.filename]#/A2/B2# соответственно.

Файловые системы могут быть смонтированы одна на другую. Продолжая предыдущий пример, файловая система `C` может быть смонтирована на каталог `B1` файловой системы `B` в таком порядке:

image::example-dir4.png[]

Или `C` может быть смонтирована прямо на файловую систему `A`, на каталог `A1`:

image::example-dir5.png[]

Это похоже, хотя и не идентично, на команду `join` из MS-DOS(R).

Как правило, вы создаёте файловые системы во время установки FreeBSD и решаете, куда их монтировать, ничего не меняя, пока не понадобится добавить новый диск.

Можно создать одну большую корневую файловую систему и не создавать других. У такого подхода есть несколько недостатков и одно преимущество.

.Преимущества нескольких файловых систем
* Различные файловые системы могут иметь различные _параметры монтирования_. Например, корневая файловая система может быть смонтирована в режиме доступности только для чтения, что делает невозможным случайное удаление или редактирование какого-то критически важного файла. Отделение файловых систем, доступных пользователям для записи, таких как [.filename]#/home#, от других файловых систем позволяет монтировать их с параметром _nosuid_. Этот параметр отменяет действие битов _suid_/ _guid_ на исполняемых файлах в этой файловой системе, что потенциально повышает безопасность.
* FreeBSD автоматически оптимизирует расположение файлов на файловой системе в зависимости от того, как файловая система используется. Файловая система, содержащая множество мелких часто записываемых файлов, будет иметь оптимизацию, отличную от таковой для файловой системы, содержащей несколько больших файлов. На одной большой файловой системе эта оптимизация не работает.
* Файловые системы FreeBSD очень устойчивы к внезапному отключению. Тем не менее, потеря питания в критический момент все же может повредить структуру файловой системы. Разделение данных на несколько файловых систем повышает шансы, что система все-таки будет работать и делает более легким восстановление с резервной копии.

.Преимущество одной файловой системы
* Размер файловых систем фиксирован. Если вы создаете файловую систему при установке FreeBSD и задаете определенный размер, позднее вы можете обнаружить что нужен раздел большего размера. Это не так легко сделать без резервного копирования, создания файловых систем нового размера и последующего восстановления сохраненных данных.
+
[IMPORTANT]
====
Во FreeBSD имеется команда man:growfs[8], которая позволяет увеличивать размер файловой системы на лету, устраняя это ограничение.
====

Файловые системы содержатся в разделах. Этот термин не имеет того же смысла, что и при более раннем его использовании в этой главе, из-за наследия UNIX(R) в FreeBSD. Каждый раздел обозначается буквой от `a` до `h`. Каждый раздел может содержать только одну файловую систему, это значит что файловая система может быть описана ее точкой монтирования в файловой иерархии, или буквой раздела, в котором она содержится.

FreeBSD также использует дисковое пространство для _раздела подкачки_, обеспечивающего работу _виртуальной памяти_. Это позволяет вашему компьютеру работать так, как если бы у него было больше памяти, чем есть на самом деле. Когда у FreeBSD кончается память, она перемещает часть данных, не используемых в данный момент, в раздел подкачки и возвращает их обратно (перемещая в подкачку что-то другое), когда они нужны.

По некоторым разделам есть определенные соглашения.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Раздел
| Соглашение

|`a`
|Как правило, содержит корневую файловую систему.

|`b`
|Как правило, содержит пространство подкачки.

|`c`
|Как правило, такого же размера, что и весь слайс (slice). Это позволяет утилитам, которым нужно работать над всем слайсом, таким, как сканер плохих блоков, работать с разделом `c`. В обычной ситуации не нужно создавать файловую систему на этом разделе.

|`d`
|Раздел `d` создавался для специальных целей, хотя сейчас они не актуальны и `d` может быть задействован как обычный раздел.
|===

Каждый раздел, содержащий файловую систему, размещается в сущности, называемом во FreeBSD _слайсом (slice)_. Слайс является термином FreeBSD для сущностей, которые обычно называют разделами, и, повторим это снова, это из-за того, что в основе FreeBSD лежит UNIX(R). Слайсы нумеруются с 1 по 4.

Номера слайсов следуют за именем устройства, предваряемые строчной `s`, начиная с 1. Так "da0__s1__" это первый слайс первого SCSI устройства. Может быть только четыре физических слайса на диске, но могут быть логические слайсы нужного типа внутри физических слайсов. Эти дополнительные слайсы нумеруются начиная с 5, так что "ad0__s5__" это первый дополнительный слайс на первом IDE диске. Эти устройства используются файловыми системами, занимающими весь слайс.

Слайсы, "эксклюзивно выделенные (dangerously dedicated)" физические устройства и другие устройства содержат _разделы_, представляемые буквами от `a` до `h`. Эти буквы добавляются к имени устройства. "da0__a__" это раздел a на первом устройстве da, который "эксклюзивно выделен". "ad1s3__e__" это пятый раздел в третьем слайсе второго IDE диска.

Наконец, каждый диск идентифицирован. Имя диска начинается с кода, обозначающего тип диска, затем идет номер диска. В отличие от слайсов, нумерация дисков начинается с 0. Основные коды, которые вам могут встретиться, есть в <<basics-dev-codes>>.

Для ссылки на раздел указывайте имя диска, `s`, номер слайса, а затем букву раздела.
Примеры показаны в <<basics-disk-slice-part>>.

<<basics-concept-disk-model>> показывает концептуальную модель рабиения диска.

Для установки FreeBSD настройте дисковые слайсы, создайте разделы внутри слайса, который будет использован для FreeBSD, создайте файловую систему (или пространство подкачки) в каждом разделе и решите, куда будет смонтирована каждая из файловых систем.

[[basics-dev-codes]]
.Коды дисковых устройств
[cols="1,1", frame="none", options="header"]
|===
| Код
| Значение

|[.filename]#ad#
|ATAPI (IDE) диск

|[.filename]#da#
|SCSI direct access диск

|[.filename]#acd#
|ATAPI (IDE) CDROM

|[.filename]#cd#
|SCSI CDROM

|[.filename]#fd#
|Floppy disk
|===

[[basics-disk-slice-part]]
.Пример имен диска, слайса, и раздела
[example]
====
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Имя
| Значение

|`ad0s1a`
|Первый раздел (`a`) на первом слайсе (`s1`) первого IDE диска (`ad0`).

|`da1s2e`
|Пятый раздел (`e`) на втором слайсе (`s2`) второго SCSI диска (`da1`).
|===
====

[[basics-concept-disk-model]]
.Концептуальная модель диска
[example]
====
Эта диаграмма показывает первый подключенный к системе IDE диск с точки зрения FreeBSD. Предположим, что размер диска 4 GB, и он содержит два 2 GB слайса (MS-DOS(R) разделы). Первый слайс содержит MS-DOS(R) диск, [.filename]#C:#, а второй слайс содержит установленную FreeBSD. В этом примере у установленной FreeBSD есть три раздела с данными и раздел подкачки.

Каждый из трёх разделов будет содержать файловую систему.
Раздел `a` будет использован для корневой файловой системы, `e` для иерархии каталогов [.filename]#/var/#, а `f` для иерархии каталогов [.filename]#/usr/#.

image::disk-layout.png[]

====

[[mount-unmount]]
== Монтирование и размонтирование файловых систем

Файловая система лучше всего представима в виде дерева, которое, если можно так выразиться, посадили в [.filename]#/#.
Каталоги [.filename]#/dev#, [.filename]#/usr# и прочие, находящиеся в корневом каталоге, являются ветвями и, в свою очередь, могут иметь собственные ветви, такие как [.filename]#/usr/local#, и так далее.

Имеются разные основания для того, чтобы размещать некоторые из этих каталогов в отдельных файловых системах.
[.filename]#/var# содержит каталоги [.filename]#log/#, [.filename]#spool/# и разные виды временных файлов и, таким образом, может полностью заполнить свободное дисковое пространство.
Заполнение корневой файловой системы нежелательно, поэтому часто предпочитают отделить [.filename]#/var# от [.filename]#/#.

Часто бывает так, что некоторые разделы файловой системы расположены на разных физических носителях (дисках, CDROM), виртуальных или сетевых (например, crossref:network-servers[network-nfs,"сетевая файловая система (Network File System, NFS)"]). В этом случае узлы файловой иерархии будут расположены на разных файловых системах.

[[disks-fstab]]
=== Файл [.filename]#fstab#

В процессе crossref:boot[boot,загрузки] файловые системы, перечисленные в [.filename]#/etc/fstab#, монтируются автоматически, за исключением тех, для которых указан параметр `noauto`.
Этот файл содержит записи в следующем формате: 

[.programlisting]
....

	устройство	/точка-монтирования	тип файловой системы	опции	частота дампов	порядок проверки
....

`устройство`::
Имя существующего устройства, соответствующее описанному в crossref:disks[disks-naming,Имена устройств].

`точка монтирования`::
Существующий каталог, предназначенный для монтирования файловой системы.

`тип файловой системы`::
Тип файловой системы, который передается программе man:mount[8]. По умолчанию FreeBSD использует `ufs`.

`опции`::
Например, `rw`, для монтирования файловой системы в режиме "чтение-запись", или `ro`, для режима "только чтение", за которыми могут следовать и другие опции. Довольно часто используется опция `noauto`, чтобы не монтировать автоматически файловые системы в процессе загрузки. Остальные параметры перечислены в man:mount[8].

`частота дампов`::
Используется утилитой man:dump[8] для указания файловых систем, с которых требуется снимать копии. При отсутствии этого параметра он принимает нулевое значение.

`порядок проверки`::
Определяет порядок, в котором должны проверяться файловые системы. Для файловых систем, которые должны быть пропущены при проверке, параметр `passno` должен быть установлен в нулевое значение. Корневая файловая система должна проверяться в первую очередь и иметь значение `passno`, установленное равным единице. Для других файловых систем значение этого параметра должно превышать единицу. Если две и более файловые системы имеют одинаковое значение `passno`, то man:fsck[8] будет пытаться проверять файловые системы параллельно, если это возможно.

Обратитесь к man:fstab[5] для получения дополнительной информацией о формате файла [.filename]#/etc/fstab# и его параметрах.

[[disks-mount]]
=== Команда `mount`

Файловые системы монтируются при помощи man:mount[8].
Самый простой формат имеет следующий вид:

[example]
====

[source,shell]
....
# mount устройство точка-монтирования
....

====

Эта команда имеет достаточное количество параметров, описанных в man:mount[8].
Самые часто используемые параметры таковы:

.Опции монтирования
`-a`::
Смонтировать все файловые системы, перечисленные в файле [.filename]#/etc/fstab#, за исключением тех, что помечены как "noauto", исключены параметром `-t` или уже смонтированы.

`-d`::
Сделать все, кроме самого системного вызова mount. Эта опция полезна вместе с флагом `-v` для определения того, что на самом деле пытается сделать man:mount[8].

`-f`::
Принудительное монтирование непроверенного раздела (опасно) или аннулирование полномочий на операции записи данных при понижении статуса монтирования файловой системы с доступной на чтение-запись на доступной только для операций чтения.

`-r`::
Монтировать файловую систему в режиме только для чтения. Идентично использованию параметра `-o ro`.

`-t` _fstype_::
Смонтировать указанный тип файловой системы или, в случае указания `-a`, монтировать файловые системы только данного типа. По умолчанию применяется тип файловой системы "ufs".

`-u`::
Обновить опции монтирования для файловой системы.

`-v`::
Выдавать более подробную информацию.

`-w`::
Монтировать файловую систему в режиме "чтение-запись".

Следующие значения могут быть переданы в качестве аргументов `-o` в виде списка значений, разделённых запятыми:

noexec::
Запрет на исполнение бинарных файлов на файловой системе (тоже полезная опция для повышения безопасности системы).

nosuid::
Игнорировать setuid и setgid биты на файловой системе (еще одна полезная опция для повышения безопасности системы).

[[disks-umount]]
=== Команда `umount`

Для размонтирования файловой системы используйте man:umount[8].
Эта команда принимает один параметр, который может соответствовать точке монтирования, имени устройства либо принимать значение `-a` или `-A`.

Во всех вариантах принимается параметр `-f` для принудительного размонтирования и `-v` для выдачи подробной информации.
Имейте в виду, что применение `-f` в целом не рекомендутся, так как может привести к аварийному завершению работы компьютера или повредить данные в файловой системе.

Для размонтирования всех смонтированных файловых систем или только тех типов файловых систем, что перечислены после параметра `-t`, воспользуйтесь параметрами `-a` и `-A`.
Заметьте, что при использовании `-A` попытка размонтирования корневой файловой системы не предпринимается.

[[basics-processes]]
== Процессы

FreeBSD является многозадачной операционной системой.
Каждая программа, выполняющаяся в некоторый выбранный момент времени, называется _процессом_.
Каждая запускаемая команда порождает хотя бы один новый процесс, и имеется определённое количество системных процессов, которые запускает FreeBSD.

Каждый процесс идентифицируется уникальным номером, называемым _идентификатором процесса_ (_process ID_) или _PID_.
Подобно файлам, у каждого процесса имеется один владелец и группа, при этом полномочия владельца и группы используются для определения того, какие файлы и устройства могут быть открыты процессом.
У большинства процессов также есть родительский процесс, которых их запустил.
Например, командная оболочка является процессом, и любая команда, запущенная из командной оболочки, является процессом, для которого командная оболочка является родительским процессом.
Исключением из этого правила является специальный процесс, который называется man:init[8], который всегда является первым процессом, запускаемым во время загрузки, и который всегда имеет PID, равный 1.

Для просмотра процессов в системе используйте man:ps[1] и man:top[1].
Для выдачи статичного списка выполняемых в данный момент процессов, их PID, объёма используемой ими памяти и команды, которой они были запущены, используйте `ps`.
Для отображения всех выполняющихся процессов и обновления этого списка каждые несколько секунд в целях интерактивного наблюдения за тем, что делает компьютер, используйте `top`.

По умолчанию `ps` показывает пользователю только те команды, которые запущены пользователем и владельцем которых он является.
К примеру:

[source,shell]
....
% ps
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish
....

Выдача команды man:ps[1] организована в несколько столбцов.
Столбец `PID` отображает идентификатор процесса.
PID назначаются начиная с 1 и увеличиваются до 99999, а затем отсчёт начинается с начала.
Однако PID не назначается повторно, если он уже используется.
Столбец `TT` показывает терминал (tty), на котором выполняется программа, а `STAT` показывает состояние программы.
`TIME` соответствует количеству времени, которое программа выполняется на центральном процессоре.
Обычно это не то же самое время, что прошло с момента запуска программы, поскольку большинство программ проводят много времени в ожидании некоторого события, прежде чем занять время процессора.
Наконец, `COMMAND` содержит команду, которая использовалась для запуска программы.

У man:ps[1] есть множество различных опций, влияющих на выводимую информацию. Один из наиболее полезных наборов опций это `auxww`.
`a` позволяет показать информацию о всех запущенных процессах всех пользователей.
`u` показывает имя пользователя, владеющего процессом, и информацию об используемой памяти. `x` показывает информацию о процессах-даемонах и `ww` указывает man:ps[1] показать всю командную строку для каждого процесса, вместо обрезания ее, когда она станет слишком длинной, чтобы уместиться на экран.

Вывод man:top[1] похож на только что описанный. Обычно он выглядит так:

[source,shell]
....
% top
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...
....

Вывод разбит на два раздела.
Заголовок (первые пять строк) показывает PID последнего запущенного процесса, среднее значение загрузки системы (которое показывает насколько система занята), время работы системы с последней перезагрузки и текущее время.
Другие цифры заголовка относятся к количеству запущенных процессов (в данном примере 47), количеству использованной оперативной памяти и пространства подкачки, а также количество времени, проводимого системой в различных состояниях центрального процессора.

Под заголовком размещены несколько столбцов, содержащих информацию, похожую на результат работы man:ps[1], такую как PID, имя пользователя, объём времени ЦПУ и команда, которая запустила процесс.
По умолчанию man:top[1] показывает также объём памяти, занятой процессом.
Эта информация разделена на два столбца: один для суммарного объёма и один для занимаемого.
Суммарный объём соответствует тому, что требовался приложению, а занимаемый соответствует объёму, фактически используемому в данный момент.
В этом примере приложению Netscape требовалось почти 30 МБ оперативной памяти, однако используется в данный момент только 9 MB.

man:top[1] автоматически обновляет экран каждые две секунды.
Другое значение этого временного интервала может быть задано при помощи параметра `-s`.

[[basics-daemons]]
== Даемоны, сигналы, уничтожение процессов

При использовании текстового редактора им можно легко управлять и загружать файлы, поскольку редактор предоставляет такие возможности, а также потому что редактор присоединён к _терминалу_.
Некоторые программы не предназначены для обработки постоянного пользовательского ввода, и они отсоединяются от терминала при первой возможности.
Например, веб-сервер обрабатывает веб-запросы, а не пользовательский ввод.
Почтовые серверы являются ещё одним примером приложений такого типа.

Такие программы известны под названием _даемоны_.
Понятие даемона пришло из греческой мифологии и представляет собой сущность, которая не является ни хорошей, ни плохой и невидимо выполняет полезные задачи.
Это объясняет тот факт, что талисманом BSD является добродушно выглядящий даемон в кедах и с вилами.

Есть соглашение, по которому имя программы, которая обычно запускается как даемон, заканчивается на "d".
BIND это Berkeley Internet Name Domain, при этом фактически запускаемая программа называется `named`.
Программа веб-сервера Apache называется `httpd`, а даемоном очереди печати является `lpd`.
Это соглашение касается только именования.
К примеру, основной почтовый даемон для Sendmail называется `sendmail`, а не `maild`.

Одним из способов взаимодействия с даемоном или любым другим работающим процессом является отправка ему _сигнала_ при помощи команды man:kill[1].
Имеется множество различных сигналов; некоторые из них имеют специальное значение, тогда как другие описаны в документации приложения.
Пользователь может посылать какой-либо сигнал только тем процессам, владельцем которых он является, а отправка сигнала процессу какого-то другого пользователя приведёт к ошибке запрета доступа.
Исключением является пользователь `root`, который может отправлять сигналы чьим угодно процессам.

FreeBSD также может отправлять сигнал процессу.
Если приложение написано некорректно и пытается обратиться к области памяти, к которой оно не должно обращаться, FreeBSD посылает процессу сигнал _нарушение сегментации_ (`SIGSEGV`).
Если приложение использует системный вызов man:alarm[3], чтобы получить уведомление по истечении определённого периода времени, то ему будет отправлен сигнал Alarm (`SIGALRM`).

Для остановки процесса могут использоваться два сигнала: `SIGTERM` и `SIGKILL`.
`SIGTERM` является вежливым способом завершить процесс, так как процесс может считать сигнал, закрыть какие-либо протоколирующие файлы, которые он мог открыть, и завершить то, что он делал до завершения работы.
В некоторых случаях процесс может даже игнорировать `SIGTERM`, если выполняет задачу, которая не может быть прервана.

`SIGKILL` не может быть проигнорирован процессом.
Этот сигнал говорит "Меня не волнует что ты делаешь - остановись немедленно".
Отправка процессу `SIGKILL` обычно остановит этот процесс тотчас же.

[NOTE]
====
Существует несколько задач, которые не могут быть прерваны.
К примеру, если процесс пытается выполнить чтение файла, находящегося на другом компьютере в сети, а другой компьютер недоступен, то такой процесс называют "непрерываемым".
В конце концов время процесса истечёт, обычно после двух минут ожидания.
Как только такой таймаут случится, процесс будет прекращён.
====

Другими часто используемыми сигналами являются `SIGHUP`, `SIGUSR1` и `SIGUSR2`.
Это сигналы общего назначения, и различные приложения будут реагировать на них по-разному.

Например, после внесения изменений в конфигурационный файл веб-сервера ему нужно указать на повторное считывание настроек.
Перезапуск `httpd` привёл бы к краткосрочной недоступности веб-сервера.
Вместо этого отправьте даемону сигнал `SIGHUP`.
Имейте в виду, что разные даемоны будут вести себя по-разному, поэтому обратитесь к документации по даемону для определения того, достигнет ли `SIGHUP` желаемых результатов.

[.procedure]
====
*Procedure: Отправка сигнала процессу*

Этот пример показывает как послать сигнал man:inetd[8]. Файл конфигурации `inetd`[.filename]#/etc/inetd.conf#, `inetd` перечитает этот файл, если ему отправить сигнал `SIGHUP`.

. Определите PID процесса, которому вы хотите отправить сигнал, при помощи man:pgrep[1]. В данном примере PID для man:inetd[8] равен 198:
+
[source,shell]
....
% pgrep -l inetd
198  inetd -wW
....
+ 

. Используйте man:kill[1] для отправки сигнала. Поскольку владельцем man:inetd[8] является `root`, сначала воспользуйтесь командой man:su[1] для получения прав `root`.
+
[source,shell]
....
% su
Password:
# /bin/kill -s HUP 198
....
+
Как и большинство команд UNIX(R), man:kill[1] ничего не выдаёт, если отрабатывает нормально. Если вы посылаете сигнал процессу, которым не владеете, то наоборот, вы увидите `kill: _PID_: Operation not permitted`. При неправильно набранном PID сигнал будет направлен либо другому процессу, что может привести к неприятным последствия, либо в адрес PID, который в данный момент не используется, что приведёт к ошибке `kill: _PID_: No such process`.
+
[NOTE]
.Зачем использовать `/bin/kill`?
======
Во многих оболочках команда `kill` является встроенной, а это означает, что командный процессор вместо запуска [.filename]#/bin/kill# будет посылать сигнал напрямую.
Учитывайте тот факт, что разные командные процессоры имеют разный синтаксис для указания имени отправляемого сигнала.
Вместо того, чтобы пытаться выучить их все, гораздо проще может оказаться прямое использование `/bin/kill _..._`.
======
====

При отправке других сигналов замените `TERM` или `KILL` в командной строке на имя другого сигнала.

[IMPORTANT]
====
Прекращение случайного процесса в системе может быть плохой затеей.
В частности, man:init[8], чей PID равен 1, является особенным процессом.
Выполнение `/bin/kill -s KILL 1` является быстрым и нерекомендуемым способом завершить работу системы.
_Всегда_ дважды проверяйте параметры запуска man:kill[1] _перед_ тем, как нажать на kbd:[Return].
====

[[shells]]
== Интерпретатор команд

FreeBSD предоставляет интерфейс командной строки, который называют оболочкой или командным процессором, а также интерпретатором командной строки.
Командный процессор получает команды из канала ввода и исполняет их.
Многие командные интерпретаторы имеют встроенные функции, помогающие выполнять такие повседневной задачи, как управление файлами, включая их массовую обработку, редактирование командной строки, работа с макрокомандами и переменными окружения.
Вместе с FreeBSD поставляется несколько командных интерпретаторов, в том числе `sh`, или Bourne Shell, и `tcsh`, улучшенный вариант C-shell.
Другие командные процессоры, такие как `zsh` и `bash`, доступны в Коллекции портов FreeBSD.

Выбор используемого интерпретатора командной строки на самом деле является делом вкуса.
Программист на языке C может чувствовать себя более комфортно с C-подобной оболочкой типа `tcsh`.
Пользователь Linux может предпочесть `bash`.
Каждый командный процессор имеет свои уникальные особенности, которые могут работать, а могут и не работать в рабочем окружении, которое предпочитает пользователь, и именно поэтому имеются варианты выбора используемой оболочки.

Одной из распространённых функций командного интерпретатора является дополнение частичного имени файла до полного.
После того, как пользователь набирает несколько первых символов команды или имени файла и нажимает клавишу kbd:[Tab], командный интерпретатор автоматически дополнит имя команды или файла до полного наименования.
Рассмотрим случай с двумя файлами, которые называются [.filename]#foobar# и [.filename]#foo.bar#.
Для удаления [.filename]#foo.bar# наберите `rm fokbd:[Tab].kbd:[Tab]`.

Командный процессор должен выдать следующее: `rm foo[BEEP].bar`.

[BEEP] обозначает консольный зуммер, который используется оболочкой для оповещения о том, что сформировать полное имя файла не удалось, так как имеется более одного совпадения.
Как [.filename]#foobar#, так и [.filename]#foo.bar# начинаются с `fo`.
После набора `.` и последующего нажатия kbd:[Tab] командный процессор сможет сформировать остаток имя файла.

Дополнительные возможности при работе с интерпретатором дает использование переменных окружения.
Переменные окружения представляют собой пары переменная/значение, сохраняемые в рабочем окружении интерпретатора.
Это рабочее окружение может быть прочитано любой программой, запущенной из командного интерпретатора, и, таким образом, содержит много информации для настройки приложения.
Вот список наиболее часто встречающихся переменных окружения и их значения:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Переменная
| Описание

|`USER`
|Имя текущего пользователя.

|`PATH`
|Каталоги, разделенные двоеточием, для поиска исполняемых файлов.

|`DISPLAY`
|Сетевое имя дисплея Xorg для подключения при его доступности.

|`SHELL`
|Текущий командный интерпретатор.

|`TERM`
|Тип терминала пользователя. Используется, чтобы узнать возможности терминала.

|`TERMCAP`
|Список escape-последовательностей для управления различными функциями терминала.

|`OSTYPE`
|Вид операционной системы.

|`MACHTYPE`
|Процессорная архитектура системы.

|`EDITOR`
|Выбранный пользователем текстовый редактор.

|`PAGER`
|Выбранная пользователем утилита просмотра файлов.

|`MANPATH`
|Каталоги, разделенные двоеточием, для поиска файлов системного справочника.
|===

Порядок установки значения переменной окружения различна для разных оболочек.
В командных процессорах `tcsh` и `csh` для задания переменных окружения используется `setenv`.
В интерпретаторах `sh` и `bash` для задания актуального значения переменных окружения используется `export`.
В этом примере для `tcsh` значение по умолчанию для переменной `EDITOR` устанавливается равным [.filename]#/usr/local/bin/emacs#:

[source,shell]
....
% setenv EDITOR /usr/local/bin/emacs
....

Аналогичная команда для `bash` была бы следующей:

[source,shell]
....
% export EDITOR="/usr/local/bin/emacs"
....

Чтобы раскрыть значение переменной окружения для того, чтобы посмотреть её текущее значение, в командной строке наберите символ `$` перед именем переменной.
Например, `echo $TERM` выведет актуальное значение для `$TERM`.

Командные процессоры обрабатывают специальные символы, называемые метасимволами, как особое обозначение данных.
Самым общеупотребительным метасимволом является `\*`, который обозначает любое количество символов в имени файла.
Метасимволы могут использоваться для выполнения массовых операций с именами файлов.
Например, `echo *` равнозначна `ls`, поскольку оболочка выбирает все файлы, соответствующие `*`, а `echo` выдаёт их список в командной строке.

Чтобы предотвратить обработку специального символа командным процессором, экранируйте его, предварив наклонной чертой влево `\` (обратным слэшем).
Например, `echo $TERM` выведет значение настройки терминала, тогда как `echo \$TERM` выведет в буквальном смысле строку `$TERM`.

[[changing-shells]]
=== Как изменить командный интерпретатор по умолчанию

Самым простым способом замены командного процессора, используемого по умолчанию, на постоянной основе является использование команды `chsh`.
При запуске этой команды открывается редактор, настроенный в переменной окружения `EDITOR`, значение которой по умолчанию равно `vi`.
Измените строку "Shell:", указав полный путь для нового командного процессора.

Альтернативным способом является использование команды `chsh -s`, которая настроит указанную оболочку без открытия редактора.
Например, для замены командного процессора на `bash`:

[source,shell]
....
% chsh -s /usr/local/bin/bash
....

[NOTE]
====
Новая оболочка _обязательно_ должна присутствовать в файле [.filename]#/etc/shells#.
Если командный процессор был установлен из crossref:ports[ports,Коллекции Портов] FreeBSD, он должен быть добавлен в этот файл автоматически.
Если его там нет, добавьте его при помощи следующей команды, заменив путь на маршрут соответствующей оболочки:

[source,shell]
....
# echo _/usr/local/bin/bash_ >> /etc/shells
....

После этого запустите `chsh` повторно.
====

[[editors]]
== Текстовые редакторы

Большинство настроек FreeBSD осуществляется редактированием текстовых файлов.
В силу этого обстоятельства хорошей идеей является освоение текстового редактора.
Несколько редакторов поставляются с FreeBSD в составе базового комплекта системы, и гораздо больше доступно в Коллекции портов.

Простым в изучении редактором является ee, что означает "easy editor" ("лёгкий редактор").
Чтобы запустить его, наберите `ee _filename_`, где _filename_ является именем редактируемого файла.
Внутри редактора все команды для управления его функциями перечислены вверху экрана.
Символ вставки `^` обозначает клавишу kbd:[Ctrl], таким образом, `^e` означает комбинацию клавиш kbd:[Ctrl+e].
Чтобы выйти из ee, нажмите клавишу kbd:[Esc], затем выберите пункт "leave editor" в главном меню.
Редактор запросит у вас сохранение изменений, если файл был изменён.

Во FreeBSD также имеются более мощные текстовые редакторы типа vi, поставляемого как часть базового системного комплекта.
Другие редакторы, типа [.filename]#editors/emacs# и [.filename]#editors/vim#, являются частью Коллекции портов FreeBSD.
Эти редакторы обладают большей функциональностью, но также они более сложны в изучении.
Изучение более мощных редакторов типа vim или Emacs может сэкономить вам больше времени в долгосрочной перспективе.

Многие приложения, модифицирующие файлы или требующие текстового ввода, автоматически открывают текстовый редактор.
Чтобы сменить используемый по умолчанию редактор, задайте значение переменной окружения `EDITOR`, как это описано в разделе об <<shells,оболочках>>.

[[basics-devices]]
== Устройства и файлы устройств

Термин "устройство" используется в основном по отношению к аппаратному обеспечению системы, такому как диски, принтеры, графические адаптеры и клавиатуры.
При загрузке FreeBSD основной объём выдаваемых сообщений относится к обнаруживаемым устройствам.
Копии сообщений, выдаваемых при загрузке, сохраняются в [.filename]#/var/run/dmesg.boot#.

Каждое устройство имеет имя и номер.
Например, `acd0` соответствует первому устройству IDE CD-ROM, а `kbd0` представляет собой клавиатуру.

Во FreeBSD доступ к большинству устройств должен осуществляться через специальные файлы, называемые узлами устройств, которые размещаются в [.filename]#/dev#.

=== Создание файлов устройств

При добавлении в систему нового устройства, или добавлении поддержки дополнительных устройств, потребуется создать один или несколько файлов устройств для нового оборудования.

==== `DEVFS` (DEVice File System)

Файловая система устройств, или `DEVFS`, предоставляет доступ к пространству имён устройств ядра в общем пространстве имён файловой системы.
Снимая необходимость создавать и модифицировать узлы устройств в ручном режиме, `DEVFS` поддерживает эту специальную файловую систему в автоматическом режиме.
Дополнительную информацию можно получить в man:devfs[5].

[[binary-formats]]
== Бинарные форматы

Для того, чтобы разобраться, почему FreeBSD использует формат man:elf[5], необходимо описать три "доминирующих" в настоящее время формата исполняемых файлов для UNIX(R):

* man:a.out[5]
+
Старейший и "классический" объектный формат UNIX(R). Он использует короткий и компактный заголовок с man:magic[5]-числом в начале, которое часто используется для описания формата. Он содержит три загружаемых сегмента: .text, .data и .bss, а также таблицу символов и таблицу строк.
* COFF
+
Объектный формат SVR3. В заголовке имеется таблица, которая может содержать большее количество разделов, чем только .text, .data и .bss.
* man:elf[5]
+
Наследник формата COFF, поддерживающий множественные сегменты и 32-битные или 64-битные значения. Одним существенным недостатком является то, что ELF был разработан в предположении, что для каждой системной архитектуры имеется только один ABI. Это предположение на самом деле неверно, и не соблюдается даже в коммерческом мире SYSV (в котором есть как минимум три ABI: SVR4, Solaris, SCO).
+
FreeBSD пытается обойти эту проблему, предоставляя утилиту для _оглавления_ известного исполняемого файла ELF информацией об ABI, которому он соответствует. Обратитесь к странице справочника man:brandelf[1] за более подробной информацией.

FreeBSD произошла из "классического" лагеря и использовала формат man:a.out[5], технологию опробованную и проверенную на многих поколениях релизов BSD, до начала ветки 3.X.
Хотя собирать и запускать родные бинарные файлы ELF (и ядро) в системе FreeBSD можно было несколько раньше, FreeBSD вначале сопротивлялась "проталкиванию" ELF как формата по умолчанию.
Почему?
Когда Linux проводил болезненный переход к ELF, это происходило из-за негибкого, основанного на таблице переходов механизма совместно используемых библиотек, что делало создание таких библиотек трудным для поставщиков и разработчиков.
Так как инструменты ELF предоставляли решение проблемы совместно используемых библиотек и в целом виделись как "путь вперёд", цена перехода была признана допустимой, и такой переход был сделан.
Механизм совместно используемых библиотек FreeBSD в основе своей близок к механизму разделяемых библиотек SunOS(TM) и прост в использовании.

Итак, почему так много разных форматов?
Если вернуться во времена PDP-11, когда простое оборудование поддерживало простую и маленькую систему, [.filename]#a.out# соответствовал задаче по представлению бинарных файлов.
После того, как UNIX(R) был портирован, формат [.filename]#a.out# остался, так как он был достаточен для работы ранних портов UNIX(R) на архитектурах, подобных Motorola 68k или VAX.

Затем какой-то проектировщик оборудования решил, что если он сможет заставить программы исполнять кое-какие грубые трюки, то можно будет слегка упростить архитектуру и заставить ядро ЦПУ работать быстрее.
[.filename]#a.out# был слабо приспособлен для подобного нового типа оборудования, известного как RISC.
Было разработано множество форматов для того, чтобы получить производительность, превосходящую ту, что мог предоставить простой и ограниченный формат [.filename]#a.out#.
Были придуманы форматы COFF, ECOFF и несколько других, а их ограничения были изучены перед тем, как остановиться на ELF.

Кроме того, размеры программ становились огромными, тогда как диски и физическая память оставались относительно небольшими, поэтому появилась концепция совместно используемых библиотек.
Система виртуальной памяти стала более сложной.
Хотя каждое усовершенствование было выполнено с использованием формата [.filename]#a.out#, его полезность уменьшалась с каждой новой возможностью.
Кроме того, появилась потребность в динамической загрузке во время выполнения или удалении частей кода программ после выполнения стартового кода для экономии основной памяти или пространства подкачки.
Языки усложнились, потребовался автоматический вызов кода перед функцией main().
Множество изменений было внесено в формат [.filename]#a.out#, чтобы все эти вещи стали возможными, и в целом они работали какое-то время.
Настал момент, когда [.filename]#a.out# не смог решить все эти проблемы без дополнительных затрат на кодирование и усложнение.
Хотя ELF решал многие из этих проблем, переход на этот формат с целом рабтающей системы был бы болезненным.
Так что формату ELF пришлось подождать, прежде чем не стало более болезненным оставаться с [.filename]#a.out#, чем перейти на ELF.

С течением времени инструменты разработки, лежащие в основе инструментов разработки FreeBSD, особенно ассемблер и загрузчик, развивались в рамках двух параллельных ветках.
В ветви FreeBSD были добавлены совместно используемые библиотеки и исправлены некоторые ошибки.
Участники команды GNU, изначально писавшие эти программы, переписали их и добавили упрощённую поддержку для построения кросс-компиляторов и подключения различных форматов.
Тем, кто хотел построить кросс-компиляторы для FreeBSD, не повезло, поскольку более старые исходные тексты FreeBSD для as и ld не подходили для этой задачи.
Новый набор инструментов GNU (binutils) поддерживает кросс-компиляцию, ELF, совместно используемые библиотеки и расширения C++.
Кроме того, многие поставщики решений выпускают программы в формате ELF, а FreeBSD должна уметь их запускать.

ELF более выразителен, чем [.filename]#a.out#, позволяет базовой системе быть более гибкой.
ELF лучше поддерживается и предоставляет поддержку кросс-компиляции.
ELF может быть несколько медленнее, чем [.filename]#a.out#, но измерить это может оказаться сложно.
Есть также множество деталей, отличающих эти два формата, типа карты страниц памяти и обработки кода инициализации.
В подходящее время поддержка [.filename]#a.out# будет убрана из ядра [.filename]#GENERIC# и в какой-то момент будет исключена, как только потребность в запуске старых программ [.filename]#a.out# останется в прошлом.

[[basics-more-information]]
== Дополнительная информация

[[basics-man]]
=== Системный справочник (man)

Пожалуй, самая полная документация по FreeBSD имеет форму страниц справочной системы. Практически каждое приложение или утилита имеют соответствующую страницу (часто не одну), описывающую основы работы и различные параметры.
Эти справочники можно просматривать при помощи `man`:

[source,shell]
....
% man command
....

Здесь _command_ является названием команды, которую вы хотите изучить.
Например, чтобы узнать больше о команде `ls`, наберите:

[source,shell]
....
% man ls
....

Онлайновый справочник разделён на пронумерованные разделы:

. Пользовательские команды.
. Системные вызовы и коды ошибок.
. Функции стандартных библиотек.
. Драйверы устройств.
. Форматы файлов.
. Развлечения и игры.
. Дополнительная информация.
. Команды системного администрирования.
. Для разработчиков ядра.

В некоторых случаях одна и та же тема может появиться в различных разделах справочника.
Например, существуют пользовательская команда `chmod` и системный вызов `chmod()`.
Для указания `man` искомого раздела укажите его номер:

[source,shell]
....
% man 1 chmod
....

Эта команда выведет справку об утилите `chmod`. По традиции, конкретный раздел справочника указывается в скобках после команды, например, man:chmod[1] относится к утилите `chmod`, а man:chmod[2] - к соответствующему системному вызову.

Если вы не знаете название команды, используйте `man -k` для поиска по ключевым словам, встречающимся в описаниях команд:

[source,shell]
....
% man -k _mail_
....

Эта команда выдаёт список команд, имеющих ключевое слово "mail" в своих описаниях.
Это равнозначно использованию команды man:apropos[1].

Для выяснения того, что делают команды в [.filename]#/usr/bin#, наберите:

[source,shell]
....
% cd /usr/bin
% man -f *
....

или

[source,shell]
....
% cd /usr/bin
% whatis *
....

[[basics-info]]
=== Файлы GNU Info

FreeBSD поставляется с многочисленными приложениями и утилитами от Фонда Свободного Программного Обеспечения, Free Software Foundation (FSF).
В дополнение к страницам справочника, с этими программами могут поставляться гипертекстовые документы в виде так называемых файлов `info`.
Они могут быть просмотрены с помощью команды `info` или, если установлен пакет package:editors/emacs[], в режиме info редактора emacs.

Чтобы воспользоваться командой man:info[1], наберите:

[source,shell]
....
% info
....

Вызвать на экран краткое введение можно набрав `h`.
Краткий список команд можно получить, набрав `?`.
