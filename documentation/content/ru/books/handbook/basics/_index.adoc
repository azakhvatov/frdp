//
// The FreeBSD Russian Documentation Project
//
// Original EN revision (SVN): 50188
//

---
title: Глава 4. Основы UNIX
part: Часть I. Начало работы
prev: books/handbook/bsdinstall
next: books/handbook/ports
showBookMenu: true
weight: 6
path: "/books/handbook/basics/"
---

[[basics]]
= Основы FreeBSD
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 4
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/basics/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[basics-synopsis]]
== Краткий обзор

Эта глава посвящена основным командам и функциональности операционной системы FreeBSD.
Большая часть нижеизложенного материала применима к любой UNIX(R)-подобной операционной системе.
Новые пользователи FreeBSD призываются к внимательному чтению всей главы.

Прочитав эту главу, вы узнаете:

* Как использовать и настраивать виртуальные консоли.
* Как создавать пользователей и группы пользователей во FreeBSD и управлять ими.
* Как работают права доступа на файлы в UNIX(R) и файловые флаги во FreeBSD.
* Иерархия каталогов FreeBSD.
* Организация дисков FreeBSD.
* Как монтировать и размонтировать файловые системы.
* Что такое процессы, даемоны и сигналы.
* Что такое командный процессор и как изменить используемые по умолчанию параметры рабочего окружения
* Как пользоваться стандартными текстовыми редакторами.
* Что такое устройства и файлы устройств.
* Как пользоваться справочным руководством для получения дополнительной информации.

[[consoles]]
== Виртуальные консоли и терминалы

Если только FreeBSD не была настроена на автоматический запуск графической среды при загрузке, система будет запускаться в режиме запроса ввода имени учётной записи в командной строке, как в этом примере:

[source,shell]
....
FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:
....

Первая строка содержит определённую информацию о системе.
`amd64` указывает на то, что в системе в данном примере работает 64-разрядная версия FreeBSD.
`pc3.example.org` является именем хоста, а [.filename]#ttyv0# указывает на то, что это "системная консоль".
Вторая строка является приглашением к входу в систему.

Поскольку FreeBSD является многопользовательской системой, она должна каким-то образом отличать различных пользователей.
Это достигается за счёт того, что каждый пользователь перед получением доступа к программам системы должен в эту систему войти.
Каждый пользователь имеет уникальное "имя пользователя" и персональный "пароль".

Для входа в системную консоль наберите имя пользователя, которое было настроено во время установки системы, описанной в разделе <<bsdinstall-addusers>>, и нажмите kbd:[Enter].
Затем введите пароль, соответствующий этому имени пользователя и нажмите kbd:[Enter].
Пароль _не отображается_ по соображениям безопасности.

После ввода корректного пароля будет выдано сообщение дня MOTD (Message Of The Day), за которым последует приглашение командной строки.
В зависимости от командного процессора, который был выбран при создании пользователя, таким приглашением будет символ `#`, `$` или `%`.
Это приглашение указывает на то, что теперь пользователь вошёл в системную консоль FreeBSD и может попытаться использовать имеющиеся команды.

[[consoles-virtual]]
=== Виртуальные консоли

Хотя системная консоль может использоваться для взаимодействия с системой, пользователь, работающий в режиме командной строки за клавиатурой системы FreeBSD, как правило, будет входить в систему через виртуальную консоль.
Это так, потому что по умолчанию выдача системных сообщений настроена на их отображение на системной консоли.
Эти сообщения будут выдаваться поверх команд или файлов, с коорым работает пользователь, что мешает сосредоточиться на текущей работе.

По умолчанию FreeBSD настроена так, что она предоставляет несколько виртуальных консолей для ввода команд.
Каждая виртуальная консоль обладает собственным приглашением к входу в систему и командным процессором, а переключение между виртуальными консолями выполняется легко.
В итоге это равнозначно предоставлению нескольких одновременно открытых окон в графической среде, но в режиме командной строки.

Для переключения между виртуальными консолями во FreeBSD зарезервированы комбинации клавиш от kbd:[Alt+F1] до kbd:[Alt+F8].
Используйте kbd:[Alt+F1] для переключения на системную консоль ([.filename]#ttyv0#), kbd:[Alt+F2] для доступа к первой виртуальной консоли ([.filename]#ttyv1#), kbd:[Alt+F3] для доступа ко второй виртуальной консоли ([.filename]#ttyv2#) и так далее.

При переключении от одной консоли к другой FreeBSD берёт на себя управление изображением на экране.
В результате создаётся видимость наличия множества виртуальных экранов и клавиатур, которые могут быть использованы при наборе команд для их запуска во FreeBSD.
Программы, запущенные на одной из виртуальных консолей, не прекращают своей работы, когда пользователь переключается на другую виртуальную консоль.

Обратитесь к man:kbdcontrol[1], man:vidcontrol[1], man:atkbd[4], man:syscons[4] и man:vt[4] для получения дополнительных технических описаний консоли FreeBSD и драйверов её клавиатуры.

Во FreeBSD количество доступных виртуальных консолей настраивается в следующем разделе файла [.filename]#/etc/ttys#.

[.programlisting]
....
# name	getty				type	status	comments
#
ttyv0   "/usr/libexec/getty Pc"         xterm	on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         xterm	on  secure
ttyv2   "/usr/libexec/getty Pc"         xterm	on  secure
ttyv3   "/usr/libexec/getty Pc"         xterm	on  secure
ttyv4   "/usr/libexec/getty Pc"         xterm	on  secure
ttyv5   "/usr/libexec/getty Pc"         xterm	on  secure
ttyv6   "/usr/libexec/getty Pc"         xterm	on  secure
ttyv7   "/usr/libexec/getty Pc"         xterm	on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

Для отключения какой-либо виртуальной консоли поместите символ комментария (`#`) в начале строки, соответствующей этой виртуальной консоли.
К примеру, для уменьшения количества доступных виртуальных консолей с восьми до четырёх поместите `#` в начале последних четырёх строк, представляющих виртуальные консоли с [.filename]#ttyv5# по [.filename]#ttyv8#.
_Не комментируйте_ строку системной консоли [.filename]#ttyv0#.
Заметьте, что последняя виртуальная консоль ([.filename]#ttyv8#) используется для доступа к графическому окружению, если был установлен пакет Xorg, как это описано в главе <<x11>>.

За детальным описанием каждой колонки этого файла и доступных параметров виртуальных консолей обратитесь к man:ttys[5].

[[consoles-singleuser]]
=== Однопользовательский режим

В загрузочном меню FreeBSD имеется пункт, который называется "Boot Single User".
При его выборе система загрузится в специальном режиме, который называется "однопользовательским".
Этот режим обычно используется для восстановления работоспособности системы, которая не загружается, или для сброса пароля пользователя `root`, когда он неизвестен.
В однопользовательском режиме недоступны сетевые функции и дополнительные виртуальные консоли.
При всём при этом имеется полный доступ к системе с полномочиями пользователя `root`, и по умолчанию пароль пользователя `root` не требуется.
По этим причинам для загрузки в таком режиме требуется физический доступ к клавиатуре, а решение о том, кто имеет физический доступ к клавиатуре, стоит рассматривать в контексте обеспечения безопасности системы FreeBSD.

Настройки, управляющие однопользовательским режимом, находятся в следюущем разделе файла [.filename]#/etc/ttys#:

[.programlisting]
....
# name	getty	type	status	comments
#
# Если консоль помечена как "insecure", то init будет запрашивать пароль
# пользователя root при переходе в однопользовательский режим
console	none	unknown	off	secure
....

По умолчанию столбец status установлен в значение `secure`.
Это предполагает, что физический доступ к клавиатуре либо не важен, либо контролируется политикой физической безопасности.
Если изменить этот параметр на `insecure`, то это будет означать, что само по себе окружение не является безопасным, так как любой может получить доступ к клавиатуре.
Когда в этой строке значение меняется на `insecure`, то FreeBSD будет запрашивать пароль пользователя `root` в случае, когда пользователь выберет загрузку в однопользовательском режиме.

[NOTE]
====
__Будьте осторожны при изменении этоо параметра на ``insecure``__!
Если пароль пользователя `root` забыт, то загрузка в однопользовательском режиме всё ещё будет возможна, но может быть затруднена для тех, кто незнаком с процессом загрузки FreeBSD.
====

[[consoles-vidcontrol]]
=== Изменение видеорежимов консоли

Установленный по умолчанию режим видео для консоли FreeBSD может быть изменён до значения 1024x768, 1280x1024 или любого другого, который поддерживается вашим монитором и видеокартой.
Для использования другого видеорежима загрузите модуль `VESA`:

[source,shell]
....
# kldload vesa
....

Для определения того, какие видеорежимы поддерживаются вашим оборудованием, воспользуйтесь man:vidcontrol[1].
Чтобы получить список поддерживаемых видеорежимов, выполните следующую команду:

[source,shell]
....
# vidcontrol -i mode
....

Выдача этой команды отобразит список видеорежимов, поддерживаемых оборудованием.
Для выбора нового видеорежима укажите его при помощи man:vidcontrol[1], работая как пользователь `root`.

[source,shell]
....
# vidcontrol MODE_279
....

Если новый видеорежим приемлем, то его можно определить постоянно устанавливаемым при загрузке, добавив в [.filename]#/etc/rc.conf#:

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[users-synopsis]]
== Пользователи и основы управления учётными записями

FreeBSD позволяет одновременное использование компьютера множеством пользователей.
В то время, как в одно и то же время только один пользователь может сидеть перед экраном и использовать клавиатуру, войти в систему по сети может любое количество пользователей.
Для того, чтобы использовать систему, каждый пользователь должен иметь собственную учётную запись.

В этом разделе описывается вот что:

* Различные виды пользовательских учётных записей в системе FreeBSD.
* Как добавлять, удалять и изменять учётные записи пользователей.
* Как устанавливать ограничения для управления ресурсами, к которым имеют доступ пользователи и группы пользователей.
* Как создавать группы и добавлять пользователей в качестве их членов.

[[users-introduction]]
=== Виды учётных записей

Так как все доступы к системе FreeBSD осуществляются через учётные записи, и все процессы запускаются пользователями, то управление пользователями и учётными записями является важным вопросом.

Существуют три основных вида учётных записей: системные учётные записи, пользовательские учётные записи и учётная запись суперпользователя.

[[users-system]]
==== Системные учётные записи

Системные учётные записи используются для запуска таких сервисов, как DNS, электронная почта и веб-серверы.
Причиной этого является безопасность; если бы все сервисы работали с полномочиями суперпользователя, то они могли бы действовать без ограничений.

Примерами системных учётных записей являются `daemon`, `operator`, `bind`, `news` и `www`.

`nobody` является обобщённой непривилегированной системной учётной записью.
Несмотря на это, чем больше сервисов используют `nobody`, тем больше файлов и процессов становятся связанными с этим пользователем, и, соответственно, тем болеепривилегированным становится этот пользователь.

[[users-user]]
==== Учётные записи пользователей

Учётные записи пользователей назначаются реальным людям и используются для входа в систему и её использования.
Каждый человек, имеющий доступ к системе, должен иметь уникальную пользовательскую учётную запись.
Это позволяет администратору понимать, кто и что делает, а также предотвращать затирание настроек одних пользователей другими пользователями.

Каждый пользователь может настроить свою собственную рабочую среду, приспособленную к использованию системы, при помощи выбора оболочки, используемой по умолчанию, редактора, привязок комбинаций клавиш и настроек языкового окружения.

С каждой пользовательской учётной записью в системе FreeBSD связана определенная информация:

Имя пользователя::
Имя пользователя вводится в строке приглашения `login:`.
Каждый пользователь должен иметь уникальное имя пользователя.
Существует определённый набор правил для создания допустимых имен пользователей, документированных в man:passwd[5].
Для того, чтобы поддерживать обратную совместимость с приложениями, рекомендуется использовать имена пользователей, состоящие из восьми или меньшего количества символов в нижнем регистре.

Пароль::
У каждой учётной записи имеется связанный с ней пароль.

Идентификатор пользователя (UID)::
Идентификатор пользователя (UID) является числом, используемым для однозначной идентификации этого пользователя в системе FreeBSD.
Команды, позволяющие указывать имя пользователя, сначала будут преобразовывать его в UID.
Рекомендуется использовать UID меньше 65535, так как более высокие значения могут вызвать проблемы совместимости с некоторым программным обеспечением.

Идентификатор группы (GID)::
Идентификатор группы (GID) является числом, используемым для однозначной идентификации основной группы, которой принадлежит пользователь.
Группы являются механизмом контроля доступа к ресурсам на основе GID пользователя, а не его UID.
Это может значительно уменьшить размер некоторых конфигурационных файлов, а также позволяет пользователям быть членами более чем одной группы.
Рекомендуется использовать значения GID, не превышающие 65535, так как превышение может вызвать сбои некоторого программного обеспечения.

Класс доступа (login class)::
Классы доступа являются расширением механизма групп, дающим дополнительную гибкость при адаптации системы к различным пользователям.
Классы доступа описываются в <<users-limiting>>.

Периодичность смены пароля::
По умолчанию пароли не устаревают.
Однако устаревание пароля может быть включено по отдельности у каждого пользователя, принуждая всех или некоторых пользователей менять свои пароли по истечении определённого периода времени.

Время действия учётной записи::
По умолчанию во FreeBSD время действия учётных записей не ограничено.
При создании учётных записей с ограниченным сроком действия, например, учётных записей студентов учебного заведения, укажите дату истечения действия учетной записи при помощи man:pw[8].
После наступления указанной даты учётная запись не может быть использована для входа в систему, хотя каталоги и файлы, соответствующие этой учётной записи, не исчезнут.

Полное имя пользователя::
Имя пользователя является уникальным идентификатором учётной записи для FreeBSD, однако оно не обязательно соответствует реальному имени пользователя.
Подобно комментариям, эта информация может содержать пробелы, заглавные буквы и иметь длину более 8 символов.

Домашний каталог::
Домашний каталог является полным путём к некоторому каталогу в системе.
Это начальный каталог пользователя после его входа в систему.
По общепринятому соглашению все домашние каталоги пользователей помещаются в [.filename]#__/home/username__# или [.filename]#__/usr/home/username__#.
Пользователи хранят свои личные файлы и подкаталоги в своих домашних каталогах.

Оболочка пользователя::
Оболочка обеспечивает стандартное пользовательское окружение для взаимодействия с системой.
Существует множество различных видов оболочек, и у опытных пользователей будут свои предпочтения, которые могут быть отражены в настройках их учётных записей.

[[users-superuser]]
==== Учётная запись суперпользователя

Учётная запись суперпользователя, обычно называемая `root`, используется для управления системой без ограничения полномочий.
По этой причине она не должна использоваться для таких повседневных задач, как отправка и получение почты, общий анализ системы или программирование.

В отличие от других пользовательских учётных записей, может работать без ограничений, и некорректное использование учётной записи суперпользователя может привести к грандиозным авариям.
Учётные записи пользователей не способны уничтожить систему по ошибке, поэтому рекомендуется входить в систему как пользователь, и переключаться в режим суперпользователя только в случае, когда запускаемой команде требуются дополнительные полномочия.

Всегда проверяйте и перепроверяйте любые команды, запускаемые учётной записью суперпользователя, поскольку любой дополнительный пробел или отсутствующий символ может привести к безвозвратной потере данных.

Имеется несколько способов получения полномочий суперпользователя.
Хотя можно входить как пользователь `root`, это крайне не рекомендуется.

Для того, чтобы стать суперпользователем, вместо этого используйте man:su[1].
Если при запуске этой команды указывается параметр `-`, то пользователь также получит настройки окружения учётной записи `root`.
Пользователь, запускающий эту команду, должен входить в группу `wheel`, в противном случае команда не будет выполнена.
Пользователь также должен знать пароль для учётной записи пользователя `root`.

В этом примере пользователь становится суперпользователем только для запуска команды `make install`, так как этот шаг требует полномочий суперпользователя.
После завершения работы команды пользователь набирает `exit` для того, чтобы выйтих из учётной записи суперпользователя и возвратиться к полномочиям собственной пользовательской учётной записи.

.Установка программы с полномочиями суперпользователя
[example]
====
[source,shell]
....
% configure
% make
% su -
Password:
# make install
# exit
%
....
====

Стандартный механизм man:su[1] хорошо работает для отдельных инсталляций или небольших сетей с единственным системным администратором.
Альтернативой является установка пакета или порта package:security/sudo[].
Данное программное обеспечение обеспечивает протоколирование активностей и позволяет администратору настраивать, какие команды и какими пользователями могут запускаться с полномочиями суперпользователя.

[[users-modifying]]
=== Управление учётными записями

FreeBSD предоставляет набор различных команд для управления учётными записями пользователей.
Наиболее часто используемые команды перечислены в <<users-modifying-utilities>>, затем даны некоторые примеры их использования.
Обратитесь к страницам Справочника каждой утилиты для получения дополнительной информации и примеров использования.

[[users-modifying-utilities]]
.Инструменты для управления учётными записями
[cols="25h,~"]
|===
| Команда
| Краткое описание

|man:adduser[8]
|Рекомендуемое приложение командной строки для добавления новых пользователей.

|man:rmuser[8]
|Рекомендуемое приложение командной строки для удаления пользователей.

|man:chpass[1]
|Гибкий инструмент для изменения информации в базе данных пользователей.

|man:passwd[1]
|Инструмент командной строки для изменения паролей пользователей.

|man:pw[8]
|Мощный и гибкий инструмент для изменения всех параметров пользовательских учётных записей.
|===

[[users-adduser]]
==== `adduser`

Рекомендуемой программой для добавления новых пользователей является man:adduser[8].
При добавлении нового пользователя эта программа автоматически обновляет [.filename]#/etc/passwd# и [.filename]#/etc/group#.
Она также создаёт домашний каталог для этого нового пользователя, копирует стандартные конфигурационные файлы из [.filename]#/usr/shared/skel# и опционально может отправить новому пользователю по электронной почте приветственное сообщение.
Эта утилита должна запускаться с полномочиями суперпользователя.

Утилита man:adduser[8] является интерактивной и следует шагам создания новой учётной записи пользователя.
Как показано в <<users-modifying-adduser>>, вводите запрашиваемую информацию либо нажимайте <keycap>Return</keycap> для принятия значения по умолчанию, отображаемого в квадратных скобках.
В этом примере пользователь был приглашён в группу `wheel`, позволяющей работать с полномочиями суперпользователя при помощи man:su[1].
По окончании утилита выдаст запрос на создание ещё одного пользователя или завершение работы.

[[users-modifying-adduser]]
.Добавление пользователя во FreeBSD
[example]
====
[source,shell]
....
# adduser
Username: jru
Full name: J. Random User
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: wheel
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: zsh
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): yes
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): no
Goodbye!
#
....
====

[NOTE]
====
Так как при наборе пароля он не отображается, будьте внимательны к опечаткам при его вводе при создании пользовательской учётной записи.
====

[[users-rmuser]]
==== `rmuser`

Для полного удаления пользователя из системы запустите man:rmuser[8] с полномочиями суперпользователя.
Эта команда выполняет следующие шаги:

[.procedure]
====
. Удаляет пользовательскую информацию в man:crontab[1], если она имеется.
. Удаляет все задания man:at[1], принадлежащие этому пользователю.
. Прекращает работу всех процессов, владельцем которых является данный пользователь.
. Удаляет пользователя из локального файла паролей системы.
. Опционально удаляет домашний каталог пользователя, если этот пользователь является его владельцем.
. Удаляет файлы входящей почты, принадлежащие этому пользователю, из [.filename]#/var/mail#.
. Удаляет все файлы, владельцем которых является этот пользователь, из мест размещения временных файлов, таких как [.filename]#/tmp#.
. Наконец, удаляет имя пользователя из всех групп, в которых он состоял, в [.filename]#/etc/group#. Если какая-то группа становится пустой, а её название совпадает с именем пользователя, то эта группа удаляется. Эта группа соответствует уникальной пользовательской группе, создаваемой man:adduser[8].

man:rmuser[8] не может использоваться для удаления учётной записи суперпользователя, поскольку это практически гарантированно означает массовые сбои системы.

По умолчанию используется интерактивный режим, как показано в следующем примере.

.Интерактивное удаление учётной записи с помощью `rmuser`
[example]
====
[source,shell]
....
# rmuser jru
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user's home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
#
....
====

[[users-chpass]]
==== `chpass`

Любой пользователь может воспользоваться man:chpass[1] для изменения своего используемого по умолчанию командного процессора и персональной информации, связанной с его пользовательской учётной записью.
Суперпользователь может использовать данную утилиту для изменения дополнительной информации об учётной записи любого пользователя.

При запуске без указания параметров, за исключением необязательного имени пользователя, man:chpass[1] отображает редактор, содержащий информацию пользователя.
Когда пользователь завершает работу с редактором, база данных пользователей обновляется новой информацией.

[NOTE]
====
Если утилита не запущена с полномочиями суперпользователя, то после выхода из редактора она запросит пароль пользователя.
====

В <<users-modifying-chpass-su>> суперпользователь набрал `chpass jru` и просматривал поля, которые могут быть изменены для данного пользователя.
Если вместо этого эта команда будет запущена пользователем `jru`, то будут отображены и доступны для редактирования только шесть последних полей.
Это показано в <<users-modifying-chpass-ru>>.

[[users-modifying-chpass-su]]
.Использование `chpass` с полномочиями суперпользователя
[example]
====
[source,shell]
....
#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....
====

[[users-modifying-chpass-ru]]
.Использование `chpass` с полномочиями обычного пользователя
[example]
====
[source,shell]
....
#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....
====

[NOTE]
====
Команды man:chfn[1] и man:chsh[1] являются ссылками на man:chpass[1], так же, как и man:ypchpass[1], man:ypchfn[1] и man:ypchsh[1].
Так как NIS поддерживается автоматически, указание `yp` перед командой не обязательно.
Настройка NIS рассматривается в <<network-servers>>.
====

[[users-passwd]]
==== `passwd`

Любой пользователь может легко сменить собственный пароль при помощи man:passwd[1].
Для предотвращения случайных или неавторизованных изменений перед установкой нового пароля эта команду будут запрашивать первоначальный пароль пользователя:

.Изменение собственного пароля
[example]
====
[source,shell]
....
% passwd
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done
....

====

Суперпользователь может сменить пароль любого пользователя, указав имя пользователя при запуске man:passwd[1].
В тех случаях, когда эта утилита работает с полномочиями суперпользователя, она не будет запрашивать текущий пароль пользователя.
Это позвляет менять пароль в случае, когда пользователь не может вспомнить первоначальный пароль.

.Изменение пароля другого пользователя суперпользователем
[example]
====
[source,shell]
....
# passwd jru
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done
....
====

[NOTE]
====
Как и в случае с man:chpass[1], man:yppasswd[1] является ссылкой на man:passwd[1], так что NIS работает с любой из команд.
====

[[users-pw]]
==== `pw`

Утилита man:pw[8] может создавать, удалять, изменять и отображать пользователей и группы.
Она функционирует как пользовательский интерфейс к системным файлам пользователей и групп.
man:pw[8] обладает очень мощным набором параметров командной строки, что делает её подходящей для использования в скриптах командного процессора, однако новым пользователям она может показаться более сложной, чем другие команды, представленные в этом разделе.

[[users-groups]]
=== Управление группами

Группа представляет собой список пользователей.
Группа идентифицируется по её имени и GID.
Во FreeBSD для определения того, что имеет право делать процесс, ядро использует UID процесса и список групп, которым он принадлежит.
В большинстве случаев GID пользователя или процесса соотносится с первой группой из списка.

Соответствие имени группы и GID определено в файле [.filename]#/etc/group#.
Это обычный текстовый файл с четырьмя полями, разделёнными двоеточиями.
Первое поле соответствует имени группы, второе является зашифрованным паролем, третье содержит GID, а четвёртое является списком членов группы, разделённых запятыми.
За более полным описанием синтаксиса обратитесь к man:group[5].

Суперпользователь может изменять [.filename]#/etc/group# при помощи текстового редактора.
В качестве альтернативы для добавления и редактирования групп можно использовать man:pw[8].
Например, для добавления группы с именем `teamtwo` и последующей проверки её существования:

.Добавление группы с использованием man:pw[8]
[example]
====
[source,shell]
....
# pw groupadd teamtwo
# pw groupshow teamtwo
teamtwo:*:1100:
....
====

В этом примере `1100` является GID группы `teamtwo`.
На данный момент в `teamtwo` нет участников.
Эта команда добавит `jru` в группу `teamtwo` в качестве участника.

.Добавление учётных записей пользователей в новую группу при помощи man:pw[8]
[example]
====
[source,shell]
....
# pw groupmod teamtwo -M jru
# pw groupshow teamtwo
teamtwo:*:1100:jru
....
====

Аргументом к параметру `-M` является разделённый запятыми список пользователей, которых нужно добавить в новую (пустую) группу или заменить участников существующей группы.
С точки зрения пользователя такое членство в группе отличается от (и является дополнительным к) основной группы, указанной в файле паролей.
Это значит, что пользователь не будет отображаться как участник группы при использовании параметра `groupshow` с man:pw[8], но будет отображаться при запросе информации с помощью man:id[1] или аналогичного инструмента.
При использовании man:pw[8] для добавления пользователя в группу она работает только с [.filename]#/etc/group# и не пытается считывать дополнительные сведения из [.filename]#/etc/passwd#.

.Добавление нового участника в группу с помощью man:pw[8]
[example]
====
[source,shell]
....
# pw groupmod teamtwo -m db
# pw groupshow teamtwo
teamtwo:*:1100:jru,db
....
====

В этом примере аргументом к параметру `-m` является разделённый запятыми список пользователей, которые должны быть добавлены в группу.
В отличие от предыдущего примера, эти пользователи присоединяются к группе, а не замещают существующих в группе пользователей.

.Использование man:id[1] для определения принадлежности к группе
[example]
====
[source,shell]
....
% id jru
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)
....
====

В этом примере `jru` является членом групп `jru` и `teamtwo`.

За дополнительной информацией об этой команде и о формате [.filename]#/etc/group# обратитесь к man:pw[8] и man:group[5].

[[permissions]]
== Права доступа

Во FreeBSD с каждым файлом и каталогом связан набор прав доступа, для просмотра и изменения которых доступны несколько утилит.
Понимание того, как работают эти права доступа, необходимо для обеспечения того, чтобы пользователи могли получать доступ к файлам, которые им нужны, и не могли некорректно обращаться к файлам, используемым операционной системой или владельцами которых является другие пользователи.

В этом разделе описываются традиционные права доступа UNIX(R), используемые во FreeBSD.
Для более тонкого управления доступом в файловой системе обратитесь к разделу crossref:fs-acl[fs-acl,Списки управления доступом к файловой системе].

В UNIX(R) базовые права доступа назначаются с использованием трёх типов доступа: чтение, запись и исполнение.
Эти типы доступа используются для определения доступа к файлу для владельца файла, для группы и для прочих пользователей (всех остальных).
Полномочия на чтение, запись и исполнение могут быть представлены в виде букв `r`, `w` и `x`.
Также они могут быть представлены в виде двоичных чисел, так как каждое полномочие либо включено, либо выключено (`0`).
При представлении в виде числа порядок прочтения всегда имеет вид `rwx`, где `r` имеет значение `4`, `w` имеет значение `2` и `x` равно `1`.

В Таблице 4.1 сведены возможные цифровые и символьные комбинации.
В столбце "Список файлов каталога" символ `-` используется для отражения отсутствующего права доступа.

.Права доступа UNIX(R)
[cols="1,1,1", frame="none", options="header"]
|===
| Значение
| Права доступа
| Список файлов каталога

|0
|Ничего не разрешено
|`---`

|1
|Нельзя читать и писать, разрешено исполнять
|`--x`

|2
|Нельзя читать и исполнять, разрешено писать
|`-w-`

|3
|Нельзя читать, разрешено писать и исполнять
|`-wx`

|4
|Разрешено читать, нельзя писать и исполнять
|`r--`

|5
|Разрешено читать и исполнять, нельзя писать
|`r-x`

|6
|Разрешено читать и писать, нельзя исполнять
|`rw-`

|7
|Разрешено все
|`rwx`
|===

Используйте параметр `-l` команды man:ls[1] для получения подробного списка содержимого каталога, включающего столбец с информацией о полномочиях на файл для владельца, группы и всех остальных.
Например, команда `ls -l` в произвольном каталоге может выдать следующее:

[source,shell]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
....

Первый (самый левый) символ в первом столбце указывает на то, обычный ли это файл, каталог, специальное символьное устройство, сокет или какое-то другое псевдофайловое устройство.
В данном примере `-` указывает на то, что это обычный файл.
Следующие три символа (в данном примере это `rw-`) определяют полномочия владельца файла.
Последующие три символа, `r--`, определяют полномочия группы, которой принадлежит файл.
Последние три символа, `r--`, определяют полномочия для всего остального мира.
Дефис означает, что полномочия отсутствуют.
В этом примере полномочия установлены таким образом, что владелец может выполнять операции чтения и записи в файл, группа может читать файл, а весь остальной мир может только читать файл.
В соответствии с таблицей выше, полномочия для этого файлы могли бы быть представлены как `644`, где каждая цифра представляет три части полномочий на файл.

Как система управляет полномочиями на устройства?
Во FreeBSD большинство устройств представлено в виде файлов, которые программы могут открывать, читать и записывать в них данные.
Эти специальные файлы устройств находятся в каталоге [.filename]#/dev#.

Каталоги обрабатываются так же, как и файлы.
У них также имеются полномочия на чтение, запись и выполнение.
Бит исполнимости для каталога имеет несколько другой, отличающийся от файлов, смысл.
Когда каталог помечен как исполняемый, это означает, что в него можно перейти с помощью команды man:cd[1].
Это также означает, что можно получить доступ к файлам в данном каталоге с учётом полномочий, установленных для этих файлов.

Для того, чтобы получить список файлов в каталоге, на него должны быть установлены полномочия на чтение.
Для того, чтобы удалить из каталога какой-либо файл, имя которого известно, необходимо иметь полномочия на запись _и_ исполнение каталога, содержащего соответствующий файл.

Существуют и другие права доступа, но они как правило используются в особых случаях, например, setuid-бит на выполняемые файлы и sticky-бит на каталоги.
За дополнительной информацией о файловых полномочиях и о том, как их устанавливать, обратитесь к man:chmod[1].

=== Символическое обозначение полномочий

Символическое обозначение полномочий использует буквы вместо восьмеричных значений для назначения прав на файлы или каталоги.
Символическое обозначение использует формат (кто) (действие) (полномочия), при этом доступны следующие значения:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Опция
| Буква
| Значение

|(кто)
|u
|Пользователь (User)

|(кто)
|g
|Группа (Group)

|(кто)
|o
|Другие (Other)

|(кто)
|a
|Все (All, "world")

|(действие)
|+
|Добавление прав

|(действие)
|-
|Удаление прав

|(действие)
|=
|Явная установка прав

|(права)
|r
|Чтение (Read)

|(права)
|w
|Запись (Write)

|(права)
|x
|Выполнение (Execute)

|(права)
|t
|Sticky бит

|(права)
|s
|SUID или SGID
|===

Эти значения используются с командой man:chmod[1], но с буквами вместо цифр.
Например, следующая команда блокирует доступ сторонних пользователей к _FILE_:

[source,shell]
....
% chmod go= FILE
....

Для изменения более чем одного набора прав можно применить список значений, разделённых запятыми.
Например, следующая команда удаляет права группы и "всех остальных" на запись в _FILE_ и добавляет права на выполнение любым пользователям:

[source,shell]
....
% chmod go-w,a+x __FILE__
....

=== Флаги файлов в FreeBSD

Кроме прав доступа к файлам, FreeBSD поддерживает использование "файловых флагов".
Эти флаги привносят дополнительный уровень защиты и контроля над файлами, но не каталогами.
При помощи этих флагов даже пользователь `root` может быть ограничен в удалении или изменении файлов.

Файловые флаги изменяются при помощи man:chflags[1].
К примеру, для установки системного флага неудаляемости на файл [.filename]#file1#, выполните следующую команду:

[source,shell]
....
# chflags sunlink file1
....

Чтобы отключить системный флаг неудаляемости, укажите "no" перед `sunlink`:

[source,shell]
....
# chflags nosunlink file1
....

Чтобы просмотреть флаги какого-либо файла, используйте команду man:ls[1] с параметрами `-lo`:

[source,shell]
....
# ls -lo file1
....

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

Некоторые файловые флаги могут быть установлены или сняты только пользователем `root`.
В остальных случаях флаги файла может устанавливать его владелец.
Обратитесь к man:chflags[1] и man:chflags[2] для получения дополнительной информации.

=== Права доступа `setuid`, `setgid` и `sticky`

В дополнение к рассмотренным выше правам доступа и флагам файлов необходимо также упомянуть еще три бита прав доступа, о которых должны знать все системные администраторы. Это такие биты, как `setuid`, `setgid` и `sticky`.

Эти биты играют важную роль в определённых моментах работы UNIX(R), так как они предоставляют функциональность, расширяющую права обычного пользователя.
Чтобы понять, как они работают, необходимо отметить различия между реальным идентификатором пользователя (UID) и действующим идентификатором пользователя (effective UID, EUID).

Реальный UID - это идентификатор пользователя, запустившего процесс на выполнение. Действующий UID (EUID) - это идентификатор пользователя, с которым на самом деле выполняется процесс.
Например, утилита man:passwd[1] во время смены пароля пользователем запускается с реальным ID пользователя.
Однако для того, чтобы актуализировать базу данных паролей, команда работает с действующим ID пользователя `root`.
Это позволяет пользователям изменять их пароли и не наблюдать ошибку `Permission Denied`.

Полномочие setuid устанавливается добавлением цифры четыре (4) перед численным представлением прав доступа, например:

[source,shell]
....
# chmod 4755 suidexample.sh
....

Теперь права доступа на файл [.filename]#__suidexample.sh__# выглядят подобно следующему:

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

Заметьте, что `s` теперь является частью набора полномочий, относящихся к владельцу файла, и заменяет бит выполнимости.
Это позволяет работать утилитам, которым требуется повышенный уровень полномочий, таким как man.passwd[1].

[NOTE]
====
Указание параметра `nosuid` при запуске команды man:mount[8] приводит к тому, что такие программы перестают работать без выдачи предупреждений пользователям.
Указанная возможность не является абсолютно надёжно работающей, так как обработчик `nosuid` может её обойти.
====

Чтобы увидеть, как это работает, откройте два терминала.
В одном из них наберите `passwd`, работая как обычный пользователь.
Пока утилита ждёт ввода нового пароля, просмотрите таблицу процессов и обратите внимание на информацию о пользователе процесса man.passwd[1].

В терминале А:

[source,shell]
....
Changing local password for trhodes
Old Password:
....

В терминале Б:

[source,shell]
....
# ps aux | grep passwd
....

[source,shell]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

Хотя man.passwd[1] запущена от обычного пользователя, она использует действующий UID пользователя `root`.

Полномочие `setgid` выполняет ту же функцию, что и `setuid`; отличие заключается в том, что изменяются настройки прав для группы.
Когда выполняются приложение или утилита с этой настройкой, то им назначаются полномочия на основании группы, владеющей файлом, а не пользователя, запустившего процесс.

Чтобы установить на какой-либо файл полномочие `setgid`, выполните команду man.chmod[1], добавив в начало цифру два (2):

[source,shell]
....
# chmod 2755 sgidexample.sh
....

В следующей выдаче обратите внимание на наличие `s` в перечне прав доступа для группы:

[source,shell]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
В этих примерах, несмотря на то, что сценарий оболочки является исполняемым файлом, он не будет выполняться с другим действующим идентификатором пользователя (EUID). Так происходит потому, что сценариям командного интерпретатора недоступен системный вызов man:setuid[2].
====

Позволяя повышать права доступа, биты полномочий `setuid` и `setgid` могут снижать безопасность системы.
Третье специальное полномочие, `sticky bit`, может усиливать безопасность системы.

`Sticky bit`, будучи установленным на каталог, позволяет производить удаление файла только его владельцем.
Это полезно для предотвращения удаления файлов в общедоступных каталогах, таких как [.filename]#/tmp#, пользователями, которые не являются их владельцами.
Чтобы использовать это полномочие, добавьте единицу (1) перед набором прав доступа:

[source,shell]
....
# chmod 1777 /tmp
....

Полномочие `sticky bit` будет отображаться как `t` в самом конце набора прав доступа:

[source,shell]
....
# ls -al / | grep tmp
....

[source,shell]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

[[dirstructure]]
== Структура каталогов

Структура каталогов FreeBSD является фундаментальным вопросом в достижении общего понимания устройства всей системы.
Самым важным понятием является, несомненно, корневой каталог, или "/".
Этот каталог является самым первым, монтируемым на этапе загрузки и содержащим базовую систему, необходимую для подготовки операционной системы к работе в многопользовательском режиме.
Корневой каталог также содержит точки монтирования для других файловых систем, которые монтируются во время перехода к функционированию в многопользовательском режиме.

Точкой монтирования называется каталог, находящийся в родительской (обычно - корневой) файловой системе, к которому может быть подсоединена другая файловая система.
Более глубоко это описывается в <<disk-organization>>.
К стандартным точкам монтирования относятся [.filename]#/usr/#, [.filename]#/var/#, [.filename]#/tmp/#, [.filename]#/mnt/# и [.filename]#/cdrom/#.
Эти каталоги обычно перечислены как отдельные записи в файле [.filename]#/etc/fstab#.
Этот файл является таблицей с различными файловыми системами и точками монтирования, которая считывается системой.
Большинство файловых систем в [.filename]#/etc/fstab# монтируются во время загрузки автоматически из скрипта man:rc[8], если только в соответствующей записи для них не указано `noauto`.
Более подробную информацию можно найти в <<disks-fstab>>.

Полное описание иерархии файловой системы есть в man:hier[7].
Таблица ниже содержит краткое описание наиболее часто упоминаемых каталогов.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Каталог
| Описание

|[.filename]#/#
|Корневой каталог файловой системы.

|[.filename]#/bin/#
|Основные утилиты, необходимые для работы как в однопользовательском, так и в многопользовательском режимах.

|[.filename]#/boot/#
|Программы и конфигурационные файлы, необходимые для нормальной загрузки операционной системы.

|[.filename]#/boot/defaults/#
|Конфигурационные файлы, используемые в процессе загрузки операционной системы, со стандарными настройками. Обратитесь к man:loader.conf[5] для получения более подробной информации.

|[.filename]#/dev/#
|Файлы устройств. Обратитесь к man:intro[4] для получения более подробной информации.

|[.filename]#/etc/#
|Основные конфигурационные файлы системы и скрипты.

|[.filename]#/etc/defaults/#
|Конфигурационные файлы системы со стандартными настройками. Обратитесь к man:rc[8] для получения более подробной информации.

|[.filename]#/etc/mail/#
|Конфигурационные файлы для систем обработки почты (например, man:sendmail[8]).

|[.filename]#/etc/namedb/#
|Конфигурационные файлы man:named[8].

|[.filename]#/etc/periodic/#
|Файлы сценариев, выполняемые ежедневно, еженедельно и ежемесячно при помощи man:cron[8]. Обратитесь к man:periodic[8] для получения более подробной информации.

|[.filename]#/etc/ppp/#
|Конфигурационные файлы man:ppp[8].

|[.filename]#/mnt/#
|Пустой каталог, часто используемый системными администраторами как временная точка монтирования.

|[.filename]#/proc/#
|Файловая система процессов. Обратитесь к man:procfs[5] и man:mount_procfs[8] для получения более подробной информации.

|[.filename]#/rescue/#
|Статически скомпилированные программы для восстановления после сбоев, как описано в man:rescue[8].

|[.filename]#/root/#
|Домашний каталог пользователя `root`.

|[.filename]#/sbin/#
|Системные утилиты и утилиты администрирования, необходимые для работы как в однопользовательском, так и в многопользовательском режимах.

|[.filename]#/tmp/#
|Временные файлы, которые обычно _не_ сохраняются при перезагрузке системы. Размещаемая в оперативной памяти файловая система часто монтируется в [.filename]#/tmp#. Это может быть автоматизировано с помощью переменных, относящихся к tmpmfs, в man:rc.conf[5] или с помощью записи в [.filename]#/etc/fstab#; обратитесь к man:mdmfs[8] для получения более подробной информации.

|[.filename]#/usr/#
|Большинство пользовательских утилит и приложений.

|[.filename]#/usr/bin/#
|Пользовательские утилиты и приложения общего назначения.

|[.filename]#/usr/include/#
|Стандартные заголовочные файлы для языка C.

|[.filename]#/usr/lib/#
|Файлы стандартных библиотек.

|[.filename]#/usr/libdata/#
|Файлы данных для различных утилит.

|[.filename]#/usr/libexec/#
|Системные даемоны и системные утилиты, вызываемые другими программами.

|[.filename]#/usr/local/#
|Локальные исполнимые файлы и библиотеки. Также используется в качестве стандартного целевого каталога в рамках механизма портов. Внутри [.filename]#/usr/local# иерархия каталогов должна следовать man:hier[7] для [.filename]#/usr#. Исключение составляют каталог [.filename]#man#, который расположен непосредственно в [.filename]#/usr/local#, а не в [.filename]#/usr/local/share#, и документация портов, которая располагается в [.filename]#share/doc/__port__#.

|[.filename]#/usr/obj/#
|Архитектурно-зависимые файлы и каталоги, образующиеся в процессе сборки системы из исходных текстов в [.filename]#/usr/src#.

|[.filename]#/usr/ports/#
|Коллекция портов FreeBSD (опционально).

|[.filename]#/usr/sbin/#
|Системные даемоны и системные утилиты, запускаемые пользователями.

|[.filename]#/usr/shared/#
|Архитектурно-независимые файлы.

|[.filename]#/usr/src/#
|Исходные тексты BSD и/или программ.

|[.filename]#/var/#
|Файлы журналов общего назначения, временные, перемещаемые файлы и файлы очередей. Файловая система в памяти иногда монтируется в [.filename]#/var#. Это может быть автоматизировано с помощью переменных, относящихся к varmfs, в man:rc.conf[5] или с помощью записи в [.filename]#/etc/fstab#; обратитесь к man:mdmfs[8] для получения подробной информации.

|[.filename]#/var/log/#
|Различные файлы системных журналов.

|[.filename]#/var/mail/#
|Почтовые ящики пользователей.

|[.filename]#/var/spool/#
|Файлы очередей печати, почты, и пр.

|[.filename]#/var/tmp/#
|Временные файлы, которые обычно сохраняются после перезагрузки системы, если только [.filename]#/var# не является файловой системой, размещаемой в оперативной памяти.

|[.filename]#/var/yp/#
|Карты NIS.
|===

[[disk-organization]]
== Организация дисков

Наименьшей единицей, которую FreeBSD использует для поиска файлов, является имя файла.
Имена файлов чувствительны к регистру, поэтому [.filename]#readme.txt# и [.filename]#README.TXT# - два разных файла.
FreeBSD не использует расширение файла для определения того, является ли файл программой, документом или какой-то иной формой данных.

Файлы хранятся в каталогах.
Каталоги могут не содержать файлов, либо могут содержать многие сотни файлов.
Каталог также может содержать другие каталоги, что позволяет иметь иерархию вложенных друг в друга каталогов для организации данных.

Обращение к файлам и каталогам осуществляется указанием имени файла или каталога, дополняемого прямым слэшем `/`, за которым при необходимости могут следовать имена других каталогов.
К примеру, если каталог [.filename]#foo# содержит каталог [.filename]#bar#, который содержит файл [.filename]#readme.txt#, то полным именем, или _путём_ файла является [.filename]#foo/bar/readme.txt#.
Заметьте, что это отличается от Windows(R), в которой для отделения имён файлов и каталогов используется `\`.
FreeBSD не использует символьных или каких-либо других именований устройств в пути.
К примеру, набирать [.filename]#c:\foo\bar\readme.txt# во FreeBSD не имеет смысла.

Каталоги и файлы хранятся в файловой системе.
Каждая файловая система на самом верхнем уровне содержит ровно один каталог, называемый _корневым каталогом_ этой файловой системы.
Этот корневой каталог может содержать другие каталоги.
Одна из файловых систем назначается _корневой файловой системой_, или `/`.
Любая другая файловая система _монтируется_ в корневой файловой системе.
Вне зависимости от того, сколько дисков присутствует в системе FreeBSD, каждый каталог выглядит как часть одного диска.

Рассмотрим три файловых системы, называющиеся `A`, `B`, и `C`.
Каждая файловая система имеет один корневой каталог, в котором содержатся два других каталоги с именами `A1`, `A2` (и, соответственно, `B1`, `B2` и `C1`, `C2`).

Назовём `A` корневой файловой системой.
Если для просмотра содержимого этого каталога использовать команду man:ls[1], то она покажет два подкаталога, `A1` и `A2`.
Дерево каталогов выглядит вот так:

image::example-dir1.png[]

Файловая система должна быть смонтирована в каталог другой файловой системы.
При монтировании файловой системы `B` в каталог `A1`, корневой каталог `B` заменяет `A1`, а каталоги в `B` отображаются в соответствии с этим:

image::example-dir2.png[]

При необходимости к любым файлам, находящимся в каталогах `B1` или `B2`, можно обратиться по маршруту [.filename]#/A1/B1# или [.filename]#/A1/B2#.
Все файлы, находившиеся в [.filename]#/A1#, временно скрыты.
Они появятся снова, если `B` будет _размонтирована_ с `A`.

Если `B` была смонтирована в `A2`, диаграмма будет выглядеть так:

image::example-dir3.png[]

а пути будут [.filename]#/A2/B1# и [.filename]#/A2/B2#, соответственно.

Файловые системы могут быть смонтированы одна на другую. Продолжая предыдущий пример, файловая система `C` может быть смонтирована на каталог `B1` файловой системы `B` в таком порядке:

image::example-dir4.png[]

Или `C` может быть смонтирована прямо на файловую систему `A`, на каталог `A1`:

image::example-dir5.png[]

Вполне возможно иметь одну большую корневую файловую систему и не иметь потребности в создании других.
У такого подхода есть несколько недостатков и одно преимущество.

.Преимущества нескольких файловых систем
* Различные файловые системы могут иметь различные _параметры монтирования_. Например, корневая файловая система может быть смонтирована в режиме доступности только для чтения, что делает невозможным случайное удаление или редактирование какого-то критически важного файла. Отделение файловых систем, доступных пользователям для записи, таких как [.filename]#/home#, от других файловых систем позволяет монтировать их с параметром _nosuid_. Этот параметр отменяет действие битов _suid_/ _guid_ на исполняемых файлах в этой файловой системе, что потенциально повышает безопасность.
* FreeBSD автоматически оптимизирует расположение файлов на файловой системе в зависимости от того, как файловая система используется. Файловая система, содержащая множество мелких часто записываемых файлов, будет иметь оптимизацию, отличную от таковой для файловой системы, содержащей несколько больших файлов. На одной большой файловой системе эта оптимизация не работает.
* Файловые системы FreeBSD устойчивы к отключению электропитания. Тем не менее, потеря питания в критический момент все же может повредить структуру файловой системы. Разделение данных на несколько файловых систем повышает шансы, что система все-таки будет работать и делает более легким восстановление с резервной копии.

.Преимущество одной файловой системы
* Размер файловых систем фиксирован. Если вы создаете файловую систему при установке FreeBSD и задаете определенный размер, позднее вы можете обнаружить что нужен раздел большего размера. Это не так легко сделать без резервного копирования, создания файловых систем нового размера и последующего восстановления сохраненных данных.
+
[IMPORTANT]
====
Во FreeBSD имеется команда man:growfs[8], которая позволяет увеличивать размер файловой системы на лету, устраняя это ограничение.
====

Файловые системы содержатся в разделах. Этот термин не имеет того же смысла, что и при более раннем его использовании в этой главе, из-за наследия UNIX(R) в FreeBSD. Каждый раздел обозначается буквой от `a` до `h`. Каждый раздел может содержать только одну файловую систему, это значит что файловая система может быть описана ее точкой монтирования в файловой иерархии, или буквой раздела, в котором она содержится.

FreeBSD также использует дисковое пространство для _раздела подкачки_, обеспечивающего работу _виртуальной памяти_. Это позволяет вашему компьютеру работать так, как если бы у него было больше памяти, чем есть на самом деле. Когда у FreeBSD кончается память, она перемещает часть данных, не используемых в данный момент, в раздел подкачки и возвращает их обратно (перемещая в подкачку что-то другое), когда они нужны.

По некоторым разделам есть определенные соглашения.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Раздел
| Соглашение

|`a`
|Как правило, содержит корневую файловую систему.

|`b`
|Как правило, содержит пространство подкачки.

|`c`
|В обычном случае имеет такой же размер, что и окружающий слайс. Это позволяет утилитам, которым нужно обрабатывать весь слайс, таким, как сканер плохих блоков, использовать раздел `c`. В обычном случае создавать файловую систему в этом разделе не требуется.

|`d`
|Раздел `d` создавался для специальных целей, хотя сейчас они не актуальны и `d` может быть задействован как обычный раздел.
|===

Во FreeBSD диски разбиваются на слайсы, в Windows(R) называемые разделами, и нумеруются от 1 до 4.
Эти слайсы, в свою очередь, разбиваются на разделы, содержащие файловые системы, и обозначаются буквами.

Номера слайсов следуют за именем устройства, предваряемые строчной `s`, начиная с 1.
Так "da0__s1__" это первый слайс первого SCSI устройства.
На диске может быть только четыре физических слайса, но внутри физических слайсов подходящего типа могут существовать логические слайсы.
Эти дополнительные слайсы нумеруются начиная с 5, так что "ada0__s5__" это первый дополнительный слайс на первом диске SATA.
Эти устройства используются файловыми системами, занимающими весь слайс.

Слайсы, "эксклюзивно выделенные (dangerously dedicated)" физические устройства и другие устройства содержат _разделы_, представляемые буквами от `a` до `h`.
Соответствующая буква добавляется к имени устройства, и, таким образом, "da0__a__" является разделом `a` на первом устройстве `da`, являющемся "эксклюзивно выделенным".
"ada1s3__e__" является пятым разделом третьего слайса второго диска SATA.

Наконец, каждый диск идентифицирован. Имя диска начинается с кода, обозначающего тип диска, затем идет номер диска. В отличие от слайсов, нумерация дисков начинается с 0.
Часто встречающиеся коды перечислены в разделе <<disks-naming>>.

Для ссылки на раздел указывайте имя диска, `s`, номер слайса, а затем букву раздела.
Примеры показаны в <<basics-disk-slice-part>>.

<<basics-concept-disk-model>> показывает концептуальную модель рабиения диска.

Для установки FreeBSD настройте дисковые слайсы, создайте разделы внутри слайса, который будет использован для FreeBSD, создайте файловую систему (или пространство подкачки) в каждом разделе и решите, куда будет смонтирована каждая из файловых систем.

[[disks-naming]]
.Имена дисковых устройств
[cols="1,1", frame="none", options="header"]
|===
| Тип дискового устройства
| Имя дискового устройства

|Приводы жёстких дисков SATA и IDE
|`ada` или `ad`

|Приводы жёстких дисков SCSI и устройства хранения USB
|`da`

|Приводы CD-ROM с интерфейсом SATA и IDE
|`cd` или `acd`

|Приводы CD-ROM с интерфейсом SCSI
|`cd`

|Приводы гибких дисков
|`fd`

|Различные нестандартные приводы CD-ROM
|`mcd` для устройств Mitsumi CD-ROM и `scd` для устройств Sony CD-ROM

|Ленточные накопители с интерфейсом SCSI
|`sa`

|Ленточные накопители с интерфейсом IDE
|`ast`

|Устройства хранения RAID
|Например, `aacd` для Adaptec AdvancedRAID, `mlxd` и `mlyd` для Mylex, `amrd` для AMI MegaRAID, `idad` для Compaq Smart RAID и `twed` для 3ware RAID.
|===

[[basics-disk-slice-part]]
.Примеры именований диска, слайса и раздела
[example]
====
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Имя
| Значение

|`ada0s1a`
|Первый раздел (`a`) на первом слайсе (`s1`) первого диска SATA (`ada0`).

|`da1s2e`
|Пятый раздел (`e`) на втором слайсе (`s2`) второго SCSI диска (`da1`).
|===
====

[[basics-concept-disk-model]]
.Концептуальная модель диска
[example]
====
Эта диаграмма изображает первый подключенный к системе диск SATA с точки зрения FreeBSD.
Предположим, что объём диска составляет 250 ГБ, и он содержит слайс размером 80 ГБ и слайс размером 170 ГБ (разделы MS-DOS(R)).
Первый слайс содержит файловую систему Windows(R) NTFS, [.filename]#C:#, а второй слайс содержит установленную FreeBSD.
В этом примере установленная FreeBSD имеет четыре раздела с данными и раздел подкачки.

Каждый из четырёх разделов содержит файловую систему.
Раздел `a` будет используется для корневой файловой системы, `d` для [.filename]#/var/#, `e` для [.filename]#/tmp/# и `f` для [.filename]#/usr/#.
Раздел, обозначенный буквой `c`, соответствует всему слайсу и поэтому не используется как обычный раздел.

image::disk-layout.png[]
====

[[mount-unmount]]
== Монтирование и размонтирование файловых систем

Файловая система лучше всего представима в виде дерева, которое, если можно так выразиться, растёт из [.filename]#/#.
Каталоги [.filename]#/dev#, [.filename]#/usr# и прочие, находящиеся в корневом каталоге, являются ветвями и, в свою очередь, могут иметь собственные ветви, такие как [.filename]#/usr/local#, и так далее.

Имеются разные основания для того, чтобы размещать некоторые из этих каталогов в отдельных файловых системах.
[.filename]#/var# содержит каталоги [.filename]#log/#, [.filename]#spool/# и разные виды временных файлов и, таким образом, может полностью заполнить свободное дисковое пространство.
Заполнение корневой файловой системы нежелательно, поэтому часто предпочитают отделить [.filename]#/var# от [.filename]#/#.

Другой частой причиной для размещения определённых веток каталогов в отдельных файловых системах является их расположение на отдельных физических дисках, отдельных виртуальных дисках, например, в Network File System, описанной в отдельном crossref:network-servers[network-nfs,разделе), или на CDROM.

[[disks-fstab]]
=== Файл [.filename]#fstab#

В процессе загрузки (<<boot>>) файловые системы, перечисленные в [.filename]#/etc/fstab#, монтируются автоматически, за исключением тех, для которых указан параметр `noauto`.
Этот файл содержит записи в следующем формате: 

[.programlisting]
....

	устройство	/точка-монтирования	тип файловой системы	опции	частота дампов	порядок проверки
....

`устройство`::
Имя существующего устройства, соответствующее описанному в crossref:disks[disks-naming,Имена устройств].

`точка монтирования`::
Существующий каталог, предназначенный для монтирования файловой системы.

`тип файловой системы`::
Тип файловой системы, который передается программе man:mount[8]. По умолчанию FreeBSD использует `ufs`.

`опции`::
Либо `rw` для монтирования файловой системы в режиме чтения и записи, либо `ro` для файловых систем, доступных только в режиме чтения, за которыми могут следовать и другие нужные параметры. Довольно часто используется опция `noauto`, чтобы не монтировать автоматически файловые системы в процессе загрузки. Остальные параметры перечислены в man:mount[8].

`частота дампов`::
Используется утилитой man:dump[8] для указания файловых систем, с которых требуется снимать копии. При отсутствии этого параметра он принимает нулевое значение.

`порядок проверки`::
Определяет порядок, в котором должны проверяться файловые системы. Для файловых систем, которые должны быть пропущены при проверке, параметр `passno` должен быть установлен в нулевое значение. Корневая файловая система должна проверяться в первую очередь и иметь значение `passno`, установленное равным единице. Для других файловых систем значение этого параметра должно превышать единицу. Если две и более файловые системы имеют одинаковое значение `passno`, то man:fsck[8] будет пытаться проверять файловые системы параллельно, если это возможно.

Обратитесь к man:fstab[5] для получения дополнительной информацией о формате файла [.filename]#/etc/fstab# и его параметрах.

[[disks-mount]]
=== Использование man:mount[8]

Файловые системы монтируются при помощи man:mount[8].
Самый простой формат имеет следующий вид:

[example]
====
[source,shell]
....
# mount __device__ __mountpoint__
....
====

Эта команда имеет достаточное количество параметров, описанных в man:mount[8].
Самые часто используемые параметры таковы:

.Опции монтирования
`-a`::
Смонтировать все файловые системы, перечисленные в файле [.filename]#/etc/fstab#, за исключением тех, что помечены как "noauto", исключены параметром `-t` или уже смонтированы.

`-d`::
Сделать все, кроме самого системного вызова mount. Эта опция полезна вместе с флагом `-v` для определения того, что на самом деле пытается сделать man:mount[8].

`-f`::
Принудительное монтирование непроверенного раздела (опасно) или аннулирование полномочий на операции записи данных при понижении статуса монтирования файловой системы с доступной на чтение-запись на доступной только для операций чтения.

`-r`::
Монтировать файловую систему в режиме только для чтения. Идентично использованию параметра `-o ro`.

`-t` _fstype_::
Смонтировать указанный тип файловой системы или, в случае указания `-a`, монтировать файловые системы только данного типа. По умолчанию применяется тип файловой системы "ufs".

`-u`::
Обновить опции монтирования для файловой системы.

`-v`::
Выдавать более подробную информацию.

`-w`::
Монтировать файловую систему в режиме "чтение-запись".

Следующие значения могут быть переданы в качестве аргументов `-o` в виде списка значений, разделённых запятыми:

nosuid::
Игнорировать setuid и setgid биты на файловой системе (еще одна полезная опция для повышения безопасности системы).

[[disks-umount]]
=== Использование man:umount[8]

Для размонтирования файловой системы используйте man:umount[8].
Эта команда принимает один параметр, который может соответствовать точке монтирования, имени устройства либо принимать значение `-a` или `-A`.

Во всех вариантах принимается параметр `-f` для принудительного размонтирования и `-v` для выдачи подробной информации.
Имейте в виду, что применение `-f` в целом не рекомендутся, так как может привести к аварийному завершению работы компьютера или повредить данные в файловой системе.

Для размонтирования всех смонтированных файловых систем или только тех типов файловых систем, что перечислены после параметра `-t`, воспользуйтесь параметрами `-a` и `-A`.
Заметьте, что при использовании `-A` попытка размонтирования корневой файловой системы не предпринимается.

[[basics-processes]]
== Процессы и Даемоны

FreeBSD является многозадачной операционной системой.
Каждая программа, выполняющаяся в некоторый выбранный момент времени, называется _процессом_.
Каждая запускаемая команда порождает хотя бы один новый процесс, и имеется определённое количество системных процессов, которые запускает FreeBSD.

Каждый процесс идентифицируется уникальным номером, называемым _идентификатором процесса_ (_process ID_) или _PID_.
Подобно файлам, у каждого процесса имеется один владелец и группа, при этом полномочия владельца и группы используются для определения того, какие файлы и устройства могут быть открыты процессом.
У большинства процессов также есть родительский процесс, которых их запустил.
Например, командная оболочка является процессом, и любая команда, запущенная из командной оболочки, является процессом, для которого командная оболочка является родительским процессом.
Исключением из этого правила является специальный процесс, который называется man:init[8], который всегда является первым процессом, запускаемым во время загрузки, и который всегда имеет PID, равный `1`.

Некоторые программы спроектированы не для того, чтобы работать в режиме ввода команд пользователя, и отключаются от терминала при первой возможности.
К примеру, веб-сервер отвечает на веб-запросы, а не на команды пользователя.
Другим примером такого типа приложений являются почтовые серверы.
Программы такого типа известны под названием _даемоны_.
Понятие даемона пришло из греческой мифологии и обозначает сущность, которая не является ни хорошей, ни плохой, и которая невидимо выполняет полезные дела.
Это объясняет тот факт, что талисманом BSD является дружелюбно выглядящий даемон в кедах и с вилами.

Имеется соглашение, по которому программы, обычно работающие в режиме даемона, именуются с "d" в конце названия.
К примеру, BIND означает Berkeley Internet Name Domain, но на самом деле исполняемой программой является `named`.
Программой веб-сервера Apache является `httpd`, а даемоном очереди принтера является `lpd`.
Это всего лишь соглашение об именовании.
К примеру, основной почтовый даемон для приложения Sendmail называется `sendmail`, а не `maild`.

=== Просмотр процессов

Для просмотра процессов, работающих в системе, воспользуйтесь man:ps[1] или man:top[1].
Для выдачи статичного списка выполняемых в данный момент процессов, их PID, объёма используемой ими памяти и команды, которой они были запущены, используйте man:ps[1].
Для отображения всех выполняющихся процессов и обновления этого списка каждые несколько секунд в целях интерактивного наблюдения за тем, что делает компьютер, используйте man:top[1].

По умолчанию man:ps[1] показывает пользователю только те команды, которые запущены пользователем и владельцем которых он является.
К примеру:

[source,shell]
....
% ps
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps
....

Выдача команды man:ps[1] организована в несколько столбцов.
Столбец `PID` отображает идентификатор процесса.
PID назначаются начиная с 1 и увеличиваются до 99999, а затем отсчёт начинается с начала.
Однако PID не назначается повторно, если он уже используется.
Столбец `TT` показывает терминал (tty), на котором выполняется программа, а `STAT` показывает состояние программы.
`TIME` соответствует количеству времени, которое программа выполняется на центральном процессоре.
Обычно это не то же самое время, что прошло с момента запуска программы, поскольку большинство программ проводят много времени в ожидании некоторого события, прежде чем занять время процессора.
Наконец, `COMMAND` содержит команду, которая использовалась для запуска программы.

Имеется множество различных опций для изменения выводимой информации.
Один из наиболее полезных наборов опций это `auxww`, при этом `a` отображает информацию о всех запущенных процессах всех пользователей, `u` показывает имя и объём используемой памяти пользователя, владеющего процессом, `x` отображает информацию о процессах-даемонах, а `ww` указывает man:ps[1] на отображение всей командной строки для каждого процесса, вместо её обрезания в случае, если она слишком длинная, чтобы уместиться на экран.

Вывод man:top[1] выглядит похожим образом:

[source,shell]
....
% top
last pid:  9609;  load averages:  0.56,  0.45,  0.36              up 0+00:20:03 10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% nice,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 -21  r31   136M 42296K select  0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K select  3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K select  0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M select  0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M select  2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K select  3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K select  1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K select  1   0:05  0.00% kdeinit4
....

Вывод разбит на два раздела.
Заголовок (первые пять или шесть строк) показывает PID последнего запущенного процесса, среднее значение загрузки системы (которое показывает насколько система занята), время работы системы с последней перезагрузки и текущее время.
Остальные числа в заголовке относятся к количеству работающих процессов, объёму использования оперативной памяти и пространства подкачки, а также количеству времени, проводимого системой в различных состояниях центрального процессора.
Если был загружен модуль файловой системы ZFS, то строка `ARC` содержит информацию о том, какой объём данных был считан из кэша оперативной памяти, а не с диска.

Под заголовком размещены несколько столбцов, содержащих информацию, похожую на результат работы man:ps[1], такую как PID, имя пользователя, объём времени ЦПУ и команда, которая запустила процесс.
По умолчанию man:top[1] показывает также объём памяти, занятой процессом.
Эта информация разделена на два столбца: один для суммарного объёма и один для занимаемого.
Суммарный объём соответствует тому, что требовался приложению, а занимаемый соответствует объёму, фактически используемому сейчас.

man:top[1] автоматически обновляет экран каждые две секунды.
Другое значение этого временного интервала может быть задано при помощи параметра `-s`.

[[basics-daemons]]
=== Прекращение процессов

Одним из способов взаимодействия с любым работающим процессом или даемоном является отправка ему _сигнала_ при помощи команды man:kill[1].
Имеется множество различных сигналов; некоторые из них имеют специальное значение, тогда как другие описаны в документации приложения.
Пользователь может посылать какой-либо сигнал только тем процессам, владельцем которых он является, а отправка сигнала процессу какого-то другого пользователя приведёт к ошибке запрета доступа.
Исключением является пользователь `root`, который может отправлять сигналы чьим угодно процессам.

Операционная система также может отправлять сигнал процессу.
Если приложение написано некорректно и пытается обратиться к области памяти, к которой оно не должно обращаться, FreeBSD посылает процессу сигнал "Segmentation Violation" (`SIGSEGV`).
Если приложение было написано с учётом использования системного вызова man:alarm[3] для получения уведомления по истечении определённого периода времени, то ему будет отправлен сигнал "Alarm" (`SIGALRM`).

Для остановки процесса могут использоваться два сигнала: `SIGTERM` и `SIGKILL`.
`SIGTERM` является вежливым способом завершить процесс, так как процесс может считать сигнал, закрыть какие-либо протоколирующие файлы, которые он мог открыть, и завершить то, что он делал до завершения работы.
В некоторых случаях процесс может даже игнорировать `SIGTERM`, если выполняет задачу, которая не может быть прервана.

`SIGKILL` не может быть проигнорирован процессом.
Отправка процессу `SIGKILL` обычно остановит этот процесс тотчас же.

[NOTE]
====
Существует несколько задач, которые не могут быть прерваны.
К примеру, если процесс пытается выполнить чтение файла, находящегося на другом компьютере в сети, а другой компьютер недоступен, то такой процесс называют "непрерываемым".
В конце концов время процесса истечёт, обычно после двух минут ожидания.
Как только такой таймаут случится, процесс будет прекращён.
====

Другими часто используемыми сигналами являются `SIGHUP`, `SIGUSR1` и `SIGUSR2`.
Так как эти сигналы являются сигналами общего назначения, различные приложения будут реагировать на них по-разному.

Например, после внесения изменений в конфигурационный файл веб-сервера ему нужно указать на повторное считывание настроек.
Перезапуск `httpd` привёл бы к краткосрочной недоступности веб-сервера.
Вместо этого отправьте даемону сигнал `SIGHUP`.
Имейте в виду, что разные даемоны будут вести себя по-разному, поэтому обратитесь к документации по даемону для определения того, достигнет ли `SIGHUP` желаемых результатов.

[.procedure]
====
*Procedure: Отправка сигнала процессу*

Этот пример показывает, как послать сигнал man:inetd[8].
Конфигурационным файлом для man:inetd[8] является [.filename]#/etc/inetd.conf#, и man:inetd[8] перечитает этот файл с настройками, если ему будет отправлен сигнал `SIGHUP`.

. Определите PID процесса, которому будет отправлен сигнал, при помощи man:pgrep[1]. В данном примере PID для man:inetd[8] равен 198:
+
[source,shell]
....
% pgrep -l inetd
198  inetd -wW
....
+ 

. Используйте man:kill[1] для отправки сигнала. Поскольку владельцем man:inetd[8] является `root`, сначала воспользуйтесь командой man:su[1] для получения прав `root`.
+
[source,shell]
....
% su
Password:
# /bin/kill -s HUP 198
....
+
Как и большинство команд UNIX(R), man:kill[1] ничего не выдаёт, если отрабатывает нормально. Если сигнал посылается процессу, владельцем которого пользователь не является, то будет выдано сообщение `kill: _PID_: Operation not permitted`. При неправильно набранном PID сигнал будет направлен либо не тому процессу, что может привести к неприятным последствия, либо в адрес PID, который в данный момент не используется, что приведёт к ошибке `kill: _PID_: No such process`.
+
[NOTE]
.Зачем использовать `/bin/kill`?
======
Во многих оболочках команда `kill` является встроенной, а это означает, что командный процессор вместо запуска [.filename]#/bin/kill# будет посылать сигнал напрямую.
Учитывайте тот факт, что разные командные процессоры имеют разный синтаксис для указания имени отправляемого сигнала.
Вместо того, чтобы пытаться выучить их все, гораздо простым способом может оказаться указание `/bin/kill _..._`.
======
====

При отправке другого сигнала замените `TERM` или `KILL` именем этого сигнала.

[IMPORTANT]
====
Прекращение случайного процесса в системе является плохой затеей.
В частности, man:init[8], чей PID равен 1, является особенным процессом.
Выполнение `/bin/kill -s KILL 1` является быстрым и нерекомендуемым способом завершить работу системы.
_Всегда_ дважды проверяйте параметры запуска man:kill[1] _перед_ тем, как нажать на kbd:[Return].
====

[[shells]]
== Командные процессоры

_Командный процессор_ (или оболочка) предоставляет интерфейс командной строки для взаимодействия с операционной системой.
Командный процессор получает команды из канала ввода и исполняет их.
Многие командные интерпретаторы имеют встроенные функции, помогающие выполнять такие повседневной задачи, как управление файлами, включая их массовую обработку, редактирование командной строки, работа с макрокомандами и переменными окружения.
FreeBSD поставляется вместе с несколькими командными процессорами, среди которых Bourne Shell (man:sh[1]) и расширенная версия C-shell (man:tcsh[1]),
Другие командные процессоры, такие как `zsh` и `bash`, доступны в Коллекции портов FreeBSD.

Выбор используемого интерпретатора командной строки на самом деле является делом вкуса.
Программист на языке C может чувствовать себя более комфортно с C-подобной оболочкой типа man:tcsh[1].
Пользователь Linux(R) может предпочесть `bash`.
Каждый командный процессор имеет свои уникальные особенности, которые могут работать, а могут и не работать в рабочем окружении, которое предпочитает пользователь, и именно поэтому имеются варианты выбора используемой оболочки.

Одной из распространённых функций оболочки командной строки является дополнение частичного имени файла до полного.
После того, как пользователь набирает несколько первых символов команды или имени файла и нажимает клавишу kbd:[Tab], командный процессор дополняет имя команды или файла до полного наименования.
Рассмотрим случай с двумя файлами, которые называются [.filename]#foobar# и [.filename]#football#.
Для удаления [.filename]#foobar# пользователь может набрать `rm foo` и нажать kbd:[Tab] для формирования полного имени файла.

Однако оболочка только лишь отобразит `rm foo`.
Сформировать полное имя файла невозможно, так как и [.filename]#foobar#, и [.filename]#football# начинаются с `foo`.
Некоторые командные процессоры издадут звуковой сигнал или отобразят все варианты, если имеются совпадения более чем у одного имени.
Тогда пользователь должен набрать дополнительные символы для идентификации желаемого имени файла.
Набор `t` и повторное нажатие kbd:[Tab] достаточно для того, чтобы командный процессор определил желаемый файл и дополнил остаток его имени.

Дополнительные возможности при работе с интерпретатором дает использование переменных окружения.
Переменные окружения представляют собой пары переменная/значение, сохраняемые в рабочем окружении интерпретатора.
Это рабочее окружение может быть прочитано любой программой, запущенной из командного интерпретатора, и, таким образом, содержит много информации для настройки приложения.
<<shell-env-vars>> содержит список часто используемых переменных окружения и их значений.
Заметьте, что имена переменных окружения всегда пишутся заглавными буквами.

[[shell-env-vars]]
.Часто используемые переменные окружения
[cols="25h,~"]
|===
| Переменная
| Описание

|`USER`
|Имя текущего пользователя.

|`PATH`
|Каталоги, разделенные двоеточием, для поиска исполняемых файлов.

|`DISPLAY`
|Сетевое имя дисплея Xorg для подключения при его доступности.

|`SHELL`
|Текущий командный интерпретатор.

|`TERM`
|Тип терминала пользователя. Используется, чтобы узнать возможности терминала.

|`TERMCAP`
|Список escape-последовательностей для управления различными функциями терминала.

|`OSTYPE`
|Вид операционной системы.

|`MACHTYPE`
|Процессорная архитектура системы.

|`EDITOR`
|Выбранный пользователем текстовый редактор.

|`PAGER`
|Предпочитаемая пользователем утилита для постраничного просмотра текста.

|`MANPATH`
|Каталоги, разделенные двоеточием, для поиска файлов системного справочника.
|===

Порядок установки значения переменной окружения различна для разных оболочек.
В командных процессорах man:tcsh[1] и man:csh[1] для задания переменных окружения используется `setenv`.
В интерпретаторах man:sh[1] и `bash` для задания актуального значения переменных окружения используется `export`.
В этом примере для man:tcsh[1] значение по умолчанию для переменной `EDITOR` устанавливается равным [.filename]#/usr/local/bin/emacs#:

[source,shell]
....
% setenv EDITOR /usr/local/bin/emacs
....

Аналогичная команда для `bash` была бы следующей:

[source,shell]
....
% export EDITOR="/usr/local/bin/emacs"
....

Чтобы раскрыть значение переменной окружения для того, чтобы посмотреть её текущее значение, в командной строке наберите символ `$` перед именем переменной.
Например, `echo $TERM` выведет актуальное значение для `$TERM`.

Командные процессоры обрабатывают специальные символы, называемые метасимволами, как особое обозначение данных.
Самым общеупотребительным метасимволом является `\*`, который обозначает любое количество символов в имени файла.
Метасимволы могут использоваться для выполнения массовых операций с именами файлов.
Например, команда `echo *` равнозначна команде `ls`, поскольку оболочка выбирает все файлы, соответствующие `*`, а `echo` выдаёт их список в командной строке.

Чтобы предотвратить обработку специального символа командным процессором, экранируйте его, предварив наклонной чертой влево `\` (обратным слэшем).
Например, `echo $TERM` выведет значение настройки терминала, тогда как `echo \$TERM` выведет в буквальном смысле строку `$TERM`.

[[changing-shells]]
=== Смена командного процессора

Самым простым способом замены командного процессора, используемого по умолчанию, на постоянной основе является использование команды `chsh`.
При запуске этой команды открывается редактор, настроенный в переменной окружения `EDITOR`, значение которой по умолчанию равно man:vi[1].
Измените строку `Shell:`, указав полный путь для нового командного процессора.

Альтернативным способом является использование команды `chsh -s`, которая настроит указанную оболочку без открытия редактора.
Например, для замены командного процессора на `bash`:

[source,shell]
....
% chsh -s /usr/local/bin/bash
....

[NOTE]
====
Новая оболочка _обязательно_ должна присутствовать в файле [.filename]#/etc/shells#.
Если командный процессор был установлен из Коллекции портов FreeBSD, как это описано в главе <<ports>>, то он должен быть добавлен в этот файл автоматически.
Если его там нет, добавьте его при помощи следующей команды, заменив путь на маршрут соответствующей оболочки:

[source,shell]
....
# echo __/usr/local/bin/bash__ >> /etc/shells
....

После этого запустите man:chsh[1] повторно.
====

=== Расширенные функции оболочки

Оболочка UNIX(R) является не только лишь интерпретатором команд, она также выступает в роли мощного инструмента, позволяющего пользователям выполнять команды, перенаправлять их результирующий и входной потоки, а также выстраивать последовательность команд для улучшения выдачи финализирующей команды.
Когда такая функциональность объединяется со встроенными командами, пользователь получает окружение, которое может дать максимальный эффект.

Перенаправление на уровне оболочки представляет собой действие по отправке результата работы или входного потока какой-либо команды в другую команду или в файл.
Для записи результата работы команды man:ls[1], например, в файл, перенаправьте выходной поток:

[source,shell]
....
% ls > directory_listing.txt
....

Список содержимого каталога теперь будет находиться в [.filename]#directory_listing.txt#.
Некоторые команды, подобные man:sort[1], могут использоваться для чтения входного потока.
Для сортировки этого списка перенаправьте входной поток:

[source,shell]
....
% sort < directory_listing.txt
....

Входной поток будет отсортирован и размещён на экране.
Для перенаправления этого ввода в другой файл можно перенаправить выходной поток man:sort[1], объединив направление:

[source,shell]
....
% sort < directory_listing.txt > sorted.txt
....

Во всех примерах выше команды выполняют перенаправление при помощи файловых дескрипторов.
В каждой системе UNIX(R) имеются файловые дескрипторы, среди которых имеются стандартный ввод (stdin), стандартный вывод (stdout) и стандартная диагностика (stderr).
У каждого из них имеется своё назначение, и здесь вводом может быть клавиатура или мышь, что-то, формирующее входной поток.
Выводом может быть экран или бумага в принтере.
А диагностикой может быть что угодно, используемое для диагностических сообщений или сообщений об ошибках.
Все три рассматриваются как файловые дескрипторы ввода-вывода и иногда рассматриваются как потоки.

Посредством использования этих дескрипторов командный процессор обеспечивает прохождение ввода и вывода через различные команды и их перенаправление в файл или из файла.
Ещё одним методом перенаправления является оператор конвейера.

Оператор конвейера UNIX(R), "|", позволяет прямую передачу или перенаправление вывода одной команды в другую программу.
Проще говоря, конвейер позволяет передавать стандартный вывод какой-либо команды в качестве стандартного ввода другой команде, к примеру:

[source,shell]
....
% cat directory_listing.txt | sort | less
....

В этом примере содержимое [.filename]#directory_listing.txt# будет отсортировано, а вывод передан в man:less[1].
Это позволяет пользователю просматривать результат в собственном темпе и не позволяет выходить за рамки экрана.

[[editors]]
== Текстовые редакторы

Большинство настроек FreeBSD осуществляется редактированием текстовых файлов.
В силу этого обстоятельства хорошей идеей является освоение текстового редактора.
Несколько редакторов поставляются с FreeBSD в составе базового комплекта системы, и гораздо больше доступно в Коллекции портов.

Простым в освоении редактором является man:ee[1], что означает "easy editor" ("лёгкий редактор").
Чтобы запустить его, наберите `ee __filename__`, где _filename_ является именем редактируемого файла.
Внутри редактора все команды для управления его функциями перечислены вверху экрана.
Карет (`^`) обозначает клавишу kbd:[Ctrl], таким образом, `^e` означает комбинацию клавиш kbd:[Ctrl+e].
Чтобы выйти из man:ee[1], нажмите клавишу kbd:[Esc], затем выберите пункт "leave editor" в главном меню.
Редактор запросит сохранение изменений, если файл был изменён.

Во FreeBSD также имеются более мощные текстовые редакторы типа man:vi[1], поставляемого как часть базового системного комплекта.
Другие редакторы, подобные package:editors/emacs[] и package:editors/vim[], являются частью Коллекции портов FreeBSD.
Эти редакторы обладают большей функциональностью, но также они более сложны в изучении.
Изучение более мощных редакторов типа vim или Emacs может сэкономить вам больше времени в долгосрочной перспективе.

Многие приложения, модифицирующие файлы или требующие текстового ввода, автоматически открывают текстовый редактор.
Чтобы сменить редактор, заданный по умолчанию, определите значение переменной окружения `EDITOR`, как это описано в разделе об <<shells,оболочках>>.

[[basics-devices]]
== Устройства и файлы устройств

Термин "устройство" используется в основном по отношению к аппаратному обеспечению системы, такому как диски, принтеры, графические адаптеры и клавиатуры.
При загрузке FreeBSD основной объём выдаваемых сообщений относится к обнаруживаемым устройствам.
Копии сообщений, выдаваемых при загрузке, сохраняются в [.filename]#/var/run/dmesg.boot#.

Каждое устройство имеет имя и номер.
Например, [.filename]#ada0# соответствует первому приводу жёстких дисков с интерфейсом SATA, а [.filename]#kbd0# представляет собой клавиатуру.

Во FreeBSD доступ к большинству устройств обязательно должен осуществляться через специальные файлы, называемые узлами устройств, которые размещаются в [.filename]#/dev#.

[[basics-more-information]]
== Страницы Справочника

Пожалуй, самая полная документация по FreeBSD имеет форму страниц справочной системы. Практически каждое приложение или утилита имеют соответствующую страницу (часто не одну), описывающую основы работы и различные параметры.
Эти справочники можно просматривать при помощи `man`:

[source,shell]
....
% man __command__
....

Здесь _command_ является названием команды, информацию о которой нужно получить.
Например, чтобы узнать больше о команде man:ls[1], наберите:

[source,shell]
....
% man ls
....

Страницы Справочника разделены на разделы, соответствующие различному типу содержимого.
Во FreeBSD имеются следующие разделы:

. Пользовательские команды.
. Системные вызовы и коды ошибок.
. Функции стандартных библиотек.
. Драйверы устройств.
. Форматы файлов.
. Развлечения и игры.
. Дополнительная информация.
. Команды системного администрирования.
. Интерфейсы ядра системы.

В некоторых случаях одна и та же тема может появиться в различных разделах справочника.
Например, существуют пользовательская команда `chmod` и системный вызов `chmod()`.
Для указания команде man:man[1] искомого раздела задайте его номер:

[source,shell]
....
% man 1 chmod
....

При этом будет выведена справка о пользовательской команде man:chmod[1].
По традиции документирования ссылки на конкретный раздел онлайного справочника указываются в скобках, так что man:chmod[1] относится к пользовательской команде, man:chmod[2] указывает на соответствующий системный вызов.

Если название страницы Справочника неизвестно, воспользуйтесь `man -k` для поиска по ключевым словам, встречающимся в описаниях страниц Справочника:

[source,shell]
....
% man -k __mail__
....

Эта команда выдаёт список команд, имеющих ключевое слово "mail" в своих описаниях.
Это равнозначно использованию команды man:apropos[1].

Чтобы прочитать описания всех команд из [.filename]#/usr/bin#, наберите:

[source,shell]
....
% cd /usr/bin
% man -f * | more
....

или

[source,shell]
....
% cd /usr/bin
% whatis * |more
....

[[basics-info]]
=== Файлы GNU Info

FreeBSD поставляется с некоторым количеством приложений и утилит, выпущенных Free Software Foundation (FSF).
В дополнение к страницам справочника, с этими программами могут поставляться гипертекстовые документы в виде так называемых файлов `info`.
Они могут быть просмотрены с помощью команды man:info[1] или, если установлен пакет package:editors/emacs[], в режиме info редактора emacs.

Чтобы использовать man:info[1], наберите:

[source,shell]
....
% info
....

Вызвать на экран краткое введение можно набрав `h`.
Краткий список команд можно получить, набрав `?`.
