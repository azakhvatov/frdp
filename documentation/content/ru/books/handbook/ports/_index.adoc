//
// The FreeBSD Russian Documentation Project
//
// Original EN revision (19.01.2023): c5fa554557e5cb07eec0446c7fcef05090065fb6
//

---
title: "Глава 5. Установка приложений: порты и пакеты"
part: Часть I. Начало работы
prev: books/handbook/basics
next: books/handbook/x11
description: "FreeBSD имеет две взаимодополняющие технологии для установки программного обеспечения сторонних разрабочиков: Коллекцию Портов FreeBSD для установки из исходных текстов и пакеты для установки из уже скомпилированных бинарных файлов"
tags: ["порты", "коллекция", "pkg", "poudriere", "управление"]
showBookMenu: true
weight: 6
path: "/books/handbook/"
aliases: ["/ru/books/handbook/ports-overview/","/ru/books/handbook/ports-finding-applications/","/ru/books/handbook/pkgng-intro/","/ru/books/handbook/ports-using/","/ru/books/handbook/ports-poudriere/","/ru/books/handbook/ports-nextsteps/","/ru/books/handbook/ports-broken/"]
---

[[ports]]
= Установка приложений: порты и пакеты
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 4
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/ports/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[ports-synopsis]]
== Обзор

Вместе с FreeBSD в составе базового комплекта системы поставляется богатый набор системный утилит.
Кроме того, FreeBSD предоставляет две взаимодополняющие технологии для установки программного обеспечения сторонних разработчиков: Коллекция Портов FreeBSD для установки из исходного кода и пакеты для установки из откомпилированных бинарных файлов.'
Любой из этих методов может быть использован для установки приложений с локальных носителей или из сети.

После чтения этой главы вы будете знать:

* Разницу между бинарными пакетами и портами.
* Как найти программное обеспечение сторонних разработчиков, которое было перенесено во FreeBSD.
* Как управлять бинарными пакетами при помощи pkg.
* Как компилировать программное обеспечение сторонних разработчиков из исходных текстов с использованием Коллекции Портов.
* Как найти файлы, установленные вместе с определённым приложением, для настройки после установки.
* Что делать, если установка программного обеспечения завершается неудачно.

[[ports-overview]]
== Обзор установки программного обеспечения

_Порт_ FreeBSD является набором файлов, предназначенных для автоматизации процесса компиляции приложения из исходного кода.
Файлы, из которых состоит порт, содержат всю необходимую информацию для выполнения автоматической загрузки, извлечения, применения патчей, компиляции и установки приложения.

Если определённое программное обеспечение ещё не было адаптировано и протестировано на FreeBSD, то может потребоваться редактирование исходного кода для его корректной установки и работы.

Несмотря на это, более {numports} приложений сторонних разработчиков уже было перенесено во FreeBSD.
По возможности эти приложения делаются доступными к сгрузке в виде уже откомпилированных _пакетов_.

Пакетами можно управлять при помощи соответствующих команд управления пакетами FreeBSD.

Как пакеты, так и порты принимают во внимание зависимости.
Если для установки приложения используется пакет или порт, а необходимая библиотека ещё не была установлена, то в автоматическом режиме сначала будет установлена библиотека.

Во FreeBSD пакет содержит уже откомпилированные копии всех команд приложения, а также все конфигурационные файлы и документацию.
Пакетом можно управлять командами man:pkg[8], такими, как `pkg install`.

Несмотря на то, что обе технологии похожи, и пакеты, и порты имеют свои преимущества. Выберите технологию, которая соответствует вашим требованиям к установке конкретного приложения.

.Преимущества пакетов
* Сжатый tar-архив пакета обычно меньше, чем сжатый tar-архив, содержащий исходный код приложения.
* Пакеты не требуют времени на компиляцию. Для больших приложений, таких как Firefox, KDE Plasma или GNOME, это может быть важным на медленной системе.
* Пакеты не требуют понимания процесса компиляции программного обеспечения во FreeBSD.

.Преимущества портов
* Пакеты обычно компилируются с консервативными параметрами, потому что они должны работать на максимальном количестве систем. При установке из порта становится возможным изменение опций компиляции.
* Некоторые приложения имеют параметры, задаваемые на этапе компиляции и имеющие отношение к активируемым функциональным возможностям. К примеру, NGINX(R) может быть сконфигурирован с широким набором различных встроенных возможностей.
+
В некоторых случаях для одного и того же приложения будут иметься несколько пакетов с разными предварительными настройками. Например, NGINX(R) доступен как пакет `nginx` и как пакет `nginx-lite`, в зависимости от того, установлен ли Xorg. Создание нескольких пакетов одного приложения быстро становится невозможным, если приложение имеет более одного или двух параметров, задаваемых во время компиляции.
* Условия лицензирования некоторого программного обеспечения запрещают распространение в двоичном виде. Такое программное обеспечение должно распространяться в виде исходного кода и компилироваться конечным пользователем.
* Некоторые пользователи не доверяют дистрибутивам в двоичном виде или предпочитают прочесть исходный код и попытаться найти потенциальные проблемы.
* Исходный код нужен для того, чтобы применять специально разработанные корректировки.

Чтобы отслеживать обновления портов, подпишитесь на {freebsd-ports} и {freebsd-ports-bugs}.

[WARNING]
====
Перед установкой любого приложения сверьтесь с https://vuxml.freebsd.org/[] на предмет наличия проблем с безопасностью, связанных с этим приложением, либо наберите `pkg audit -F` для проверки всех установленных приложений на наличие известных уязвимостей.
====

В оставшейся части рассказывается о том, как использовать пакеты и порты для установки и управления программным обеспечением сторонних разработчиков во FreeBSD.

[[ports-finding-applications]]
== Поиск программного обеспечения

Список имеющихся для FreeBSD приложений постоянно растёт.
Существует несколько способов найти программное обеспечение для установки:

* На веб-сайте FreeBSD в разделе link:https://www.FreeBSD.org/ports/[Портал портов] поддерживается обновляемый список всех имеющихся приложений для FreeBSD, в котором можно выполнять поиск. Поиск порта можно выполнить либо по имени приложения, либо по названию категории.
* Дэн Лэнджил поддерживает сайт link:https://www.freshports.org/[FreshPorts], содержащий полноценные средства поиска и отслеживания изменений в приложениях из Коллекции Портов. Зарегистрированные пользователи могут создавать собственные списки отслеживаемых портов для того, чтобы в автоматическом режиме получать сообщения электронной почты при их обновлении.
* Если поиск определённого приложения является затруднительным, попытайтесь выполнить поиск на сайте, подобном https://www.sourceforge.net/[SourceForge] или https://www.github.com/[GitHub], а затем вернитесь на link:https://www.FreeBSD.org/ports/[Портал портов], чтобы проверить, не было ли это приложение портировано.
* Поиск приложения в хранилище бинарных пакетов при помощи команды man:pkg[8]

[[pkgng-intro]]
== Использование pkg для управления бинарными пакетами

man:pkg[8] предоставляет интерфейс для управления пакетами: регистрации, добавления, удаления и обновления.

Для организаций, желающих использоваться только уже подготовленные бинарные пакеты с зеркал FreeBSD, управления пакетами при помощи man:pkg[8] может быть достаточно.

Однако для тех случаев, когда выполняется построение из исходных текстов, будет требоваться отдельный <<ports-upgrading-tools, инструмент управления портами>>.

Так как man:pkg[8] работает только с бинарными пакетами, он не является заменой подобных инструментов.
Упомянутые инструменты могут использоваться для установки программного обеспечения как из бинарных пакетов, так и из Коллекции Портов, тогда как man:pkg[8] устанавливает исключительно бинарные пакеты.

[[pkgng-initial-setup]]
=== Начало работы с pkg

Во всех поддерживаемых версиях FreeBSD теперь имеется утилита `/usr/sbin/pkg`, известная как man:pkg[7].
Это всего лишь небольшой заменитель, обладающий только минимальной функциональностью, требуемой для установки полноценного man:pkg[8].

[NOTE]
====
Для успешного завершения процесса первичной загрузки требуется работающее соединение с Интернет.
====

Запустите man:pkg[8] из командной строки:

[source,shell]
....
# pkg
....

Выдаваемый результат должен быть похож на следующее:

[.programlisting]
....
The package management tool is not yet installed on your system.
Do you want to fetch and install it not? [y/N]
....

man:pkg[7] перехватит эту команду, и если вы подтвердите свои намерения, сгрузит файл с архивом man:pkg[8], установит из него man:pkg[8], выполнит первичную загрузку локальной базы данных пакетов и затем продолжит исполнение команды, которая изначально была запрошена.

Более новые версии man:pkg[7] принимают `pkg -N` в качестве проверки наличия установленного man:pkg[8] без запуска установки, и наоборот, pkg bootstrap[-f] для установки man:pkg[8] (или принудительной повторной установки) без выполнения каких-либо других действий.

Информация о порядке использования pkg доступна на справочной странице по man:pkg[8] или в выводе утилиты `pkg`, запущенной без дополнительных параметров.
Дополнительные параметры настройки pkg описаны в man:pkg.conf[5].

Каждый параметр команды pkg описан на соответствующей странице справочника.
Например, чтобы ознакомиться со страницей справочника по `pkg install`, запустите следующую команду:

[source,shell]
....
# pkg help install
....

В оставшейся части этого раздела демонстрируются частые задачи управления бинарными пакетами, которые могут быть выполнены при помощи man:pkg[8].
Каждая из показываемых команд имеет много параметров для различных целей использования.
Обратитесь к встроенной справочной информации о команде или странице Справочника за деталями и дополнительными примерами.

[[quarterly-latest-branch]]
=== Квартальные ветки и ветка с самыми последними портами

Ветка `Quarterly` даёт пользователям больше предсказуемости и стабильности при установке и модернизации портов и пакетов.
В целом это обеспечивается за счёт применения обновлений, исключающих новую функциональность.
Квартальные ветки направлены на предоставление исправлений безопасности (это могут быть обновления версий или перенос изменений из более новых версий), исправлений ошибок или соответствий политикам, а также изменений в программных инструментах.
Ветка Quarterly формируется из HEAD в начале каждого квартала (года) в январе, апреле, июле и октябре.
Ветки именуются в соответствии с нумерацией года (YYYY) и квартала (Q1-4), в котором они создаются.
К примеру, квартальная ветка, созданная в январе 2023 года, именуется как 2023Q1.
А ветка `Latest` предоставляет пользователям самые последние версии пакетов.

Для переключения от квартальной ветке к ветке с последними версиями выполните следующие команды:

[source,shell]
....
# mkdir -p /usr/local/etc/pkg/repos
# cp /etc/pkg/FreeBSD.conf /usr/local/etc/pkg/repos/FreeBSD.conf
....

Отредактируйте файл `/usr/local/etc/pkg/repos/FreeBSD.conf` и замените текст _quarterly_ на _latest_ в строке `url:`.

Результат должен быть похож на следующее:

[.programlisting]
....
FreeBSD: {
	url: "pkg+http://pkg.FreeBSD.org/${ABI}/latest",
	mirror_type: "srv",
	signature_type: "fingerprints",
	fingerprints: "/usr/share/keys/pkg",
	enabled: yes
}
....

И, наконец, запустите следующую команду для обновления метаданных из нового (latest) хранилища.

[source,shell]
....
# pkg update -f
....

[[pkg-configuration]]
=== Настройка pkg

man:pkg.conf[5] является общесистемным конфигурационным файлом, используемым инструментами man:pkg[8].
По умолчанию этот файл размещён в `/usr/local/etc/pkg.conf`.

[NOTE]
====
Для FreeBSD присутствие файла `pkg.conf` не является обязательным.
Многие инсталляции будут хорошо работать вовсе без `pkg.conf` или с пустым (содержащим только строки комментариев) `pkg.conf`.
====

Строки этого файла, начинающиеся с "#", являются комментариями и не орабатываются.

Файл имеет формат UCL.
Для получения дополнительной информации о синтаксисе man:libucl[3], пожалуйста, посетите link:https://github.com/vstakhov/libucl[официальный веб-сайт UCL].

Распознаются следующие типы параметров - логические, строчные и списки.

Логический параметр считается активированным, если в конфигурационном файле указано одно из следующих значений - YES, TRUE или ON.

[[pkg-search]]
=== Поиск пакетов

Для поиска какого-либо пакета может быть использована команда man:pkg-search[8].

[source,shell]
....
# pkg search nginx
....

Выдаваемый результат должен быть похож на следующее:

[.programlisting]
....
modsecurity3-nginx-1.0.3       Instruction detection and prevention engine / nginx Wrapper
nginx-1.22.1_2,3               Robust and small WWW server
nginx-devel-1.23.2_4           Robust and small WWW server
nginx-full-1.22.1_1,3          Robust and small WWW server (full package)
nginx-lite-1.22.1,3            Robust and small WWW server (lite package)
nginx-naxsi-1.22.1,3           Robust and small WWW server (plus NAXSI)
nginx-prometheus-exporter-0.10.0_7 Prometheus exporter for NGINX and NGINX Plus stats
nginx-ultimate-bad-bot-blocker-4.2020.03.2005_1 Nginx bad bot and other things blocker
nginx-vts-exporter-0.10.7_7    Server that scraps NGINX vts stats and export them via HTTP
p5-Nginx-ReadBody-0.07_1       Nginx embeded perl module to read and evaluate a request body
p5-Nginx-Simple-0.07_1         Perl 5 module for easy to use interface for Nginx Perl Module
p5-Test-Nginx-0.30             Testing modules for Nginx C module development
py39-certbot-nginx-2.0.0       NGINX plugin for Certbot
rubygem-passenger-nginx-6.0.15 Modules for running Ruby on Rails and Rack applications
....

[[pkg-installing-fetching]]
=== Установка и скачивание пакетов

Для установки бинарного пакета может быть использована команда man:pkg-install[8].

Эта команда использует данные хранилища для определения версии устанавливаемого программного обеспечения и выявления каких-либо неустановленных зависимостей.
Например, для установки curl выполните:

[source,shell]
....
# pkg install curl
....

Выдаваемый результат должен быть похож на следующее:

[.programlisting]
....
Updating FreeBSD repository catalogue...
FreeBSD repository is up to date.
All repositories are up to date.
The following 9 package(s) will be affected (of 0 checked):

New packages to be INSTALLED:
        ca_root_nss: 3.83
        curl: 7.86.0
        gettext-runtime: 0.21
        indexinfo: 0.3.1
        libidn2: 2.3.3
        libnghttp2: 1.48.0
        libpsl: 0.21.1_4
        libssh2: 1.10.0.3
        libunistring: 1.0

Number of packages to be installed: 9

The process will require 11 MiB more space.
3 MiB to be downloaded

Proceed with this action? [y/N]
....

Новый пакет и любые дополнительные пакеты, которые были установлены как зависимости, можно увидеть в списке установленных пакетов:

[source,shell]
....
# pkg info
....

Выдаваемый результат должен быть похож на следующее:

[.programlisting]
....
ca_root_nss-3.83               Root certificate bundle from the Mozilla Project
curl-7.86.0                    Command line tool and library for transferring data with URLs
gettext-runtime-0.21.1         GNU gettext runtime libraries and programs
indexinfo-0.3.1                Utility to regenerate the GNU info page index
libidn2-2.3.3                  Implementation of IDNA2008 internationalized domain names
libnghttp2-1.48.0              HTTP/2.0 C Library
libpsl-0.21.1_6                C library to handle the Public Suffix List
libssh2-1.10.0.3               Library implementing the SSH2 protocol
libunistring-1.0               Unicode string library
pkg-1.18.4                     Package manager
....

Для того, чтобы скачать какой-либо пакет и установить его позже или в другое место, используйте команду man:pkg-fetch[8].
К примеру, для сгрузки `nginx-lite`:

[source,shell]
....
# pkg fetch -d -o /usr/home/user/packages/ nginx-lite
....

* `-d`: используется для сгрузки всех зависимостей
* `-o`: используется для указания каталога для сгрузки

Выдаваемый результат должен быть похож на следующее:

[.programlisting]
....
Updating FreeBSD repository catalogue...
FreeBSD repository is up to date.
All repositories are up to date.
The following packages will be fetched:

New packages to be FETCHED:
        nginx-lite: 1.22.1,3 (342 KiB: 22.20% of the 2 MiB to download)
        pcre: 8.45_3 (1 MiB: 77.80% of the 2 MiB to download)

Number of packages to be fetched: 2

The process will require 2 MiB more space.
2 MiB to be downloaded.

Proceed with fetching packages? [y/N]:
....

Для установки сгруженных пакетов может быть следующим образом использована команда man:pkg-install[8]:

[source,shell]
....
# cd /usr/home/user/packages/
....

[source,shell]
....
# pkg install nginx-lite-1.22.1,3.pkg
....

[[pkgng-pkg-info]]
=== Получение информации об установленных пакетах

Информация об установленных в системе пакетах может быть просмотрена при помощи запуска команды man:pkg-info[8], которая при запуске без указания каких-либо параметров отобразит версию пакета либо для всех установленных пакетов, либо для указанного.

Например, для просмотра установленной версии pkg выполните:

[source,shell]
....
# pkg info pkg
....

Выдаваемый результат должен быть похож на следующее:

[.programlisting]
....
pkg-1.19.0
Name           : pkg
Version        : 1.19.0
Installed on   : Sat Dec 17 11:05:28 2022 CET
Origin         : ports-mgmt/pkg
Architecture   : FreeBSD:13:amd64
Prefix         : /usr/local
Categories     : ports-mgmt
Licenses       : BSD2CLAUSE
Maintainer     : pkg@FreeBSD.org
WWW            : https://github.com/freebsd/pkg
Comment        : Package manager
Options        :
        DOCS           : on
Shared Libs provided:
        libpkg.so.4
Annotations    :
        FreeBSD_version: 1301000
        repo_type      : binary
        repository     : FreeBSD
Flat size      : 33.2MiB
Description    :
Package management tool

WWW: https://github.com/freebsd/pkg
....

[[pkgng-upgrading]]
==== Обновление установленных пакетов

Установленные пакеты могут быть модернизированы до их самых последних версий при помощи man:pkg-upgrade[8]:

[source,shell]
....
# pkg upgrade
....

Эта команда сравнит установленные версии с теми, что доступны в каталоге хранилища и выполнит их обновление из хранилища.

[[pkgng-auditing]]
=== Аудит установленных пакетов

В приложениях сторонних разработчиков регулярно обнаруживаются программные уязвимости.
Для решения этой проблемы в pkg встроен механизм аудита.
Для выявления наличия каких бы то ни было известных уязвимостей в программном обеспечении, установленном в системе, используйте man:pkg-audit[8]:

[source,shell]
....
# pkg audit -F
....

Выдаваемый результат должен быть похож на следующее:

[.programlisting]
....
Fetching vuln.xml.xz: 100%  976 KiB 499.5kB/s    00:02
chromium-108.0.5359.98 is vulnerable:
  chromium -- multiple vulnerabilities
  CVE: CVE-2022-4440
  CVE: CVE-2022-4439
  CVE: CVE-2022-4438
  CVE: CVE-2022-4437
  CVE: CVE-2022-4436
  WWW: https://vuxml.FreeBSD.org/freebsd/83eb9374-7b97-11ed-be8f-3065ec8fd3ec.html
....

[[pkg-delete]]
=== Удаление пакетов

Пакеты, которые более не нужны, могут быть удалены командой man:pkg-delete[8].

К примеру:

[source,shell]
....
# pkg delete curl
....

Выдаваемый результат должен быть похож на следующее:

[.programlisting]
....
Checking integrity... done (0 conflicting)
Deinstallation has been requested for the following 1 packages (of 0 packages in the universe):

Installed packages to be REMOVED:
        curl :7.86.0

Number of packages to be removed: 1

The operation will free 4 MiB.

Proceed with deinstallation packages? [y/N]: y
[1/1] Deinstalling curl-7.86.0...
[1/1] Deleting files for curl-7.86.0: 100%
....

[[pkgng-autoremove]]
=== Автоматическое удаление неиспользуемых пакетов

После удаления пакета в системе могут оставаться зависимости, которые больше не востребованы.
Ненужные пакеты, которые были установлены как зависимости (пакеты-листья), могут быть выявлены и удалены в автоматическом режиме при помощи man:pkg-autoremove[8]:

[source,shell]
....
# pkg autoremove
....

Выдаваемый результат должен быть похож на следующее:

[.programlisting]
....
Checking integrity... done (0 conflicting)
Deinstallation has been requested for the following 1 packages:

Installed packages to be REMOVED:
        ca_root_nss-3.83

Number of packages to be removed: 1

The operation will free 723 KiB.

Proceed with deinstalling packages? [y/N]:
....

Пакеты, установленные как зависимости, называются _автоматическими_ пакетами.
Список неавтоматических пакетов, то есть пакетов, которые были установлены исключительно не как зависимости другого пакета, можно получить при помощи:

[source,shell]
....
# pkg prime-list
....

Выдаваемый результат должен быть похож на следующее:

[.programlisting]
....
nginx
openvpn
sudo
....

Команда `pkg prime-list` является командой-алиасом, определённой в `/usr/local/etc/pkg.conf`.
Есть и много других команд, которые могут быть использованы для исполнения запросов в базу данных пакетов системы.
К примеру, команда `pkg prime-origins` может быть использована для получения каталога размещения портов из списка, упомянутого выше:

[source,shell]
....
# pkg prime-origins
....

Выдаваемый результат должен быть похож на следующее:

[.programlisting]
....
www/nginx
security/openvpn
security/sudo
....

Этот список можно использовать для перестроения всех пакетов, установленных в системе, воспользовавшись такими средствами построения, как package:ports-mgmt/poudriere[] или package:ports-mgmt/synth[].

Пометить установленный пакет автоматическим можно при помощи:

[source,shell]
....
# pkg set -A 1 devel/cmake
....

Если какой-нибудь пакет, являющийся пакетом-листом, также помечен как автоматический, то он попадает в выборку команды `pkg autoremove`.

Пометить установленный пакет _не_автоматическим можно при помощи:

[source,shell]
....
# pkg set -A 0 devel/cmake
....

[[pkgng-backup]]
=== Восстановление базы данных пакетов

В отличие от традиционной системы управления пакетами, pkg располагает своим собственным механизмом резервного копирования базы данных.
Эта функциональность включена по умолчанию.

[TIP]
====
Для отключения резервного копирования базы данных пакетов регулярным скриптом укажите `daily_backup_pkgdb_enable="NO"` в файле man:periodic.conf[5].
====

Для восстановления содержимого базы данных установленных пакетов из резервной копии, выполните следующую команду, заменив _/path/to/pkg.sql_ местонахождением резервной копии:

[source,shell]
....
# pkg backup -r _/path/to/pkg.sql_
....

[NOTE]
====
Если восстанавливается резервная копия, созданная периодическим скриптом, то до восстановления она должна быть распакована.
====

Для запуска резервного копирования базы данных pkg в неавтоматизированном режиме запустите следующую команду, заменив _/path/to/pkg.sql_ именем и местоположением соответствующего файла:

[source,shell]
....
# pkg backup -d _/path/to/pkg.sql_
....

[[pkgng-clean]]
=== Удаление устаревших пакетов

По умолчанию pkg сохраняет копии установленных бинарных пакетов в кэширующем каталоге, заданном переменной `PKG_CACHEDIR` в man:pkg.conf[5].
Хранятся копии только последних установленных пакетов.
Более старые версии pkg хранили все предыдущие пакеты.
Для удаления этих устаревших бинарных пакетов выполните:

[source,shell]
....
# pkg clean
....

Полностью кэш может быть очищен при запуске:

[source,shell]
....
# pkg clean -a
....

[[pkg-locking-unlocking]]
=== Блокировка и разблокировка пакетов

Для блокировки пакетов от повторной установки, модификации или удаления используется команда man:pkg-lock[8].
Команда man:pkg-unlock[8] выполняет разблокировку перечисленных пакетов.
Действие любой из команд распространяется только на установленные в данный момент пакеты.
Соответственно, используя данный механизм, невозможно ограничить установку нового пакета, если только такая установка не подразумевает обновление заблокированного пакета.

К примеру, для блокировки `nginx-lite`:

[source,shell]
....
# pkg lock nginx-lite
....

А для разблокировки `nginx-lite`:

[source,shell]
....
# pkg unlock nginx-lite
....

[[pkgng-set]]
=== Изменение метаданных пакета

В программном обеспечении из Коллекции Портов FreeBSD может изменяться старший номер версии.
Для решения этой задачи в pkg имеется встроенная команда для обновления информации о местоположении пакета.
Это может оказаться полезным, к примеру, когда package:lang/python3[] переименовывается в package:lang/python311[], так что package:lang/python3[] теперь может соответствовать версии `3.1.1`.

В вышеприведённом случае для изменения местоположения пакета выполните:

[source,shell]
....
# pkg set -o lang/python3:lang/python311
....

Ещё один пример: для изменения информации о местоположении пакета с package:lang/ruby31[] на package:lang/ruby32[], выполните:

[source,shell]
....
# pkg set -o lang/ruby31:lang/ruby32
....

[NOTE]
====
Выполняя замену информации о местоположении пакетов, важно переустановить пакеты, которые зависят от пакета с изменившимся местоположением.
Для принудительной переустановки зависимых пакетов, выполните:

[source,shell]
....
# pkg install -Rf lang/ruby32
....
====

[[ports-using]]
== Использование Коллекции Портов

Коллекция Портов является набором файлов `Makefile`, патчей и файлов описаний.
Каждый набор таких файлов используется для компиляции и установки отдельного приложения во FreeBSD и называется _портом_.

По умолчанию сама Коллекция Портов хранится как подкаталог `/usr/ports`.

[WARNING]
====
Перед установкой и использованием Коллекции Портов, пожалуйста, примите во внимание, что использование Коллекции Портов для установки программного обеспечения совместно с бинарными пакетами, доступными при помощи pkg, является не самым хорошим решением.
По умолчанию pkg отслеживает ветку квартальных релизов дерева портов, но не ветку HEAD.
Для порта, находящегося в ветке HEAD, и соответствующего порта, находящегося в квартальном релизе этой ветки, зависимости могут отличаться, а это может привести к конфликтам между зависимостями, установленными при помощи pkg, и полученными из Коллекции Портов.
Если Коллекция Портов и pkg в обязательном порядке должны использоваться совместно, то удостоверьтесь, что ваша Коллекция Портов и pkg работают с одним и тем же релизом ветки дерева портов.
====

Коллекция Портов содержит каталоги, соответствующие категориям программного обеспечения.
В каждой категории присутствуют подкаталоги для отдельных приложений.
Каждый подкаталог приложения, называемый _скелетом порта_, содержит набор файлов, указывающих FreeBSD, как скомпилировать и установить данную программу.

В скелет любого порта включены следующие файлы и каталоги:

* *Makefile*: содержит директивы, которые определяют, как приложение должно быть откомпилировано и куда должно быть установлены его компоненты.
* *distinfo*: содержит имена и контрольные суммы файлов, которые должны быть сгружены для сборки порта.
* *files*: этот каталог содержит все патчи, необходимые для компиляции и установки программы во FreeBSD. Этот каталог может также содержать другие файлы, используемые для построения порта.
* *pkg-descr*: предоставляет более подробное описание программы.
* *pkg-plist*: список всех файлов, которые будут установлены портом. Он также указывает системе портов на то, какие файлы подлежат удалению при удаления порта.

В некоторых портах присутствует файл `pkg-message` или другие файлы для обработки особых ситуаций.
Для получении дополнительной информации об этих файлах и о портах в целом обратитесь к extref:{porters-handbook}[Руководству по созданию портов FreeBSD].

Порт не содержит собственно исходного кода, или так называемого `distfile`.
Этап распаковки в процессе построения порта будет автоматически сохранять сгруженный исходный код в `/usr/ports/distfiles`.

[[ports-using-installation-methods]]
=== Установка Коллекции Портов

Перед тем, как какое-либо приложение сможет быть скомпилировано при помощи порта, в обязательном порядке должна быть установлена Коллекция Портов.
Если она не была установлена в ходе установки FreeBSD, воспользуйтесь для этого одним из следующих методов:

[[ports-using-git-method]]
[.procedure]
****
*Procedure: Метод Git*

Если необходим дополнительный контроль за деревом портов или имеется необходимость в организации работы с локальными изменениями, либо используется FreeBSD-CURRENT, то для получения Коллекции Портов может быть задействован Git.
Обратитесь к extref:{committers-guide}[Учебнику Git, git-primer] за детальным описанием Git.

. Для создания рабочей копии дерева портов необходимо иметь установленный Git. Если дерево портов уже есть в наличии, то установите Git примерно следующим образом:
+
[source,shell]
....
# cd /usr/ports/devel/git
# make install clean
....
+
Если дерево портов недоступно или для управления пакетами используется pkg, то Git может быть установлен как пакет:
+
[source,shell]
....
# pkg install git
....
+
. Извлеките копию ветки HEAD дерева портов:
+
[source,shell]
....
# git clone https://git.FreeBSD.org/ports.git /usr/ports
....
+
. Либо извлеките копию квартальной ветки:
+
[source,shell]
....
# git clone https://git.FreeBSD.org/ports.git -b 2020Q3 /usr/ports
....
+
. После первичного извлечения хранилища Git и по мере необходимости обновляйте `/usr/ports`:
+
[source,shell]
....
# git -C /usr/ports pull
....
+
. По мере необходимости переключайте `/usr/ports` на другую квартальную ветку:
+
[source,shell]
....
# git -C /usr/ports switch 2020Q4
....
****

=== Установка портов

Этот раздел содержит базовые указания по использования Коллекции Портов для установки и удаления программного обеспечения.
Подробное описание доступных целей и переменных окружения для `make` доступно в man:ports[7].

[WARNING]
====
Перед компиляцией любого порта не забудьте обновить Коллекцию Портов, как это описано в предыдущем разделе.
Так как установка любого программного обеспечения сторонних разработчиков может привести к появлению уязвимостей в безопасности, рекомендуется сначала свериться с https://vuxml.freebsd.org/[] на предмет известных проблем с безопасностью, связанных с данным портом.
Альтернативным методом является запуск `pkg audit -F` перед установкой нового порта.
Эта команда может быть настроена на автоматическое выполнение аудита безопасности обновление базы данных уязвимостей во время ежедневной системной проверки безопасности.
За дополнительной информацией обратитесь к man:pkg-audit[8] и man:periodic[8].
====

Использование Коллекции Портов предполагает наличие работающего подключения к Интернет.
Также оно требует полномочий суперпользователя.

Для компиляции и установки порта перейдите в каталог порта, который будет устанавливаться, а затем наберите `make install` в приглашении командной строки.
Ход процесса будет отображаться в сообщениях:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
# make install
>> lsof_4.88D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
>> Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===>  Extracting for lsof-4.88
...
[вывод этапа распаковки опущен]
...
>> Checksum OK for lsof_4.88D.freebsd.tar.gz.
===>  Patching for lsof-4.88.d,8
===>  Applying FreeBSD patches for lsof-4.88.d,8
===>  Configuring for lsof-4.88.d,8
...
[вывод этапа настройки опущен]
...
===>  Building for lsof-4.88.d,8
...
[вывод этапа компиляции опущен]
...
===>  Installing for lsof-4.88.d,8
...
[вывод этапа установки опущен]
...
===>   Generating temporary packing list
===>   Compressing manual pages for lsof-4.88.d,8
===>   Registering installation for lsof-4.88.d,8
===>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
#
....

Так как `lsof` является программой, которая запускается с повышенными привилегиями, при установке выдаётся предупреждение о безопасности.
После завершения установки произойдёт возврат к приглашению командной строки.

Некоторые командные процессоры поддерживают кэш команд, доступных в каталогах, перечисленных в переменной окружения `PATH`, для ускорения поиска исполнимых файлов для этих команд.
Пользователи оболочки командной строки `tcsh` должны набрать `rehash`, чтобы новая установленная команда могла быть использована без указания её полного пути.
Используйте `hash -r` вместо указанной команды для оболочки `sh`.
Обратитесь к документации о конкретном командном процессоре для получения дополнительной информации.

Во время установки создаётся рабочий подкаталог, содержащий все временные файлы, используемые во время компиляции.
Удаление этого каталога экономит дисковое пространство и минимизирует вероятность возникновения проблем в дальнейшем при обновлении до более новой версии порта:

[source,shell]
....
# make clean
===>  Cleaning for lsof-88.d,8
#
....

[NOTE]
====
Для экономии времени на запуск этого дополнительного шага используйте команду `make install clean` при компиляции порта.
====

==== Настройка установки портов

Некоторые порты имеют параметры построения, которые могут быть использованы для включения или отключения компонентов приложения, указания параметров безопасности или выполнять другие тонкие настройки.
Примерами могут служить package:www/firefox[] и package:security/gpgme[].
Если порт зависит от других портов, в которых имеются настраиваемые параметры, процесс может останавливаться несколько раз для взаимодействия с пользователем, так как по умолчанию выполняется запрос пользователю для выбора параметров из меню.
Во избежание этого и для выполнения всего конфигурирования за один прогон, запустите команду `make config-recursive` в каталоге порта.
Затем выполните `make install [clean]` для компиляции и установки этого порта.

[TIP]
====
Когда используется `config-recursive`, перечень подлежащих настройке портов собирается целью `all-depends-list`.
Рекомендуется повторять запуск `make config-recursive` до тех пор, пока не будут определены все параметры зависимых портов и больше не выдаются экраны с параметрами портов, что даёт уверенность в том, что все параметры зависимостей были настроены.
====

Имеется несколько способов пересмотра набора параметров построения того или иного порта для того, чтобы добавить, удалить или изменить их после того, как порт был построен.
Одним из методов является переход по команде `cd` в каталог, содержащий порт и вызов команды `make config`.
Другим вариантом является использование команды `make showconfig`.
Ещё одним вараинтом является выполнение команды `make rmconfig`, которая удалит все выбранные параметры и позволит вам начать сначала.
Все эти и другие варианты очень подробно описаны в man:ports[7].

Для загрузки файлов с исходным кодом система портов использует утилиту man:fetch[1], которая поддерживает различные переменные окружения.
Если система FreeBSD находится за межсетевым экраном или прокси-сервером FTP/HTTP, то может потребоваться настройка значений переменных `FTP_PASSIVE_MODE`, `FTP_PROXY` и `FTP_PASSWORD`.
Обратитесь к справочной странице по man:fetch[3] для получения полного списка поддерживаемых переменных.

Пользователи, которые не имеют возможности быть постоянно подключенными к Интернет, могут выполнить команду `make fetch` в каталоге `/usr/ports` для сгрузки всех дистрибутивных файлов, или в каталоге категории, подобном `/usr/ports/net`, или в каталоге конкретного порта.
Заметьте, что если порт имеет какие бы то ни было зависимости, то запуск этой команды в какой-либо категории или каталоге порта _не будет_ приводить к сгрузке дистрибутивных файлов портов из другой категории.
Вместо этого воспользуйтесь командой `make fetch-recursive` для того, чтобы сгрузить также дистрибутивные файлы всех зависимостей порта.

В редких случаях, например, когда в какой-либо организации имеется локальный репозиторий дистрибутивных файлов, можно использовать переменную `MASTER_SITES` для переопределения местоположений для сгрузки, указанных в `Makefile`.
При её использовании укажите альтернативное размещение:

[source,shell]
....
# cd /usr/ports/_directory_
# make MASTER_SITE_OVERRIDE= \
_ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/_ fetch
....

При помощи переменных `WRKDIRPREFIX` и `PREFIX` можно переопределить назначаемые по умолчанию рабочий и целевой каталоги.
Например:

[source,shell]
....
# make WRKDIRPREFIX=/usr/home/example/ports install
....

будет компилировать порт в каталоге `/usr/home/example/ports`, а установит всё в `/usr/local`.

[source,shell]
....
# make PREFIX=/usr/home/example/local install
....

будет компилировать порт в каталоге `/usr/ports`, а установит его в `/usr/home/example/local`.
А также:

[source,shell]
....
# make WRKDIRPREFIX=../ports PREFIX=../local install
....

будет комбинировать оба варианта.

Это может быть также определено в виде переменных окружения.
Обратитесь к страницам справки по вашему командному процессору для получения инструкций о том, как установить переменные окружения.

[[ports-removing]]
=== Удаление установленных портов

Установленные порты могут быть удалены при помощи команды `pkg delete`.
Примеры использования этой команды можно найти на странице Справочника по man:pkg-delete[8].

Альтернативным способом может быть запуск команды `make deinstall` в каталоге порта:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
# make deinstall
===>  Deinstalling for sysutils/lsof
===>   Deinstalling
Deinstallation has been requested for the following 1 packages:

       lsof-4.88.d,8
The deinstallation will free 229 kB
[1/1] Deleting lsof-4.88.d,8... done
....

Рекомендуется прочесть сообщения, выдаваемые в процессу удаления порта.
Если у порта имеются какие-либо приложения, зависящие от него, то эта информация будет отражена, но процесс удаления будет продолжен.
В таких случаях хорошим действием может быть повторная установка данного приложения для того, чтобы избежать появления неработающих зависимостей.

[[ports-upgrading]]
=== Обновление портов

С течением времени в Коллекции Портов становятся доступными обновлённые версии программного обеспечения.
Этот раздел описывает, как определить, какое программное обеспечение может быть обновлено и как такое обновление произвести.

Для того, чтобы выяснить доступность более новых версий установленных портов, при помощи команды обновления, описанной в разделе <<ports-using-git-method, "Метод Git">>, удостоверьтесь, что установлена самая последняя версия дерева портов.
Следующая команда выдаст список портов, которые являются устаревшими:

[source,shell]
....
# pkg version -l "<"
....

[IMPORTANT]
====
Перед тем, как пытаться выполнить обновление, прочтите файл `/usr/ports/UPDATING`, начиная сверху и до даты, наиболее близкой к моменту последнего обновления портов или установки системы.
В этом файле дана информация по различным вопросам и дополнительным шагам, которые могут быть необходимы для обновления порта, включая информацию о таких вещах как изменения форматов файлов, изменения в расположении конфигурационных файлов, или любые другие несовместимости с предыдущими версиями.
Обратите внимание на любые указания, которые имеют отношения к каким бы то ни было портам, требующим обновления, и следуйте этим инструкциям в процессе обновления.
====

[[ports-upgrading-tools]]
==== Средства модернизации и управления портами

Коллекция Портов содержит несколько утилит для непосредственного выполнения модернизации.
У каждой из них имеются свои достоинства и недостатки.

Исторически в большинстве инсталляций использовался либо Portmaster, либо Portupgrade.
Synth является более новой альтернативой.

[NOTE]
====
Выбор инструмента, наилучшим образом соответствующего конкретной системе, остаётся за её системным администратором.
Рекомендуемой практикой является создание резервной копии ваших данных до использования любого этих инструментов.
====

[[portmaster]]
==== Обновление портов при помощи Portmaster

package:ports-mgmt/portmaster[] является очень небольшой утилитой для обновления установленных портов.
Он спроектирован с учётом использования инструментов, устанавливаемых с базовым комплектом FreeBSD, без зависимостей от других портов или баз данных.
Для установки этой утилиты в качестве порта:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portmaster
# make install clean
....

Portmaster определяет четыре категории портов:

* Корневой порт: не зависит от других портов и не существует никаких портов, от него зависящих.
* Стволовой порт: не имеет зависимостей, но другие порты зависят от него.
* Веточный порт: имеет зависимости и другие порты зависят от него.
* Листьевый порт: имеет зависимости, но нет портов, зависящих от него.

Для выдачи списка этих категорий и поиска обновлений:

[source,shell]
....
# portmaster -L
===>>> Root ports (No dependencies, not depended on)
===>>> ispell-3.2.06_18
===>>> screen-4.0.3
        ===>>> New version available: screen-4.0.3_1
===>>> tcpflow-0.21_1
===>>> 7 root ports
...
===>>> Branch ports (Have dependencies, are depended on)
===>>> apache22-2.2.3
        ===>>> New version available: apache22-2.2.8
...
===>>> Leaf ports (Have dependencies, not depended on)
===>>> automake-1.9.6_2
===>>> bash-3.1.17
        ===>>> New version available: bash-3.2.33
...
===>>> 32 leaf ports

===>>> 137 total installed ports
        ===>>> 83 have new versions available
....

Эта команда используется для обновления всех устаревших портов:

[source,shell]
....
# portmaster -a
....

[NOTE]
====
По умолчанию Portmaster создаёт резервную копию пакета перед удалением установленного порта.
Если обновление порта прошло успешно, Portmaster удаляет резервную копию пакета.
При помощи опции `-b` можно указать Portmaster не выполнять автоматическое удаление резервной копии пакета.
Указание опции `-i` запускает Portmaster в интерактивном режиме, запрашивающем подтверждение пользователя перед обновлением каждого порта.
Имеется много других параметров.
Прочтите страницу Справочника о man:portmaster[8] для уточнения деталей относительно их использования.
====

Если в процессе обновления возникают ошибки, добавьте параметр `-f` для обновления и перестроения всех портов:

[source,shell]
....
# portmaster -af
....

Portmaster может быть также задействован для установки новых портов в систему, автоматически обновляя другие зависимые порты перед построением и установкой нового порта.
Для использования этой функции укажите место размещения порта в Коллекции Портов:

[source,shell]
....
# portmaster shells/bash
....

Дополнительную информацию о package:ports-mgmt/portmaster[] можно найти в соответствующем файле `pkg-descr` порта.

[[portupgrade]]
==== Обновление портов при помощи Portupgrade

package:ports-mgmt/portupgrade[] является ещё одной утилитой, которая может использоваться для модернизации портов.
Она устанавливает набор приложений, которые могут применяться для управления портами.
Однако она зависит от Ruby.
Для установки этого порта:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portupgrade
# make install clean
....

Перед тем, как выполнять обновление с использованием этой утилиты, рекомендуется проверить список установленных портов командой `pkgdb -F` и устранить все несоответствия, о которых будет сообщено.

Для обновления всех устаревших портов, установленных в системе, используйте `portupgrade -a`.
Дополнительно можно добавить параметр `-i`, чтобы получать запрос на подтверждение каждого отдельного обновления:

[source,shell]
....
# portupgrade -ai
....

Для обновления только конкретного приложения, а не всех доступных портов, воспользуйтесь командой `portupgrade _pkgname_`.
Очень важно указать параметр `-R`, чтобы сначала обновить все порты, требуемые этому конкретному приложению:

[source,shell]
....
# portupgrade -R firefox
....

Если указан параметр `-P`, то Portupgrade осуществляет поиск доступных пакетов в локальных каталогах, перечисленных в переменной окружения `PKG_PATH`.
Если они недоступны, то утилита сгрузит пакеты с удалённого сайта.
Если пакеты не могут быть найдены локально или сгружены удаленно, Portupgrade будет использовать порты.
Чтобы полностью запретить использование портов, укажите `-PP`.
Этот набор параметров указывает Portupgrade на прекращение работы при отсутствии доступных пакетов:

[source,shell]
....
# portupgrade -PP gnome3
....

Для того, чтобы сгрузить только дистрибутивные файлы порта или пакеты при наличии параметра `-P`, без построения или установки чего бы то ни было, используете параметр `-F`.
Для получения дополнительной информации обо всех доступных параметрах обратитесь к странице Справочника по утилите `portupgrade`.

Дополнительную информацию о package:ports-mgmt/portupgrade[] можно найти в соответствующем файле `pkg-descr` порта.

[[ports-disk-space]]
=== Порты и дисковое пространство

Использование Коллекции Портов со временем приводит к расходованию дискового пространства.
После построения и установки какого-либо порта запуск команды `make clean` в каталоге этого порта удалит временный каталог `work`.
Если для установки порта используется Portmaster, то он автоматически удаляет этот каталог, если только не указан параметр `-K`.
Если установлена утилита Portupgrade, то вот эта команда удалит все каталоги `work`, находящиеся в локальной копии Коллекции Портов:

[source,shell]
....
# portsclean -C
....

Кроме того, со временем в каталоге `/usr/ports/distfiles` скапливаются устаревшие исходные дистрибутивные файлы.
Чтобы использовать Portupgrade для удаления всех дистрибутивных файлов, которые более не связаны с каким бы то ни было портом:

[source,shell]
....
# portsclean -D
....

Portupgrade может удалить все дистрибутивные файлы, не связанных ни с одним из портов, установленных в данный момент в системе:

[source,shell]
....
# portsclean -DD
....

Если установлена утилита Portmaster, то используйте:

[source,shell]
....
# portmaster --clean-distfiles
....

По умолчанию эта команда является интерактивной и выдаёт пользователю запросы на подтверждение удаления того или иного дистрибутивного файла.

Дополнительно к этим командам package:ports-mgmt/pkg_cutleaves[] автоматизирует задачу по удалению установленных портов, которые более не нужны.

[[ports-poudriere]]
== Построение пакетов с Poudriere

Poudriere является утилитой с лицензированием BSD для создания и тестирования пакетов FreeBSD.
Она применяет изоляторы FreeBSD для формирования изолированных сред компиляции.
Эти изоляторы могут использоваться для построения пакетов для версий FreeBSD, отличающихся от компьютера, на который она установлена, а также строить пакеты для i386, если хостом является система amd64.
После построения пакетов они находятся в структуре, идентичной официальным зеркалам.
Эти пакеты могут использоваться man:pkg[8] и другими инструментами управления пакетами.

Poudriere устанавливается при помощи пакета или порта package:ports-mgmt/poudriere[].
Установочный комплект содержит пример конфигурационного файла `/usr/local/etc/poudriere.conf.sample`.
Скопируйте этот файл в `/usr/local/etc/poudriere.conf`.
Отредактируйте эту копию для того, чтобы она соответствовала локальной конфигурации.

Хотя применение ZFS для системы, на которой работает poudriere, не является обязательным, это даёт определённые преимущества.
При использовании ZFS в `/usr/local/etc/poudriere.conf` обязательно должно быть задано значение `ZPOOL`, а переменная `FREEBSD_HOST` должна указывать на ближайшее зеркало.
Задание значения `CCACHE_DIR` позволяет использовать package:devel/ccache[] для кэширования компиляции и сокращения времени построения для часто компилируемого кода.
Может быть удобным размещение наборов данных poudriere в изолированном дереве, смонтированном в каталог `/poudriere`.
Значения, применяемые по умолчанию для других конфигурационных параметров, являются адекватными.

Для определения того, сколько процессов построения будет запущено параллельно, используется количество обнаруженных процессорных ядер.
Выделите достаточное количество виртуальной памяти, как в ОЗУ, так и в пространстве подкачки.
Если виртуальная память будет исчерпана, то изоляторы с компиляциями будут остановлены и уничтожены, что приведёт к странным сообщениям об ошибках.

[[poudriere-initialization]]
=== Инициализация изоляторов и деревьев портов

После настройки выполните инициализацию poudriere, чтобы была выполнена установка изолятора с требуемым деревом FreeBSD и деревом портов.
Задайте имя для изолятора при помощи параметра `-j` и версию FreeBSD параметром `-v`.
На системах, работающих под управлением FreeBSD/amd64, архитектура может быть задана параметром `-a` в значение `i386` или `amd64`.
Архитектурой, используемой по умолчанию, является та, что отражается командой `uname`.

[source,shell]
....
# poudriere jail -c -j 13amd64 -v 13.1-RELEASE
[00:00:00] Creating 13amd64 fs at /poudriere/jails/13amd64... done
[00:00:00] Using pre-distributed MANIFEST for FreeBSD 13.1-RELEASE amd64
[00:00:00] Fetching base for FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/base.txz              125 MB 4110 kBps    31s
[00:00:33] Extracting base... done
[00:00:54] Fetching src for FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/src.txz               154 MB 4178 kBps    38s
[00:01:33] Extracting src... done
[00:02:31] Fetching lib32 for FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/lib32.txz              24 MB 3969 kBps    06s
[00:02:38] Extracting lib32... done
[00:02:42] Cleaning up... done
[00:02:42] Recording filesystem state for clean... done
[00:02:42] Upgrading using ftp
/etc/resolv.conf -> /poudriere/jails/13amd64/etc/resolv.conf
Looking up update.FreeBSD.org mirrors... 3 mirrors found.
Fetching public key from update4.freebsd.org... done.
Fetching metadata signature for 13.1-RELEASE from update4.freebsd.org... done.
Fetching metadata index... done.
Fetching 2 metadata files... done.
Inspecting system... done.
Preparing to download files... done.
Fetching 124 patches.....10....20....30....40....50....60....70....80....90....100....110....120.. done.
Applying patches... done.
Fetching 6 files... done.
The following files will be added as part of updating to
13.1-RELEASE-p1:
/usr/src/contrib/unbound/.github
/usr/src/contrib/unbound/.github/FUNDING.yml
/usr/src/contrib/unbound/contrib/drop2rpz
/usr/src/contrib/unbound/contrib/unbound_portable.service.in
/usr/src/contrib/unbound/services/rpz.c
/usr/src/contrib/unbound/services/rpz.h
/usr/src/lib/libc/tests/gen/spawnp_enoexec.sh
The following files will be updated as part of updating to
13.1-RELEASE-p1:
[...]
Installing updates...Scanning //usr/share/certs/blacklisted for certificates...
Scanning //usr/share/certs/trusted for certificates...
 done.
13.1-RELEASE-p1
[00:04:06] Recording filesystem state for clean... done
[00:04:07] Jail 13amd64 13.1-RELEASE-p1 amd64 is ready to be used
....

[source,shell]
....
# poudriere ports -c -p _local_ -m git+https
[00:00:00] Creating local fs at /poudriere/ports/local... done
[00:00:00] Checking out the ports tree... done
....

На одном компьютере poudriere может компилировать порты с множеством конфигураций в нескольких изоляторах и из разных деревьев портов.
Специальные конфигурации для таких комбинаций называются _наборами_.
Обратитесь к разделу CUSTOMIZATION в man:poudriere[8] для уточнения деталей после установки package:ports-mgmt/poudriere[] или package:ports-mgmt/poudriere-devel[].

В базовой конфигурации, показанной здесь, файл `make.conf`, специфичный для одного изолятора, порта и набора, размещается в каталоге `/usr/local/etc/poudriere.d`.
Имя файла в этом примере создано объединением имени изолятора, имени порта и имени набора: `13amd64-local-workstation-make.conf`.
Системный файл `make.conf` и этот новый файл комбинируются во время построения для создания файла `make.conf`, используемого компилирующим изолятором.

Пакеты для построения задаются в файле `13amd64-local-workstation-pkglist`:

[.programlisting]
....
editors/emacs
devel/git
ports-mgmt/pkg
...
....

Настраиваются параметры и зависимости для указанных портов:

[source,shell]
....
# poudriere options -j 13amd64 -p local -z workstation -f 13amd64-local-workstation-pkglist
....

Наконец, выполняется построение пакетов и создаётся соответствующее хранилище:

[source,shell]
....
# poudriere bulk -j 13amd64 -p local -z workstation -f 13amd64-local-workstation-pkglist
....

Если нажать kbd:[Ctrl+t] во время исполнения, то отображается текущее состояние построения.
Poudriere также формирует файлы в каталоге `/poudriere/logs/bulk/jailname`, которые можно использовать с веб-сервером для отображения информации о построении.

После завершения новые пакеты сразу доступны к установке из хранилища poudriere.

Для получения дополнительной информации об использовании poudriere обратитесь к man:poudriere[8] и основному веб-сайту, https://github.com/freebsd/poudriere/wiki[].

=== Настройка клиентов pkg на использование хранилища Poudriere

Несмотря на то, что возможно использовать как отдельное специальное хранилище, так и официальное, иногда бывает полезным отключить официальное хранилище.
Это делается путём создания конфигурационного файла, который переопределяет и отключает официальный конфигурационный файл.
Создайте файл `/usr/local/etc/pkg/repos/FreeBSD.conf`, содержащий следующее:

[.programlisting]
....
FreeBSD: {
	enabled: no
}
....

Как правило, самым лёгким механизмом предоставления хранилища poudriere клиентским машинам является HTTP.
Настройте веб-сервер для обслуживания каталога с пакетами, к примеру: `/usr/local/poudriere/data/packages/13amd64`, где `13amd64` является названием сборки.

Если URL хранилища пакетов имеет вид `http://pkg.example.com/13amd64`, то конфигурационный файл хранилища в `/usr/local/etc/pkg/repos/custom.conf` может выглядеть подобно следующему:

[.programlisting]
....
custom: {
	url: "http://pkg.example.com/13amd64",
	enabled: yes,
}
....

[[ports-nextsteps]]
== Действия после установки

Вне зависимости от того, было ли программное обеспечение установлено из бинарного пакета или порта, большинству приложений сторонних разработчиков после установки требуется определённый уровень настройки.
Нижеследующие команды и места размещения могут помочь в определении того, что было установлено вместе с приложением.

* Большинство приложений устанавливает по крайней мере один конфигурационный файл, используемый по умолчанию, в каталог `/usr/local/etc`. В тех случаях, когда у приложения имеется большое количество конфигурационных файлов, для их размещения будет создаваться подкаталог. Зачастую устанавливаются примеры конфигурационных файлов, которые имеют окончания, подобные `.sample`. Эти конфигурационные файлы должны быть рассмотрены и, возможно, отредактированы для того, чтобы соответствовать требованиям системы. Для редактирования файла с примером сначала скопируйте его, убрав расширение `.sample`.
* Приложения, поставляемые с документацией, будут устанавливать её в каталог `/usr/local/share/doc`, также многие приложения устанавливают страницы Справочника. Перед тем, как продолжить, это документация должна быть изучена.
* Некоторые приложения обслуживают сервисы, которые обязательно должны быть добавлены в `/etc/rc.conf` до запуска приложения. Такие приложения обычно устанавливают скрипт запуска в `/usr/local/etc/rc.d`. Обратитесь к разделу crossref:config[configtuning-starting-services,Запуск сервисов] для получения дополнительной информации.
+
[NOTE]
====
Система спроектирована так, что приложения не выполняют свои скрипты запуска при установке и точно так же не выполняют свои скрипты остановки при удалении или модернизации.
Решение остаётся за конкретным системным администратором.
====
+
* Те, кто использует man:csh[1], должны выполнить команду `rehash` для актуализации двоичного списка в переменной `PATH` оболочки.
* Используйте `pkg info` для определения того, какие файлы, страницы Справочника и бинарные файлы были установлены вместе с приложением.

[[ports-broken]]
== Обработка неработоспособных портов

Если порт не компилируется или не устанавливается:

. Поищите, чтобы выяснить, нет ли для этого порта исправления, ожидающего своей очереди в link:https://www.FreeBSD.org/support/[Базе сообщений о проблемах]. Если это так, то использование предложенного исправления может решить проблему.
. Попросите помощи у мейнтейнера порта. Чтобы найти его адрес, наберите команду `make maintainer` в каталоге порта или просмотрите `Makefile` порта. В письмо поддерживающему не забудьте включить выдачу, предшествующую возникновению ошибки.
+
[NOTE]
====
Некоторые порты поддерживаются не конкретными лицами, а группой, представленной extref:{mailing-list-faq}[списком рассылки].
Многие, но не все, такие адреса выглядят как mailto:freebsd-listname@FreeBSD.org[freebsd-_listname_@FreeBSD.org].
Пожалуйста, учтите это при отправке сообщения электронной почты.

В частности, порты, поддерживаемые mailto:ports@FreeBSD.org[ports@FreeBSD.org], не поддерживаются конкретным человеком.
Вместо этого любые исправления и поддержка приходят от сообщества тех, кто подписан на этот список рассылки.
Всегда требуется больше добровольцев!
====
+
Если ответа на сообщение нет, то воспользуйтесь Bugzilla для отправки сообщения о проблеме в соответствии с инструкциями в статье extref:{problem-reports}[Формирование сообщений о проблемах во FreeBSD].
. Исправьте его! В extref:{porters-handbook}[Руководстве по созданию портов] содержится подробная информация об инфраструктуре портов, так что вы сможете исправить случайно неработающий порт или даже предложить свой собственный!
. Установите пакет вместо порта в соответствии с указаниями в разделе <<pkgng-intro>>.
