//
// The FreeBSD Russian Documentation Project
//
// Original EN revision (SVN): 42903
//

---
title: "Глава 5. Установка приложений: порты и пакеты"
part: Часть I. В начале
prev: books/handbook/basics
next: books/handbook/x11
showBookMenu: true
weight: 7
path: "/books/handbook/ports/"
---

[[ports]]
= Установка приложений: порты и пакеты
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 5
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/ports/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[ports-synopsis]]
== Обзор

Вместе с FreeBSD в составе базового комплекта системы поставляется богатый набор системный утилит.
Кроме того, FreeBSD предоставляет две взаимодополняющие технологии для установки программного обеспечения сторонних разработчиков: Коллекция Портов FreeBSD для установки из исходного кода и пакеты для установки из откомпилированных бинарных файлов.'
Любой из этих методов может быть использован для установки приложений с локальных носителей или из сети.

После чтения этой главы вы будете знать:

* Разницу между бинарными пакетами и портами.
* Как найти программное обеспечение сторонних разработчиков, которое было перенесено во FreeBSD.
* Как управлять бинарными пакетами при помощи традиционной системы пакетов.
* Как управлять бинарными пакетами при помощи pkgng.
* Как компилировать программное обеспечение сторонних разработчиков из исходных текстов с использованием Коллекции Портов.
* Как найти файлы, установленные вместе с определённым приложением, для настройки после установки.
* Что делать, если установка программного обеспечения завершается неудачно.

[[ports-overview]]
== Обзор установки программного обеспечения

Стандартная процедура установки программного обеспечения сторонних разработчиков на UNIX(R)-систему выглядит примерно так:

[.procedure]
====
. Найдите и сгрузите программное обеспечение, которое может распространяться в форме исходных текстов или бинарных файлов.
. Извлеките программное обеспечения из его дистрибутивного образа. Обычно это архив в формате tar, сжатый при помощи man:compress[1], man:gzip[1] или man:bzip2[1].
. Поищите документацию в файлах [.filename]#INSTALL#, [.filename]#README# или в каком-то файле из подкаталога [.filename]#doc/# и прочтите её в поиске описания установки программного обеспечения.
. Если программное обеспечение распространялось в форме исходных текстов, скомпилируйте его. Сюда может быть включено редактирования файла [.filename]#Makefile# или запуск скрипта `configure`.
. Протестируйте и установите программное обеспечение.
====

Если программный пакет не был специально перенесён или протестирован на предмет работоспособности во FreeBSD, то может потребоваться редактирование исходного кода для его корректной установки и работы.
На момент написания этого текста во FreeBSD было перенесено более {numports} приложений сторонних разработчиков.

FreeBSD предоставляет две технологии, которые автоматизируют эти шаги.

Каждый пакет содержит уже откомпилированные копии всех команд приложения, а также все конфигурационные файлы и документацию.
С пакетом можно работать при помощи традиционных команд управления пакетами FreeBSD либо используя более новые команды pkgng, такие как `pkg install`.

Каждый порт FreeBSD является набором файлов, предназначенных для автоматизации процесса компиляции приложения из исходного кода. Файлы, из которых состоит порт, содержат всю необходимую информацию для выполнения автоматической загрузки, извлечения, применения патчей, компиляции и установки приложения.

Также система портов может использоваться для генерации пакетов, которые в последствии становятся объектом работы для команд управления пакетами FreeBSD.

Как пакеты, так и порты принимают во внимание зависимости.
Если для установки приложения используется пакет или порт, а необходимая библиотека ещё не была установлена, то в автоматическом режиме сначала будет установлена библиотека.

Несмотря на то, что обе технологии похожи, и пакеты, и порты имеют свои преимущества. Выберите технологию, которая соответствует вашим требованиям к установке конкретного приложения.

.Преимущества пакетов
* Сжатый tar-архив пакета обычно меньше, чем сжатый tar-архив, содержащий исходный код приложения.
* Пакеты не требуют времени на компиляцию. Для больших приложений, таких как Mozilla, KDE или GNOME, это может быть важно, особенно при работе на медленной системе.
* Пакеты не требуют понимания процесса компиляции программного обеспечения во FreeBSD.

.Преимущества портов
* Пакеты обычно компилируются с консервативными параметрами, потому что они должны работать на максимальном количестве систем. При установке из порта становится возможным изменение опций компиляции.
* Некоторые приложения имеют опции времени компиляции, позволяющие определять необходимые функциональные возможности. К примеру, Apache может быть настроен с широким набором различных опций.
+ 
В некоторых случаях для одного и того же приложения будут иметься несколько пакетов с разными предварительными настройками. Например, Ghostscript доступен как пакет [.filename]#ghostscript# и как пакет [.filename]#ghostscript-nox11# - в зависимости от того, установлен ли сервер X11. Создание нескольких пакетов одного приложения быстро становится бессмысленным, если приложение имеет более одного-двух параметров компиляции.
* Условия лицензирования некоторого программного обеспечения запрещают распространение в двоичном виде. Такое программное обеспечение должно распространяться в виде исходного кода и компилироваться конечным пользователем.
* Некоторые пользователи не доверяют дистрибутивам в двоичном виде или предпочитают прочесть исходный код и попытаться найти потенциальные проблемы.
* Исходный код нужен для того, чтобы применять специально разработанные корректировки.

Чтобы отслеживать обновления портов, подпишитесь на {freebsd-ports} и {freebsd-ports-bugs}.

[WARNING]
====

Перед установкой любого приложения необходимо зайти на http://vuxml.freebsd.org/[http://vuxml.freebsd.org/], где находится информация по вопросам безопасности приложений, или установить package:ports-mgmt/portaudit[]. После установки наберите `portaudit -F -a` для проверки всех установленных приложений на наличие известных уязвимостей.
====

В оставшейся части главы будет рассказано, как использовать пакеты и порты для установки и управления программным обеспечением сторонних разработчиков во FreeBSD.

[[ports-finding-applications]]
== Поиск программного обеспечения

Список имеющихся для FreeBSD приложений постоянно растет. Существует несколько способов найти то, что нужно:

* На сайте FreeBSD по адресу link:https://www.FreeBSD.org/ports/[http://www.FreeBSD.org/ports/] поддерживается обновляемый список всех имеющихся приложений для FreeBSD, в котором можно выполнять поиск. Поиск порта можно выполнить либо по имени приложения, либо по названию категории.
* Dan Langille поддерживает сайт link:http://www.FreshPorts.org/[FreshPorts.org], на котором есть удобный поиск, а также на нём отслеживаются изменения в приложениях из Коллекции Портов. Зарегистрированным пользователям доступна возможность создавать собственные списки наблюдаемых портов и автоматически получать оповещения об их обновлениях по электронной почте.
* Если вы не знаете названия какого-либо приложения, попытайтесь воспользоваться сайтом типа link:http://www.freecode.com/[Freecode.com] для его поиска, а затем возвратитесь на сайт FreeBSD, чтобы проверить, не было ли это приложение уже портировано.
* Если Коллекция портов уже установлена, есть несколько способов выполнения запроса к локальной версии дерева портов. Если вам необходимо определить, к какой категории относится порт, наберите `whereis _file_`, где _file_ - программа, которую вы хотите установить:
+
[source,shell]
....
# whereis lsof
lsof: /usr/ports/sysutils/lsof
....
+
Как вариант, можно воспользоваться man:echo[1]:
+
[source,shell]
....
# echo /usr/ports/*/*lsof*
/usr/ports/sysutils/lsof
....
+ 
Учтите, что в выводе также будут присутствовать любые совпадающие с шаблоном имена файлов, сохранённые в [.filename]#/usr/ports/distfiles#.
* Ещё одним способом поиска программного обеспечения является использование встроенной возможности поиска в Коллекции Портов. Чтобы ею воспользоваться, зайдите в [.filename]#/usr/ports# и выполните команду `make search name=_program-name_`, где _program-name_ - это название программы, которую вы хотите найти. Например, если вы ищете `lsof`:
+
[source,shell]
....
# cd /usr/ports
# make search name=lsof
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
Maint:  ler@lerctr.org
Index:  sysutils
B-deps:
R-deps:
....
+
[TIP]
====
Встроенный поисковой механизм использует файл с индексной информацией. Если получено сообщение, что требуется файл [.filename]#INDEX#, запустите `make fetchindex` для загрузки актуального индексного файла. После загрузки файла [.filename]#INDEX# команда `make search` сможет выполнить запрошенный поиск.
====
+ 
Строка "Path:" указывает, где находится порт.
+ 
Чтобы получить лаконичный вывод, задайте цель `quicksearch`:
+
[source,shell]
....
# cd /usr/ports
# make quicksearch name=lsof
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
....
+
Для выполнения более глубокого поиска используйте `make search key=_string_` или `make quicksearch key=_string_`, где _string_ представляет собой некоторый текст, относящийся к искомому порту. Текст может быть в комментариях, описаниях или зависимостях. Этот способ можно использовать для поиска портов, связанных с некоторой темой, когда название программы неизвестно.
+
При использовании `search` и `quicksearch` строка поиска нечувствительна к регистру. Поиск "LSOF" приводит к тому же самому результату, что и поиск "lsof".

[[packages-using]]
== Использование бинарных пакетов

В настоящее время FreeBSD переводится на новый метод управления пакетами.
Пользователи могут заинтересоваться изучением преимуществ использования crossref:ports[pkgng-intro,PKGng] для управления программным обеспечением сторонних разработчиков во FreeBSD.
Этот раздел описывает традиционный способ управления бинарными пакетами и касается только тех пользователей, которые ещё не перешли на формат pkgng.

Этот метод управления пакетами использует каталог с базой данных пакетов, [.filename]#/var/db/pkg#, для отслеживания версий установленного программного обеспечения и файлов, которые устанавливаются с каждым приложением.
С каталогом базы данных работают несколько утилит, используемых для управления бинарными пакетами.
Эти команды начинаются с `pkg_`.
Этот раздёл даёт обзор команд, используемых для установки, удаления и сбора информации о бинарных пакетах.
У каждой команды имеется несколько параметров для настройки её работы.
Обратитесь к указанным страницам Справочника для получения дополнительной информации и примеров использования.

=== Установка пакета

Воспользуйтесь man:pkg_add[1] для установки бинарного пакета с локального носителя с FreeBSD или с сервера пакетов из сети.
В то время как носитель с FreeBSD может предоставить исходный код локальных пакетов без необходимости в сетевом подключении, на нём могут отсутствовать самые последние версии двоичных пакетов, так как новые версии постоянно пересобираются для серверов пакетов FreeBSD.
Для установки с сервера пакетов всегда указывайте `-r` (что означает remote, то есть удалённый) с man:pkg_add[1].
Эта команда автоматически определяет правильный формат объектных файлов и релиз, а затем загружает и устанавливает нужный пакет с сервера пакетов без какого-либо дальнейшего вмешательства пользователя.

[source,shell]
....
# pkg_add -r lsof
....

В этом примере `lsof` указывается без уточнения номера версии, так как при использовании функции удалённой сгрузки версия не указывается.
Чтобы указать альтернативный зеркалирующий сервер FTP FreeBSD, укажите его адрес в переменной окружения `PACKAGESITE`.
Для загрузки файлов утилита man:pkg_add[1] использует man:fetch[3].
Последняя учитывает значения различных переменных окружения, включая `FTP_PASSIVE_MODE`, `FTP_PROXY` и `FTP_PASSWORD`.
Если вы находитесь за сетевым экраном, или для работы с FTP/HTTP вам необходимо использовать прокси, то задайте соответствующие переменные.
Обратитесь к справочной странице по man:fetch[3] для получения полного списка переменных, связанных с FTP.

[NOTE]
====
Если вы используете FreeBSD-CURRENT или FreeBSD-STABLE, то утилита man:pkg_add[1] загрузит последнюю версию устанавливаемой программы. Если же вы используете версию -RELEASE, то man:pkg_add[1] установит версию пакета, который был собран для конкретного релиза. Это поведение возможно изменить переопределив значение `PACKAGESITE`.
Например, в системе FreeBSD 9.1-RELEASE man:pkg_add[1] по умолчанию попытается скачать пакеты с `ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-9.1-release/Latest/`.
Чтобы заставить man:pkg_add[1] загружать пакеты для FreeBSD 9-STABLE, присвойте `PACKAGESITE` значение `ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-9-stable/Latest/`.
====

Файлы пакетов распространяются в формате [.filename]#.tbz#.
Пакеты находятся по адресу link:ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages[ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages] или в каталоге [.filename]#/packages# дистрибутива FreeBSD на DVD. Структура каталогов с пакетами похожа на организацию дерева [.filename]#/usr/ports#.
Каждая категория имеет собственный каталог, и каждый пакет может быть найден в каталоге [.filename]#All#.

=== Управление пакетами

Для вывода списка установленных пакетов и их описаний воспользуйтесь man:pkg_info[1]:

[source,shell]
....
# pkg_info
colordiff-1.0.13    Tool to colorize diff output
docbook-1.4         Meta-port for the different versions of the DocBook DTD
...
....

Используйте man:pkg_version[1] для получения списка версий всех установленных пакетов и сравнения версий установленных пакетов с актуальными версиями, находящимися в локально установленном дереве портов:

[source,shell]
....
# pkg_version
colordiff                   =
docbook                     =
...
....

Символы во второй колонке указывают сравнительную разницу в возрасте установленной версии и версии, находящейся в локальном дереве портов.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Символ
| Значение

|=
|Версия установленного пакета соответствует версии, находящейся в локальном дереве портов.

|<
|Версия установленного пакета является более старой по сравнению с той, что имеется в локальном дереве портов.

|>
|Версия установленного пакета является более новой по сравнению с той, что имеется в локальном дереве портов, а это значит, что, скорее всего, локальное дерево портов устарело.

|?
|В индексном файле портов установленный пакет не найден. Это может случиться если установленный порт был переименован или удалён из Коллекции Портов.

|*
|Имеется несколько версий пакета.

|!
|Установленный пакет есть в индексном файле, но по какой-то причине команде `pkg_version` не удалось сравнить номер версии установленного пакета и соответствующей записи в файле.
|===

=== Удаление пакета

Для удаления ранее установленных пакетов с программным обеспечением используйте утилиту man:pkg_delete[1].

[source,shell]
....
# pkg_delete xchat-2.8.8_1
....

Заметьте, что man:pkg_delete[1] требует полное имя пакета и номер, и что команда выше не сработала бы, если бы было указано _xchat_ вместо _xchat-2.8.8_1_.
Для определения версии установленного пакета задействуйте утилиту man:pkg_version[1]. Или же, напечатайте групповой символ (wildcard) вместо номера версии:

[source,shell]
....
# pkg_delete xchat\*
....

в этом случае будут удалены все пакеты, имена которых начинаются на `xchat`.

[[pkgng-intro]]
== Использование pkgng для управления бинарными пакетами

pkgng является заменой традиционных утилит управления пакетами FreeBSD следующего поколения, предоставляющей множество функциональных возможностей, ускоряющих и облегчающих работу с бинарными пакетами.

pkgng не является заменой для утилит управления портами, таких как package:ports-mgmt/portmaster[] или package:ports-mgmt/portupgrade[].
Эти инструменты могут использоваться для установки приложений сторонних разработчиков как из бинарных пакетов, так и из Коллекции Портов, тогда как pkgng устанавливает исключительно бинарные пакеты.

[[pkgng-initial-setup]]
=== Начало работы с pkgng

Во FreeBSD 9.1 и более поздних версиях имеется утилита начальной загрузки, которая может использоваться для скачивания и установки pkgng вместе с её справочными страницами.

Для запуска начальной загрузки выполните:

[source,shell]
....
# /usr/sbin/pkg
....

В более ранних версиях FreeBSD утилита pkgng вместо этого должна устанавливаться из Коллекции Портов или как бинарный пакет.

Для установки порта запустите следующее:

[source,shell]
....
# cd /usr/ports/ports-mgmt/pkg
# make
# make install clean
....

Для установки из бинарного пакета, выполните:

[source,shell]
....
# pkg_add -r pkg
....

После того, как pkgng будет установлен, база данных пакетов обязательно должна быть преобразована из традиционного формата в новый формат посредством запуска следующей команды:

[source,shell]
....
# pkg2ng
....

Этот шаг не требуется для новых инсталляций, в которых ещё нет установленного программного обеспечения сторонних разработчиков.

[IMPORTANT]
====
Этот шаг необратим.
После перевода базы данных установленных пакетов к формату pkgng традиционные инструменты `pkg_*` использоваться не должны.
====

[NOTE]
====
В процессе конвертирования базы данных установленных пакетов могут возникать сообщения об ошибках.
В целом их можно игнорировать без особого риска.
Однако перечень программного обеспечения сторонних разработчиков, которое не было преобразовано, будет отражён после завершения работы `pkg2ng`, и эти приложения должны быть переустановлены в неавтоматизированном режиме.
====

Чтобы быть уверенным в том, что Коллекция Портов FreeBSD регистрирует новые программы при помощи pkgng, а не в традиционном формате, для версий FreeBSD, предшествующих 10._X_, в файле [.filename]#/etc/make.conf# требуется наличие следующей строки:

[.programlisting]
....
WITH_PKGNG=	yes
....

Система управления пакетами pkgng при выполнении большинства операций обращается к пакетному репозиторию.
Адрес используемого по умолчанию репозитория задаётся в [.filename]#/usr/local/etc/pkg.conf# или в переменной окружения `PACKAGESITE`, которая переопределяет адрес, указанный в конфигурационном файле.

Дополнительные опции конфигурации pkgng описаны в pkg.conf(5).

Информация о порядке использования pkgng доступна в pkg(8) или в выводе утилиты `pkg`, запущенной без дополнительных параметров.

Каждый аргумент команды pkgng описан на соответствующей странице справочника. Например, чтобы ознакомиться со страницей справочника для `pkg install`, запустите любую из следующих команд:

[source,shell]
....
# pkg help install
....

[source,shell]
....
# man pkg-install
....

В оставшейся части этого раздела демонстрируются частые задачи управления бинарными пакетами, которые могут быть выполнены при помощи pkgng.
Каждая из показываемых команд имеет много параметров для различных целей использования.
Обратитесь к встроенной справочной информации о команде или странице Справочника за деталями и дополнительными примерами.

[[pkgng-pkg-info]]
==== Получение информации об установленных пакетах

Информация об установленных в системе пакетах может быть отображена при помощи команды `pkg info`, которая при запуске без указания модифицирующих параметров отобразит версию пакета либо для всех установленных пакетов, либо для указанного.

Например, для просмотра установленной версии pkgng выполните:

[source,shell]
....
# pkg info pkg
pkg-1.1.4_1
....

[[pkgng-installing-deinstalling]]
=== Установка и удаление пакетов

Для установки бинарного пакета используйте следующую команду, в которой _packagename_ является наименованием пакета для установки:

[source,shell]
....
# pkg install packagename
....

Эта команда использует данные хранилища для определения версии устанавливаемого программного обеспечения и выявления каких-либо неустановленных зависимостей.
Например, для установки curl выполните:

[source,shell]
....
# pkg install curl
Updating repository catalogue
/usr/local/tmp/All/curl-7.31.0_1.txz          100% of 1181 kB 1380 kBps 00m01s

/usr/local/tmp/All/ca_root_nss-3.15.1_1.txz   100% of  288 kB 1700 kBps 00m00s

Updating repository catalogue
The following 2 packages will be installed:

Installing ca_root_nss: 3.15.1_1
Installing curl: 7.31.0_1

The installation will require 3 MB more space

0 B to be downloaded

Proceed with installing packages [y/N]: y
Checking integrity... done
[1/2] Installing ca_root_nss-3.15.5_1... done
[2/2] Installing curl-7.31.0_1... done
Cleaning up cache files...Done
....

Новый пакет и любые дополнительные пакеты, которые были установлены как зависимости, можно увидеть в списке установленных пакетов:

[source,shell]
....
# pkg info
ca_root_nss-3.15.5_1	The root certificate bundle from the Mozilla Project
curl-7.31.0_1		Non-interactive tool to get files from FTP, GOPHER, HTTP(S) servers
pkg-1.1.4_6		New generation package manager
....

Пакеты, в которых больше нет необходимости, могут быть удалены при помощи `pkg delete`.
Например:

[source,shell]
....
# pkg delete curl
The following packages will be deleted:

	curl-7.31.0_1

The deletion will free 3 MB

Proceed with deleting packages [y/N]: y
[1/1] Deleting curl-7.31.0_1... done
....

[[pkgng-upgrading]]
==== Обновление установленных пакетов

Пакеты, версии которых устарели, можно найти при помощи команды `pkg version`.
Если локальное дерево портов отсутствует, то pkg-version(8) будет использовать каталог удалённого хранилища.
Если это не так, то для идентификации версий пакетов будет использоваться локальное дерево портов.

Установленные пакеты могут быть обновлены до их самых последних версий набором команды `pkg upgrade`.
Эта команда сравнит установленные версии с теми, что доступны в каталоге хранилища.
По завершении работы она выдаст список приложений, имеющих более новые версии.
Наберите `y` для продолжения обновления или `n` для того, чтобы отказаться от обновления.

[[pkgng-auditing]]
=== Аудит установленных пакетов

Иногда случается так, что в приложениях сторонних поставщиков могут быть обнаружены программные уязвимости.
Для решения этой проблемы в pkgng встроен механизм аудита.
Для выявления наличия каких бы то ни было известных уязвимостей в программном обеспечении, установленном в системе, запустите:

[source,shell]
....
# pkg audit -F
....

[[pkgng-autoremove]]
=== Автоматическое удаление неиспользуемых зависимостей

После удаления пакета в системе могут оставаться зависимости, которые больше не востребованы.
Ненужные пакеты, которые были установлены как зависимости, могут быть выявлены и удалены в автоматическом режиме при помощи:

[source,shell]
....
# pkg autoremove
Packages to be autoremoved:
	ca_root_nss-3.13.5

The autoremoval will free 723 kB

Proceed with autoremoval of packages [y/N]: y
Deinstalling ca_root_nss-3.15.1_1... done
....

[[pkgng-backup]]
=== Резервное копирование базы данных пакетов

В отличие от традиционной системы управления пакетами, pkgng располагает своим собственным механизмом резервного копирования базы данных.
Для ручного создания резервной копии содержимого базы данных пакетов, выполните следующую команду, заменив _pkgng.db_ именем соответствующего файла:

[source,shell]
....
# pkg backup -d pkgng.db
....

Кроме того, pkgng содержит скрипт man:periodic[8] для выполнения ежедневного резервного копирования базы данных пакетов в автоматическом режиме.
Для активации данной возможности задайте переменной `daily_backup_pkgng_enable` значение `YES` в файле man:periodic.conf[5].

[TIP]
====
Для отключения такого периодического резервного копирования базы данных пакетов задайте переменной `daily_backup_pkgdb_enable` значение `NO` в файле man:periodic.conf[5].
====

Для восстановления содержимого базы данных установленных пакетов из резервной копии, выполните:

[source,shell]
....
# pkg backup -r /path/to/pkgng.db
....

[[pkgng-clean]]
=== Удаление устаревших пакетов

По умолчанию, pkgng сохраняет копии установленных бинарных пакетов в каталог, заданный в переменной `PKG_CACHEDIR` в pkg.conf(5).
При обновлении пакетов командой `pkg upgrade` старые версии обновленных пакетов автоматически не удаляются.

Для удаления этих устаревших версий бинарных пакетов, выполните:

[source,shell]
....
# pkg clean
....

[[pkgng-set]]
=== Изменение метаданных пакета

В программном обеспечении из Коллекции Портов FreeBSD может изменяться старший номер версии.
Для решения этой задачи в pkgng имеется встроенная команда для обновления информации о местоположении пакета.
Это может оказаться полезным, к примеру, когда [.filename]#lang/php5# переименовывается в [.filename]#lang/php53#, так что [.filename]#lang/php5# теперь может соответствовать версии `5.4`.

В вышеприведенном случае для изменения местоположения пакета выполните:

[source,shell]
....
# pkg set -o lang/php5:lang/php53
....

Ещё один пример: для изменения информации о местоположении пакета с package:lang/ruby18[] на package:lang/ruby19[], выполните:

[source,shell]
....
# pkg set -o lang/ruby18:lang/ruby19
....

И последний пример: для замены информации о местоположении пакета разделяемой библиотеки [.filename]#libglut# с package:graphics/libglut[] на package:graphics/freeglut[], запустите:

[source,shell]
....
# pkg set -o graphics/libglut:graphics/freeglut
....

[NOTE]
====
Выполняя замену информации о местоположении пакетов, важно переустановить пакеты, которые зависят от пакета с изменившимся местоположением.
Для принудительной переустановки зависимых пакетов, выполните:

[source,shell]
....
# pkg install -Rf graphics/freeglut
....
====

[[ports-using]]
== Использование Коллекции Портов

Коллекция Портов является набором файлов [.filename]#Makefile#, патчей и файлов описаний, хранимых в [.filename]#/usr/ports#.
Этот набор файлов предназначен для компиляции и установки приложений во FreeBSD.
Перед тем, как то или иное приложение может быть скомпилировано при помощи порта, в обязательном порядке должна быть установлена Коллекция Портов.
Если она не была установлена в ходе установки FreeBSD, воспользуйтесь одним из следующих методов для её установки:

[.procedure]
====
*Procedure: Метод Portsnap*

Portsnap является быстрым и удобным для пользователей инструментом для получения Коллекции Портов, рекомендуемый к выбору для большинства пользователей.
Обратитесь к разделу <<updating-upgrading-portsnap>> для получения подробного описания Portsnap.

. Скачайте сжатый снэпшот Коллекции Портов в [.filename]#/var/db/portsnap#.
+
[source,shell]
....
# portsnap fetch
....
+
. Если вы запускаете Portsnap впервые, извлеките снэпшот в [.filename]#/usr/ports#:
+
[source,shell]
....
# portsnap extract
....
+
. По завершении первого запуска Portsnap, как было показано выше, [.filename]#/usr/ports# может быть при необходимости обновлён запуском:
+
[source,shell]
....
# portsnap fetch
# portsnap update
....
====

[.procedure]
====
*Procedure: Метод Subversion*

Если необходим дополнительный контроль за деревом портов или имеется необходимость в поддержании локальных изменений, то для получения Коллекции Портов может быть задействован Subversion.
Обратитесь к extref:{committers-guide}[Subversion Primer, subversion-primer] за детальным описанием Subversion.

. Для создания рабочей копии дерева портов необходимо иметь установленный Subversion. Если порты есть в наличии, то установите Subversion выполнив следующее:
+
[source,shell]
....
# cd /usr/ports/devel/subversion
# make install clean
....
+ 
Если портов нет, то Subversion может быть установлен при помощи системы пакетов:
+
[source,shell]
....
# pkg_add -r subversion
....
+ 
Если же для управления пакетами используется pkgng, то Subversion устанавливается при помощи следующей команды:
+
[source,shell]
....
# pkg install subversion
....
+
. Извлеките рабочую копию дерева портов. Для повышения производительности замените _svn0.us-east.FreeBSD.org_ на географически ближайшее к вам crossref:mirrors[svn-mirrors,зеркало Subversion].
+
[source,shell]
....
# svn checkout https://svn0.us-east.FreeBSD.org/ports/head /usr/ports
....
+
. По мере необходимости после первичного извлечения хранилища Subversion обновляйте [.filename]#/usr/ports#:
+
[source,shell]
....
# svn update /usr/ports
....
====

Коллекция Портов включает набор каталогов, соответствующих категориям программного обеспечения, при этом в каждой категории присутствует подкаталог для каждого приложения.
Каждый подкаталог, также называемый скелетом портов, содержит набор файлов, указывающих FreeBSD, как скомпилировать и установить данную программу.
Скелет любого порта включает следующие файлы и каталоги:

* [.filename]#Makefile#: содержит директивы, которые определяют, как приложение должно быть откомпилировано и куда должно быть установлены его компоненты.
* [.filename]#distinfo#: содержит имена и контрольные суммы файлов, которые должны быть сгружены для сборки порта.
* [.filename]#files#: этот каталог содержит все патчи, необходимые для компиляции и установки программы во FreeBSD. Этот каталог может также содержать другие файлы, используемые для построения порта.
* [.filename]#pkg-descr#: предоставляет более подробное описание программы.
* [.filename]#pkg-plist#: список всех файлов, которые будут установлены портом. Он также указывает системе портов на то, какие файлы подлежат удалению при удаления порта.

В некоторых портах присутствует файл [.filename]#pkg-message# или другие файлы для обработки особых ситуаций. Для получении дополнительной информации об этих файлах и о портах в целом обратитесь к extref:{porters-handbook}[Руководству по созданию портов для FreeBSD].

Порт не содержит собственно исходного кода, именуемого как [.filename]#distfile#.
Этап распаковки процесса построения порта будет автоматически сохранять сгруженный исходный код в [.filename]#/usr/ports/distfiles#.


[[ports-skeleton]]
=== Установка портов

Этот раздел содержит базовые указания по использования Коллекции Портов для установки и удаления программного обеспечения.
Подробное описание доступных целей и переменных окружения для `make` доступно в man:ports[7].

[WARNING]
====
Перед компиляцией любого порта не забудьте обновить Коллекцию Портов, как это описано в предыдущем разделе.
Так как установка любого программного обеспечения сторонних разработчиков может привести к появлению уязвимостей в безопасности, рекомендуется сначала обратиться к link:http://vuxml.freebsd.org/ на предмет известных проблем с безопасностью, связанных с данным портом.
Либо, при наличии установленного package:ports-mgmt/portaudit[], запустите команду `portaudit -F` перед установкой нового порта.
Эта команда может быть настроена на автоматическое выполнение аудита безопасности обновление базы данных уязвимостей во время ежедневной системной проверки безопасности.
Для получения дополнительной информации обратитесь к справочным страницам portaudit и man:periodic[8].
====

Использование Коллекции Портов предполагает наличие работающего подключения к Интернет.
Также оно требует полномочий суперпользователя.

Некоторые DVD-продукты сторонних поставщиков, таких как FreeBSD Toolkit от link:http://www.freebsdmall.com/[freebsdmall.com], содержат дистрибутивные файлы, которые могут использоваться для установки портов без соединения с Интернет.
Смонтируйте DVD в [.filename]#/cdrom#.
Если вы используете другую точку монтирования, то задайте значение переменной `CD_MOUNTPTS` для make.
Если нужные дистрибутивные файлы находятся на диске, то они будут автоматически использоваться.
Однако лицензии нескольких портов не разрешают их размещение на DVD.
Это может происходить из-за невозможности использования регистрационной формы, требуемой для сгрузки или дальнейшего распространения.
Для установки порта, отсутствующего на DVD, будет требоваться соединение с Интернет.

Для компиляции и установки порта перейдите в каталог порта, который будет устанавливаться, а затем наберите `make install` в приглашении командной строки.
Ход процесса будет отображаться в сообщениях:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
# make install
>> lsof_4.88D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
>> Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===>  Extracting for lsof-4.88
...
[вывод этапа распаковки опущен]
...
>> Checksum OK for lsof_4.88D.freebsd.tar.gz.
===>  Patching for lsof-4.88.d,8
===>  Applying FreeBSD patches for lsof-4.88.d,8
===>  Configuring for lsof-4.88.d,8
...
[вывод этапа настройки опущен]
...
===>  Building for lsof-4.88.d,8
...
[вывод этапа компиляции опущен]
...
===>  Installing for lsof-4.88.d,8
...
[вывод этапа установки опущен]
...
===>   Generating temporary packing list
===>   Compressing manual pages for lsof-4.88.d,8
===>   Registering installation for lsof-4.88.d,8
===>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
#
....

Так как `lsof` является программой, которая запускается с повышенными привилегиями, при установке выдаётся предупреждение о безопасности.
После завершения установки произойдёт возврат к приглашению командной строки.

Некоторые командные процессоры поддерживают кэш команд, доступных в каталогах, перечисленных в переменной окружения `PATH`, для ускорения поиска исполнимых файлов для этих команд.
Пользователи оболочки командной строки `tcsh` должны набрать `rehash`, чтобы новая установленная команда могла быть использована без указания её полного пути.
Используйте `hash -r` вместо указанной команды для оболочки `sh`.
Обратитесь к документации о конкретном командном процессоре для получения дополнительной информации.

Во время установки создаётся рабочий подкаталог, содержащий все временные файлы, используемые во время компиляции.
Удаление этого каталога экономит дисковое пространство и минимизирует вероятность возникновения проблем в дальнейшем при обновлении до более новой версии порта:

[source,shell]
....
# make clean
===>  Cleaning for lsof-88.d,8
#
....

[NOTE]
====
Для экономии времени на запуск этого дополнительного шага используйте команду `make install clean` при компиляции порта.
====

==== Настройка установки портов

Некоторые порты имеют параметры построения, которые могут быть использованы для включения или отключения компонентов приложения, указания параметров безопасности или выполнять другие тонкие настройки.
Примерами могут служить [.filename]#www/firefox#, [.filename]#security/gpgme# и [.filename]#mail/sylpheed-claws#.
Если у порта имеются настраиваемые параметры, он может останавливаться несколько раз для взаимодействия с пользователем, так как по умолчанию выполняется запрос пользователю для выбора параметров из меню.
Во избежание такого поведения запустите команду `make config-recursive` для выполнения конфигурации за один прогон.
Затем запустите `make install [clean]` для компиляции и установки порта.

[TIP]
====
Когда используется `config-recursive`, перечень подлежащих настройке портов собирается целью `all-depends-list`.
Рекомендуется повторять запуск `make config-recursive` до тех пор, пока не будут определены все параметры зависимых портов и больше не выдаются экраны с параметрами портов, что даёт уверенность в том, что все параметры зависимостей были настроены.
====

Имеется несколько способов пересмотра набора параметров построения того или иного порта для того, чтобы добавить, удалить или изменить их после того, как порт был построен.
Одним из методов является переход по команде `cd` в каталог, содержащий порт и вызов команды `make config`.
Другим вариантом является использование команды `make showconfig`.
Ещё одним вараинтом является выполнение команды `make rmconfig`, которая удалит все выбранные параметры и позволит вам начать сначала.
Все эти и другие варианты очень подробно описаны в man:ports[7].

Для загрузки файлов с исходным кодом система портов использует утилиту man:fetch[1], которая поддерживает различные переменные окружения.
Если система FreeBSD находится за межсетевым экраном или прокси-сервером FTP/HTTP, то может потребоваться настройка значений переменных `FTP_PASSIVE_MODE`, `FTP_PROXY` и `FTP_PASSWORD`.
Обратитесь к справочной странице по man:fetch[3] для получения полного списка поддерживаемых переменных.

Пользователи, которые не имеют возможности быть постоянно подключенными к Интернет, могут выполнить команду `make fetch` в каталоге [.filename]#/usr/ports# для сгрузки всех дистрибутивных файлов, или в каталоге категории, подобном [.filename]#/usr/ports/net#, или в каталоге конкретного порта.
Заметьте, что если порт имеет какие бы то ни было зависимости, то запуск этой команды в какой-либо категории или каталоге порта _не будет_ приводить к сгрузке дистрибутивных файлов портов из другой категории.
Вместо этого воспользуйтесь командой `make fetch-recursive` для того, чтобы сгрузить также дистрибутивные файлы всех зависимостей порта.

В редких случаях, например, когда в какой-либо организации имеется локальный репозиторий дистрибутивных файлов, можно использовать переменную `MASTER_SITES` для переопределения местоположений для сгрузки, указанных в [.filename]#Makefile#.
При её использовании укажите альтернативное размещение:

[source,shell]
....
# cd /usr/ports/directory
# make MASTER_SITE_OVERRIDE= \
_ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/_ fetch
....

При помощи переменных `WRKDIRPREFIX` и `PREFIX` можно переопределить назначаемые по умолчанию рабочий и целевой каталоги.
Например:

[source,shell]
....
# make WRKDIRPREFIX=/usr/home/example/ports install
....

будет компилировать порт в каталоге [.filename]#/usr/home/example/ports#, а установит всё в [.filename]#/usr/local#.

[source,shell]
....
# make PREFIX=/usr/home/example/local install
....

будет компилировать порт в каталоге [.filename]#/usr/ports#, а установит его в [.filename]#/usr/home/example/local#.
А также:

[source,shell]
....
# make WRKDIRPREFIX=../ports PREFIX=../local install
....

будет комбинировать оба варианта.

Это может быть также определено в виде переменных окружения.
Обратитесь к страницам справки по вашему командному процессору для получения инструкций о том, как установить переменные окружения.

[[ports-removing]]
=== Удаление установленных портов

Установленные порты могут быть удалены при помощи команды man:pkg.delete[1].
Либо, если система FreeBSD была настроена на использование приложения pkg, порт может быть удалён командой `pkg delete`.
Примеры использования использования этих команд можно найти в разделах <<packages-using>> и <<pkgng-intro>>.

Либо в каталоге порта может быть запущена команда `make deinstall`:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
make deinstall
===>  Deinstalling for sysutils/lsof
===>   Deinstalling
Deinstallation has been requested for the following 1 packages:

       lsof-4.88.d,8
The deinstallation will free 229 kB
[1/1] Deleting lsof-4.88.d,8... done
....

Рекомендуется прочесть сообщения, выдаваемые в процессу удаления порта.
Если у порта имеются какие-либо приложения, зависящие от него, то эта информация будет отражена, но процесс удаления будет продолжен.
В таких случаях хорошим действием может быть повторная установка данного приложения для того, чтобы избежать появления неработающих зависимостей.

[[ports-upgrading]]
=== Обновление портов

Прежде всего, при помощи man:pkg_version[1] просмотрите, нет ли в Коллекции Портов более новых версий установленных приложений:

[source,shell]
....
# pkg_version -v
....

[[ports-file-updating]]
==== Прочитайте [.filename]#/usr/ports/UPDATING#

После обновления Коллекции Портов, и перед тем, как обновить приложение из порта, сверьтесь с файлом [.filename]#/usr/ports/UPDATING#. В нем дана информация по различным вопросам и дополнительным шагам, которые могут быть необходимы для обновления порта, включая информацию о таких вещах как изменения форматов файлов, изменения в расположении конфигурационных файлов, или другие нестыковки с предыдущими версиями.

Если [.filename]#UPDATING# противоречит чему-либо, написанному в этом документе, то доверьтесь информации из [.filename]#UPDATING#.

[[portupgrade]]
==== Обновление Портов при помощи Portupgrade

Утилита portupgrade создана для простого обновления установленных портов. Она доступна из порта package:ports-mgmt/portupgrade[]. Установите её как и любой иной порт при помощи команды `make install clean`:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portupgrade
# make install clean
....

Проверьте перечень установленных портов командой `pkgdb -F` и устраните все несоответствия, о которых сообщит утилита. Хорошей идеей является выполнение этого действия регулярно, перед каждым обновлением.

Используйте `portupgrade -a` для обновления всех устаревших портов, установленных в вашей системе. Добавьте флаг `-i` если вы желаете получать запрос на каждый обновляемый порт.

[source,shell]
....
# portupgrade -ai
....

Для обновления конкретного приложения, а не всех установленных портов, запустите `portupgrade _pkgname_`. Включите флаг `-R` при необходимости обновить все порты, требуемые данным приложением.

[source,shell]
....
# portupgrade -R firefox
....

Для использования при установке пакетов, а не портов, укажите флаг `-P`. С этим параметром portupgrade будет искать пакеты в локальных каталогах, указанных в переменной окружения `PKG_PATH`, а если не найдет их, то загрузит с удаленного сайта. Если пакеты не могут быть найдены локально или загружены удаленно, portupgrade использует порты. Чтобы запретить использование портов, укажите `-PP`.

[source,shell]
....
# portupgrade -PP gnome2
....

Для простой загрузки дистрибутивных файлов без построения или установки чего бы то ни было, задайте флаг `-F`. Дополнительную информацию можно получить на странице справки по утилите man:portupgrade[1].

[[portmaster]]
==== Обновление портов при помощи portmaster

Утилита package:ports-mgmt/portmaster[] - это еще один инструмент для обновления установленных портов. Утилита portmaster опирается на возможности "базовой" системы и не зависит от других портов. Она использует информацию из [.filename]#/var/db/pkg/# для определения портов, подлежащих обновлению. Для установки утилиты выполните следующее:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portmaster
# make install clean
....

Portmaster делит порты на четыре категории:

* Корневые порты: не зависят от других портов и нет портов, зависимых от корневых;
* Стволовые порты: не зависят от других портов, но есть порты, зависящие от стволовых;
* Веточные порты: зависят от других портов и есть порты, зависящие от веточных;
* Листьевые порты: зависят от других портов, но нет портов, зависящих от листьевых.

Чтобы проверить наличие обновлений для всех установленных портов, задайте утилите флаг `-L`:

[source,shell]
....
# portmaster -L
===>>> Root ports (No dependencies, not depended on)
===>>> ispell-3.2.06_18
===>>> screen-4.0.3
        ===>>> New version available: screen-4.0.3_1
===>>> tcpflow-0.21_1
===>>> 7 root ports
...
===>>> Branch ports (Have dependencies, are depended on)
===>>> apache22-2.2.3
        ===>>> New version available: apache22-2.2.8
...
===>>> Leaf ports (Have dependencies, not depended on)
===>>> automake-1.9.6_2
===>>> bash-3.1.17
        ===>>> New version available: bash-3.2.33
...
===>>> 32 leaf ports

===>>> 137 total installed ports
        ===>>> 83 have new versions available
....

Все установленные порты могут быть обновлены при помощи одной команды:

[source,shell]
....
# portmaster -a
....

[NOTE]
====
По умолчанию, portmaster создаст дублирующий пакет перед удалением установленного порта. Если обновление порта прошло успешно, portmaster удалит дублирующий пакет. При помощи опции `-b` можно проинструктировать portmaster не выполнять автоматическое удаление дублирующего пакета. Указание опции `-i` запустит portmaster в интерактивном режиме, запрашивающим подтверждение пользователя перед обновлением каждого порта.
====

Если во время процесса обновления возникнут ошибки, задействуйте опцию `-f` для обновления/перестройки всех портов:

[source,shell]
....
# portmaster -af
....

Также, portmaster может быть задействован для установки новых портов в систему, автоматически обновляя другие зависимые порты перед построением и установкой нового порта:

[source,shell]
....
# portmaster shells/bash
....

За подробной информацией обратитесь к man:portmaster[8].

[[ports-disk-space]]
=== Порты и дисковое пространство

Работа с Коллекцией Портов со временем приводит к увеличению занимаемого дискового пространства. После построения и установки программы из порта удалите временный каталог [.filename]#work# при помощи команды `make clean`. Для очистки всей Коллекции Портов наберите:

[source,shell]
....
# portsclean -C
....

По прошествии некоторого времени у вас соберется множество дистрибутивных файлов в каталоге [.filename]#distfiles#. Следующая команда удалит все дистрибутивные файлы, которые более не связаны ни с какими портами:

[source,shell]
....
# portsclean -D
....

Для удаления всех дистрибутивных файлов, не связанных ни с одним установленным в вашу систему портом, наберите:

[source,shell]
....
# portsclean -DD
....

[NOTE]
====
Утилита `portsclean` является частью порта package:ports-mgmt/portupgrade[].
====

Удобная утилита для автоматизации удаления портов, в которых вы более не нуждаетесь, доступна из порта package:ports-mgmt/pkg_cutleaves[].

[[ports-nextsteps]]
== Действия после установки

Вне зависимости от того, было ли программное обеспечение установлено из бинарного пакета или порта, большинству приложений сторонних разработчиков после установки требуется определённый уровень настройки.
Нижеследующие команды и места размещения могут помочь в определении того, что было установлено вместе с приложением.

* Большинство приложений устанавливает по крайней мере один конфигурационный файл, используемый по умолчанию, в каталог [.filename]#/usr/local/etc#.
+
Конфигурационные файлы должны быть изучены и, возможно, отредактированы для того, чтобы соответствовать требованиям системы.
* Приложения, поставляемые с документацией, будут устанавливать её в каталог [.filename]#/usr/local/share/doc#, также многие приложения устанавливают страницы Справочника.
+
Перед тем, как продолжить, это документация должна быть изучена.
* Некоторые приложения обслуживают сервисы, которые обязательно должны быть добавлены в [.filename]#/etc/rc.conf# до запуска приложения.
+
Такие приложения обычно устанавливают скрипт запуска в [.filename]#/usr/local/etc/rc.d#.
+
Обратитесь к разделу crossref:config[configtuning-starting-services,Запуск сервисов] для получения дополнительной информации.
* Те, кто использует man:csh[1], должны выполнить команду `rehash` для актуализации двоичного списка в переменной `PATH` оболочки.
* Если в системе работает традиционная система управления пакетами, воспользуйтесь man:pkg.info[1] для определения того, какие файлы, страницы Справочника и бинарные файлы были установлены вместе с приложением.
+
Если в системе работает pkgng, вместо этого воспользуйтесь `pkg info`.

[[ports-broken]]
== Обработка неработоспособных портов

Если вы встретили порт, который не компилируется или не устанавливается:

. Выясните, нет ли для этого порта исправления, ожидающего своей очереди в link:https://www.FreeBSD.org/support/#gnats[Базе сообщений о проблемах]. Если это так, то предложенное исправление может сработать.
. Попросите помощи у мейнтейнера порта. Чтобы найти его адрес наберите команду `make maintainer` или просмотрите [.filename]#Makefile#. Не забудьте указать имя и версию порта (скопировав строчку `$FreeBSD:` из файла [.filename]#Makefile#) и включите в письмо весь вывод, предшествующий возникновению ошибки.
+
[NOTE]
====
Некоторые порты поддерживаются группой людей из extref:{mailing-list-faq}[списка рассылки], а не отдельными людьми. В большинстве таких случаев адрес мейнтейнера выглядит подобно следующему: mailto:freebsd-listname@FreeBSD.org[freebsd-listname@FreeBSD.org]. Пожалуйста, учтите это при формулировании ваших вопросов.

В частности, если мейнтейнер порта - mailto:ports@FreeBSD.org[ports@FreeBSD.org], то такой порт вообще никем не поддерживается. Решение проблем и поддержка, если и имеют место, то приходят от общества, которое подписано на тот список рассылки. Волонтёры требуются всегда!
====
+ 
Если вы не получили ответ, то воспользуйтесь командой man:send-pr[1] для посылки сообщения о проблеме (изучите extref:{problem-reports}[составление сообщений о проблеме во FreeBSD]).
. Исправьте его! В extref:{porters-handbook}[Руководстве по созданию портов] содержится подробная информация об инфраструктуре портов, так что вы сможете исправить редкий неработающий порт или даже предложить свой собственный!
. Воспользуйтесь man:pkg_add[1] и установите пакет вместо порта.
